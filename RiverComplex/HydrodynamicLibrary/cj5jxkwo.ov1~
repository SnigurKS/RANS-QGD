using AlgebraLibrary;
using MeshLibrary;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace HydrodynamicLibrary
{
    [Serializable]
    public class WaterTaskEliz
    {
        #region Искомые величины и объекты для работы
        public bool SerializeNow = false;
        public string status = "Running";
        public string err = "ok";
        public int Iter = 0;
        int beginIter = 0;
        //
        public double[] U = null;
        public double[] V = null;
        public double[] P = null;
        public double[] ErrP = null;
        public double[] S = null;
        public double[] K = null;
        public double[] E = null;
        public double[] nuT = null;
        public double[] rightK = null;
        public double[] rightE = null;
        public double[] ReT = null;
        double[] buffP = null;
        double[] buffU = null;
        double[] buffV = null;
        double[] buffS = null;
        double[] buffK = null;
        double[] buffE = null;
        double[] buffNu = null;
        /// <summary>
        /// напряжение на дне в полуцелый узлах
        /// </summary>
        public double[] BTau = null;
        /// <summary>
        /// напряжение на дне в целых узлах
        /// </summary>
        public double[] BTauC = null;
        public double[] arg = null;//аргумент к BTau для сплайна
        /// <summary>
        /// напряжение на верхней стенке в полуцелых узлах
        /// </summary>
        public double[] TTau = null;
        /// <summary>
        ///  напряжение на верхней стенке в целых узлах
        /// </summary>
        public double[] TTauC = null;
        public double[] argT = null;
        //
        /// <summary>
        /// максимальная горизонтальная скорость
        /// </summary>
        double U_max = 0;
        /// <summary>
        /// Рейнольдс x = U*H/nu
        /// </summary>
        double Re = 1;
        //
        double rho_w = 1000;
        /// <summary>
        /// штраф неразрывности в давлении
        /// </summary>
        double alpha_n = 0.5f;
        /// <summary>
        /// штраф регуляризационной части в давлении
        /// </summary>
        double alpha_r = 0.5f;
        /// <summary>
        /// штраф фиктивного источника на правой границе
        /// </summary>
        double alpha_p = 0.5f;
        //
        //для контроля потери массы
        //перемнные для баланса массы на входе и выходе
        public double Q_in = 0;
        public double Q_out = 0;
        /// <summary>
        /// ширина ленты
        /// </summary>
        public int BWidth = 0;
        // 
        /// <summary>
        /// лист связности центрального узла CV[i][0] и окружающих его элементов (треугольников) CV[i][1..7]
        /// </summary>
        int[][] CV = null;
        /// <summary>
        /// Лист связности внутренних КО, за исключением граничных узлов и узлов, где ставится WallFunc
        /// </summary>
        int[][] CV2 = null;
        /// <summary>
        /// Лист связности КО, где ставится WallFunc (ближайшие узлы к границе)
        /// </summary>
        int[][] CV_WallKnots = null;
        /// <summary>
        /// расстояние от пристеночного узла до дна по нормали
        /// </summary>
        double[] CV_WallKnotsDistance = null;
        /// <summary>
        /// Напряжение по пристеночной функции в пристеночных узлах
        /// </summary>
        double[] CV_WallTau = null;
        /// <summary>
        /// упрощеная версия хранения граничных треугольников у дна
        /// </summary>
        int[] BTriangles = null;
        /// <summary>
        /// массив связности окружающих дно точек в глобальной и локальной нумерации
        /// </summary>
        int[] CBottom = null;
        /// <summary>
        /// упрощеная версия хранения граничных треугольников у своб. пов.
        /// </summary>
        int[] TTriangles = null;
        /// <summary>
        /// массив связности окружающих своб пов. точек в глобальной и локальной нумерации
        /// </summary>
        int[] CTop = null;
        /// <summary>
        /// массив - [] граничная точка на правой стенке, [] вершины треугольников, создающих грань с этой точкой, но не лежащие на нранице
        /// </summary>
        int[][] RightKnotsList = null;
        int[][] TopKnotsList = null;
        //
        double[] BWallDistance = null, TWallDistance = null;
        /// <summary>
        /// генератор КЭ сетки для тестовой задачи
        /// </summary>
        public Mesh Mesh;
        /// <summary>
        /// решатель алгебраической задачи
        /// </summary>
        public SBand ABand = null;
        public SSystem Sys = null;
        /// <summary>
        /// секундомер
        /// </summary>
        [NonSerialized]
        Stopwatch stopW = null;
        [NonSerialized]
        TimeSpan timeSpan;
        int remainTimeMin;
        //
        #endregion
        //
        double[] X = null, Y = null;
        int iter = 1;
        double dt = 0.0001f;
        double tau = 0.01f;
        double Q = 0;
        public double dPdx = 0;
        [NonSerialized]
        double delta = 0.05;
        double relaxP = 0.1f;

        [NonSerialized]
        double[] U_start, V_start, K_start, E_start, NuT_start = null;
        [NonSerialized]
        double dpdx_start;

        double mu = 0;
        double nu_mol = 0;
        public int CountKnots = 0, CountTriangles = 0;
        public double Ucp = 0;// значение средней скорости по суммированию профиля
        double errP = 0.001f; // пмаксимальная допустимая погршность по давлению
        //
        double W = 0.01;
        double rho_s = 2650;
        double g = 9.8;
        double d = 0.00016;
        double kappa = 0.4327;
        double J = 0.00132;
        double gamma = 32.0 / 180 * 3.14;
        double sigma_s = 1;
        double sigma_k = 1;
        double sigma_e = 1.3;
        double C_e1 = 1.44;
        double C_e2 = 1.92;
        public double C_m = 0.09;
        double cm14 = 0;
        double y_p_0 = 11.5;
        //
        AlgorythmGauss AlgGauss = new AlgorythmGauss();
        Algorythm Alg = null;
        //
        public int _Nx = 0, _Ny = 0;
        double dy = 0;
        //
        int NBottom = 0;
        int NLeft = 0;
        int NRight = 0;
        int NTop = 0;
        //
        int[] BLeftKnots = null;
        int[] BRightKnots = null;
        int[] BBottomKnots = null;
        int[] BTopKnots = null;
        //
        double[] RBC = null;
        double[] BV = null;
        bool surf_flag = false;
        bool flag = true;
        double[] R = null;
        //
        double[] Sk = null;
        double[] b1 = null, b2 = null, b3 = null;
        double[] c1 = null, c2 = null, c3 = null;
        double[][] Lx10 = null;
        double[][] Lx32 = null;
        double[][] Ly01 = null;
        double[][] Ly23 = null;
        double[][] Alpha = null;
        double[][] SS = null;
        double[] S0 = null;
        double[][] _Lk = null;
        int[][] P1 = null;
        double[][] Nx = null;
        double[][] Ny = null;
        double[] Sx, Sy;
        [NonSerialized]
        alglib.spline1dinterpolant bufF; 
        //
        [NonSerialized]
        public double[] ConvK, ConvE, DiffK, DiffE, RegK, RegE;
        [NonSerialized]
        public double[] Tau = null;
        public WaterTaskEliz(WElizParameter p, Mesh m, SSystem a, Algorythm Alg, double[] U_start = null, double[] V_start = null, double[] K_start = null, double[] E_start = null, double[] NuT_start = null, double dpdx_start = 0)
        {
            CountKnots = m.CountKnots;
            CountTriangles = m.CountElems;
            this.Alg = Alg;
            //
            BWidth = m.BandWidth();
            //
            Sys = a;
            Sys.SetSystem(CountKnots, BWidth);
            //
            ABand = new SBand(CountKnots, BWidth);
            //
            NBottom = m.CountBottom;
            NTop = m.CountTop;
            InitMassives();
            //
            Re = p.Re;
            alpha_n = p.alpha_n;
            alpha_r = p.alpha_r;
            //alpha_p = p.alpha_p;
            Q = p.Q;
            dt = p.dt_local;
            tau = p.tau;
            relaxP = p.relaxP;
            mu = p.mu;
            nu_mol = mu / rho_w;
            errP = p.errP;
            surf_flag = p.surf_flag;
            iter = p.iter;
            //nu = p.nu_m;
            delta = p.delta;
            cm14 = Math.Pow(C_m, 0.25);
            //
            this.U_start = U_start;
            this.V_start = V_start;
            this.K_start = K_start;
            this.E_start = E_start;
            this.NuT_start = NuT_start;
            this.dpdx_start = dpdx_start;
            //ChangeMesh(m);
            double[] F = new double[] { 2, 7.89, 17.183, 29.276, 43.97, 142.7, 401.79, 696.68 };
            double[] y_p = new double[] { 2, 4, 6, 8, 10, 20, 40, 60 };
            alglib.spline1dbuildcubic(F, y_p, out bufF);
        }

        private void InitMassives()
        {
            U = new double[CountKnots];
            V = new double[CountKnots];
            P = new double[CountKnots];
            ErrP = new double[CountKnots];
            K = new double[CountKnots];
            E = new double[CountKnots];
            S = new double[CountKnots];
            nuT = new double[CountKnots];
            rightK = new double[CountKnots];
            rightE = new double[CountKnots];
            ReT = new double[CountKnots];
            BTauC = new double[NBottom];
            BTau = new double[NBottom];
            TTauC = new double[NTop];
            TTau = new double[NTop];
            //
            dudy = new double[NBottom];

        }
        public void ChangeMesh(Mesh m)
        {
            Mesh = m;
            //обновление геометрии
            Sk = Mesh.Sk;
            b1 = Mesh.b1;
            b2 = Mesh.b2;
            b3 = Mesh.b3;
            c1 = Mesh.c1;
            c2 = Mesh.c2;
            c3 = Mesh.c3;
            BLeftKnots = Mesh.LeftKnots;
            BRightKnots = Mesh.RightKnots;
            BBottomKnots = Mesh.BottomKnots;
            BTopKnots = Mesh.TopKnots;
            NLeft = Mesh.CountLeft;
            NRight = Mesh.CountRight;
            NTop = Mesh.CountTop;
            NBottom = Mesh.CountBottom;
            X = Mesh.X;
            Y = Mesh.Y;
            _Ny = NLeft;
            _Nx = NBottom;
            RightKnotsList = Mesh.CPRight;
            TopKnotsList = Mesh.CPTop;
            BTriangles = Mesh.BTriangles;
            CBottom = Mesh.CBottom;
            TTriangles = Mesh.TTriangles;
            CTop = Mesh.CTop;
            CV = Mesh.CVolumes;
            CV2 = Mesh.CV2;
            CV_WallKnots = Mesh.CV_WallKnots;
            CV_WallKnotsDistance = Mesh.CV_WallKnotsDistance;
            BWallDistance = Mesh.BWallDistance;
            TWallDistance = Mesh.TWallDistance;
            CV_WallTau = new double[CV_WallKnots.Length];
            Tau = new double[CountKnots];
            //
            Lx10 = Mesh.Lx10;
            Lx32 = Mesh.Lx32;
            Ly01 = Mesh.Ly01;
            Ly23 = Mesh.Ly23;
            Alpha = Mesh.Alpha;
            S0 = Mesh.S0;
            SS = Mesh.S;
            P1 = Mesh.P1;
            _Lk = Mesh.Lk;
            Nx = Mesh.Nx;
            Ny = Mesh.Ny;
            Sx = Mesh.Sx;
            Sy = Mesh.Sy;
            //
            InitialConditions();
        }

        
        /// <summary>
        /// Метод изменяет коэффициенты расчета (не физические величины!)
        /// </summary>
        /// <param name="p">Объект параметров расчета </param>
        public void ChangeParameters(WElizParameter p)
        {
            alpha_n = p.alpha_n;
            alpha_r = p.alpha_r;
            dt = p.dt_local;
            tau = p.tau;
            relaxP = p.relaxP;
            errP = p.errP;
            iter = p.iter;
            delta = p.delta;
        }

        void InitialConditions()
        {
            bool parabola = false;
            //Начальное условие для скорости
            double[] u0 = new double[NLeft];
            double y;
            double Hn = Y[BLeftKnots[0]] - Y[BLeftKnots[NLeft - 1]];
            //
            if (!surf_flag)
            {
                // расчет профиля
                if (U_start == null)
                {
                    // Профиль скорости на входе
                    U_max = 3.0 / 2.0 * Q / Hn;
                    double Uav = Q / Hn;
                    // --- по параболическому профилю
                    if (parabola)
                        dPdx = -8.0 * U_max * mu / Hn / Hn;
                    //-- по степенному профилю
                    //int N = -Convert.ToInt32((Hn / 2.0) * (Hn / 2.0) / mu / Uav * dPdx - 2);
                    int N = 20;
                    if (!parabola)
                        dPdx = -(2 + N) / (Hn / 2.0) / (Hn / 2.0) * mu * Uav;
                    for (int i = 0; i < NLeft; i++)
                    {
                        // U_left
                        int knot = BLeftKnots[i];
                        //-- параболический профиль скорости
                        if (parabola)
                        {
                            y = (Y[knot] - Y[0]);
                            U[knot] = (double)(1.0 / 2.0 / mu * dPdx * (y - Hn) * y);
                            // -- скорректированный параболический профиль
                            //y = (Y[knot] - Y[0]);
                            //U[knot] = (double)(1.0 / 2.0 / mu * dPdx * (y - Hn) * y);
                            //if (U[knot] > Uav)
                            //   U[knot] = Uav;
                        }
                        //-- степенной профиль
                        else
                        {
                            y = (Y[knot] - Y[0]) - Hn / 2.0;
                            U[knot] = (N + 2) / (N + 1) * Uav * (1 - Math.Pow(Math.Abs(y) / (Hn / 2.0), N + 1));
                        }
                        //
                        Ucp += U[knot];
                    }
                    for (int i = 0; i < NLeft; i++)
                    {
                        int knot = BLeftKnots[i];
                        y = (Y[knot] - Y[0]);
                        // k_left --> V
                        K[knot] = 0.005 * U[knot];//* U[knot];
                        // e_left  --> V
                        E[knot] = 0.1 * K[knot] * K[knot];// Math.Pow(C_m,0.75)*Math.Pow(K[knot],1.5)/0.1/H;
                        // s_left --> V
                        double Sz = 0.2 * (Q / Hn) * (Q / Hn) * (Q / Hn) / Hn / W;
                        double Kk = 1.4 * Math.Sqrt((rho_s - rho_w) * g * d) / kappa / Math.Sqrt(rho_w * g * Hn * J);
                        if (y == 0)
                            S[knot] = Sz;
                        else
                            S[knot] = Sz * Math.Pow(2 * d / y, Kk);
                        // nu_left --> V
                        // nu[knot] = C_m * K[knot] * K[knot] / (E[knot] + 1.0e-15);
                        //Тест
                        //P[knot] = -dPdx * (L - X[knot]);
                        ////

                    }
                    Ucp /= NLeft;
                }
                else
                {
                    //установка введенного профиля
                    if (NLeft == U_start.Length)
                    {
                        dPdx = dpdx_start;
                        for (int i = 0; i < NLeft; i++)
                        {
                            int knot = BLeftKnots[i];
                            U[i] = U_start[i];
                            V[i] = V_start[i];
                            K[i] = K_start[i];
                            E[i] = E_start[i];
                            nuT[i] = NuT_start[i];
                        }
                    }
                    else
                    {
                        throw new Exception("Введенный профиль скорости не совпадает по количеству точек с размерами сетки");
                    }
                    for (int i = 0; i < NLeft; i++)
                    {
                        int knot = BLeftKnots[i];
                        y = (Y[knot] - Y[0]);
                        double Sz = 0.2 * (Q / Hn) * (Q / Hn) * (Q / Hn) / Hn / W;
                        double Kk = 1.4 * Math.Sqrt((rho_s - rho_w) * g * d) / kappa / Math.Sqrt(rho_w * g * Hn * J);
                        if (y == 0)
                            S[knot] = Sz;
                        else
                            S[knot] = Sz * Math.Pow(2 * d / y, Kk);
                    }
                }
                // Гу слева прописывается во всей области
                for (int i = NLeft; i < CountKnots; i++)
                {
                    // k_left --> V
                    U[i] = U[i % NLeft];
                    // k_left --> V
                    K[i] = K[i % NLeft];
                    // e_left  --> V
                    E[i] = E[i % NLeft];
                    // s_left --> V
                    //S[i] = S[i % NLeft];
                    // e_left --> V
                    //nu[i] = nu[i % NLeft];
                }
                if (flag)
                {
                    buffP = new double[CountKnots];
                    buffU = new double[CountKnots];
                    buffV = new double[CountKnots];
                    buffS = new double[CountKnots];
                    buffK = new double[CountKnots];
                    buffE = new double[CountKnots];
                    buffNu = new double[CountKnots];
                    flag = false;
                }
                else
                {
                    // решение с предыдущего расчета
                    for (int i = 0; i < CountKnots; i++)
                    {
                        U[i] = buffU[i];
                        V[i] = buffV[i];
                        P[i] = buffP[i];
                        S[i] = buffS[i];
                        K[i] = buffK[i];
                        E[i] = buffE[i];
                        nuT[i] = buffNu[i];
                    }
                }
            }
            else
            {
                //for (int i = 0; i < NLeft; i++)
                //{
                //    int knot = BLeftKnots[i];
                //    y = Y[knot];
                //    U[knot] = (double)(1 / 2.0 / mu * dPdx * (-y) * y);
                //}
                // расчет профиля
                if (U_start == null)
                {
                    // Профиль скорости на входе
                    U_max = 3.0 / 2.0 * Q / (2*Hn);
                    double Uav = Q / Hn;
                    // --- по параболическому профилю
                    if (parabola)
                        dPdx = -8.0 * U_max * mu / Hn / Hn;
                    //-- по степенному профилю
                    //int N = -Convert.ToInt32((Hn) * (Hn) / mu / Uav * dPdx - 2);
                    int N = 50;
                    if (!parabola)
                        dPdx = -(2 + N) / Hn / Hn * mu * Uav;
                    for (int i = 0; i < NLeft; i++)
                    {
                        // U_left
                        int knot = BLeftKnots[i];
                        //-- параболический профиль скорости
                        if (parabola)
                        {
                            y = (Y[knot] - Y[0]);
                            U[knot] = (double)(1.0 / 2.0 / mu * dPdx * (y - Hn * 2) * y);
                            // -- скорректированный параболический профиль
                            //y = (Y[knot] - Y[0]);
                            //U[knot] = (double)(1.0 / 2.0 / mu * dPdx * (y - Hn * 2) * y);
                            //if (U[knot] > Uav)
                            //   U[knot] = Uav;
                        }
                        //-- степенной профиль
                        else
                        {
                            y = (Y[knot] - Y[0]) - Hn;
                            U[knot] = (N + 2) / (N + 1) * Uav * (1 - Math.Pow(Math.Abs(y) / (Hn), N + 1));
                            //if (knot!=0)
                            //{
                            //        U[knot] = Uav + 0.05;
                            //}
                        }
                        //
                        Ucp += U[knot];
                    }
                    for (int i = 0; i < NLeft; i++)
                    {
                        int knot = BLeftKnots[i];
                        y = (Y[knot] - Y[0]);
                        // k_left --> V
                        K[knot] = 0.005 * U[knot]; //* U[knot];
                        // e_left  --> V
                        E[knot] = 0.1 * K[knot] * K[knot]; // Math.Pow(C_m,0.75)*Math.Pow(K[knot],1.5)/0.1/H;
                        // s_left --> V
                        double Sz = 0.2 * (Q / Hn) * (Q / Hn) * (Q / Hn) / Hn / W;
                        double Kk = 1.4 * Math.Sqrt((rho_s - rho_w) * g * d) / kappa / Math.Sqrt(rho_w * g * Hn * J);
                        //if (y == 0)
                        //    S[knot] = Sz;
                        //else
                        //    S[knot] = Sz * Math.Pow(2 * d / y, Kk);
                        // тест
                        S[knot] = 1;
                        // nu_left --> V
                        // nu[knot] = C_m * K[knot] * K[knot] / (E[knot] + 1.0e-15);
                        //Тест
                        //P[knot] = -dPdx * (L - X[knot]);
                        ////
                        // По Роди
                        //double Uav = Q / Hn;
                        //K[knot] = 0.5e-4 * (U[knot] / Uav) * (U[knot] / Uav);
                        //double dudy = 0;
                        //int knot2 = 0;
                        //dy = Y[1] - Y[0];
                        //if (i != 0)
                        //{
                        //    knot2 = BLeftKnots[i - 1];
                        //    dudy = (U[knot] - U[knot2]) / dy;
                        //}
                        //else
                        //{
                        //    knot2 = BLeftKnots[i + 1];
                        //    dudy = (U[knot2] - U[knot]) / dy;
                        //}
                        //E[knot] = 0.1 * K[knot] * Math.Abs(dudy);

                    }
                    Ucp /= NLeft;
                }
                else
                {
                    //установка введенного профиля
                    if (NLeft == U_start.Length)
                    {
                        dPdx = dpdx_start;
                        for (int i = 0; i < NLeft; i++)
                        {
                            int knot = BLeftKnots[i];
                            U[i] = U_start[i];
                            V[i] = V_start[i];
                            K[i] = K_start[i];
                            E[i] = E_start[i];
                            nuT[i] = NuT_start[i];
                        }
                    }
                    else
                    {
                        throw new Exception("Введенный профиль скорости не совпадает по количеству точек с размерами сетки");
                    }
                    for (int i = 0; i < NLeft; i++)
                    {
                        int knot = BLeftKnots[i];
                        y = (Y[knot] - Y[0]);
                        // s_left --> V
                        double Sz = 0.2 * (Q / Hn) * (Q / Hn) * (Q / Hn) / Hn / W;
                        double Kk = 1.4 * Math.Sqrt((rho_s - rho_w) * g * d) / kappa / Math.Sqrt(rho_w * g * Hn * J);
                        //if (y == 0)
                        //    S[knot] = Sz;
                        //else
                        //    S[knot] = Sz * Math.Pow(2 * d / y, Kk);
                        // тест
                        S[knot] = 1;
                    }
                }
       
                for (int i = 0; i < NRight; i++)
                {
                    int knot = BRightKnots[i];
                    S[knot] = 2;
                }
                for (int i = 0; i < NBottom; i++)
                {
                    int knot = BBottomKnots[i];
                    S[knot] = 1;
                }
                for (int i = 0; i < NTop; i++)
                {
                    int knot = BTopKnots[i];
                    S[knot] = 2;
                }
                // Гу слева прописывается во всей области
                for (int i = NLeft; i < CountKnots; i++)
                {
                    // k_left --> V
                    U[i] = U[i % NLeft];
                    // k_left --> V
                    K[i] = K[i % NLeft];
                    // e_left  --> V
                    E[i] = E[i % NLeft];
                    // s_left --> V
                    //S[i] = S[i % NLeft];
                    // e_left --> V
                    //nu[i] = nu[i % NLeft];
                }
                if (flag)
                {
                    buffP = new double[CountKnots];
                    buffU = new double[CountKnots];
                    buffV = new double[CountKnots];
                    buffS = new double[CountKnots];
                    buffK = new double[CountKnots];
                    buffE = new double[CountKnots];
                    buffNu = new double[CountKnots];
                    flag = false;
                }
                else
                {
                    // решение с предыдущего расчета
                    for (int i = 0; i < CountKnots; i++)
                    {
                        U[i] = buffU[i];
                        V[i] = buffV[i];
                        P[i] = buffP[i];
                        S[i] = buffS[i];
                        K[i] = buffK[i];
                        E[i] = buffE[i];
                        nuT[i] = buffNu[i];
                    }
                }
            }
            //ГУ на левой стенке для КЭ
            // массивы для ГУ
            RBC = new double[NLeft];
            BV = new double[NLeft];
            //главные ГУ
            for (int i = 0; i < NLeft - 1; i++)
            {
                double y1 = Y[BLeftKnots[i]];
                double y2 = Y[BLeftKnots[i + 1]];
                //
                double r3 = (double)(-Math.Abs(y1 - y2) / 2.0 * (dPdx) * (-1));
                //
                BV[i] += r3;
                BV[i + 1] += r3;
            }
        }
        public void Run()
        {
            // --временно, потом убрать флаг no-serialized
            double[] F = new double[] { 2, 7.89, 17.183, 29.276, 43.97, 142.7, 401.79, 696.68 };
            double[] y_p = new double[] { 2, 4, 6, 8, 10, 20, 40, 60 };
            alglib.spline1dbuildcubic(F, y_p, out bufF);
            // так как поменяла имя переменной, она не хочет десериализоваться из сохраненных решений. То же с nuT[]
            if (nu_mol == 0)
                nu_mol = mu / rho_w;
            //Тест на перенос концентрации
            S = new double[CountKnots];
            for (int i = 0; i < NLeft; i++)
            {
                S[BLeftKnots[i]] = 1;
                S[BRightKnots[i]] = 2;
            }
            ReT = new double[CountKnots];
            //--
            double MaxError = 0; // максимальная порешность по давлению
            //pr(new Form1.ReportDelegate(Program.mm.Report), "Расчет гидродинамики");
            //////////
            int knot = 0;
            int count = 0;
            double sumBU = 0;
            //
            int knotUp = 0, knotRightU = 0, knotRightD = 0, knotDown = 0;
            //
            double[] Result = null;
            //
            double[] BV2 = new double[NRight];
            //
            stopW = new Stopwatch();
            double qf = 0;
            //WriteToData();
            try
            {
                //
                System.Object lockThis = new System.Object();
                //stopW.Start();
                for (int iteration = beginIter; iteration < iter; iteration++)
                {
                    // для просмотра компонентов ke уравнений
                    ConvK = new double[CountKnots];
                    ConvE = new double[CountKnots];
                    DiffK = new double[CountKnots];
                    DiffE = new double[CountKnots];
                    RegK = new double[CountKnots];
                    RegE = new double[CountKnots];
                    //
                    //System.Threading.Thread.Sleep(5000);
                    #region Расчет вязкости
                    OrderablePartitioner<Tuple<int, int>> rangePartitioner3 = Partitioner.Create(0, CountKnots);
                    Parallel.ForEach(rangePartitioner3,
                            (range, loopState) =>
                            {
                                for (int i = range.Item1; i < range.Item2; i++)
                                //for (int i = 0; i < CountKnots; i++)
                                {
                                    nuT[i] = C_m * K[i] * K[i] / (E[i] + 1e-9);
                                    if (nuT[i] < nu_mol)
                                        nuT[i] = nu_mol;

                                }
                            });
                    //ГУ справа - снос
                    for (int i = 0; i < NRight; i++)
                    {
                        knot = BRightKnots[i];
                        //
                        nuT[knot] = nuT[knot - NRight];
                    }
                  
                    //
                    #endregion
                    ///------Протестировано ОК
                    ////////////////// МКЭ давление /////////////////////
                    #region Расчет давления
                    Sys.ClearSystem();
                    if (iteration != 0)
                        Sys.SetX(Result);
                    // выделение памяти под результат решения задачи
                    Result = new double[Mesh.CountKnots];
                    //выделяем масивы для локальных правых частей
                    // основной цикл по конечным элементам
                    // вычисляем локальные матрицы жесткости и производим сборку глобальной матрицы жесткости
                    OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, Mesh.CountElems);
                    Parallel.ForEach(rangePartitioner,
                          (range, loopState) =>
                          {
                              for (int fe = range.Item1; fe < range.Item2; fe++)
                             //for (int fe = 0; fe < Mesh.CountElems; fe++)
                            {
                            // выделяем массивы для локальных матриц жесткости
                            double[][] M = new double[3][];
                            for (int k = 0; k < 3; k++)
                            {
                                M[k] = new double[3];
                            }
                            //и номера его вершин
                            int[] LKnots = Mesh.AreaElems[fe];
                            // нахождение площади треугольника
                            double LSk = Sk[fe];
                            // расчитываем геометрию элемента 
                            double Lb1 = b1[fe];
                            double Lb2 = b2[fe];
                            double Lb3 = b3[fe];
                            double Lc1 = c1[fe];
                            double Lc2 = c2[fe];
                            double Lc3 = c3[fe];
                            // расчет локальной матрицы жесткости для диффузионного члена
                            M[0][0] = -LSk * (Lb1 * Lb1 + Lc1 * Lc1);
                            M[0][1] = -LSk * (Lb1 * Lb2 + Lc1 * Lc2);
                            M[0][2] = -LSk * (Lb1 * Lb3 + Lc1 * Lc3);

                            M[1][0] = -LSk * (Lb2 * Lb1 + Lc2 * Lc1);
                            M[1][1] = -LSk * (Lb2 * Lb2 + Lc2 * Lc2);
                            M[1][2] = -LSk * (Lb2 * Lb3 + Lc2 * Lc3);

                            M[2][0] = -LSk * (Lb3 * Lb1 + Lc3 * Lc1);
                            M[2][1] = -LSk * (Lb3 * Lb2 + Lc3 * Lc2);
                            M[2][2] = -LSk * (Lb3 * Lb3 + Lc3 * Lc3);
                            lock (lockThis)
                                Sys.BuildMatrix(M, LKnots);
                                  }

                         });
                    R = new double[CountKnots];
                    //сборка правой части
                    OrderablePartitioner<Tuple<int, int>> rangePartitioner1 = Partitioner.Create(0, Mesh.CountElems);
                    Parallel.ForEach(rangePartitioner1,
                            (range, loopState) =>
                            {
                                for (int fe = range.Item1; fe < range.Item2; fe++)
                                //for (int fe = 0; fe < Mesh.CountElems; fe++)
                                {

                                    //for (int fe = 0; fe < Mesh.CountElem; fe++)
                                    //{
                                    double[] RR = new double[3];
                                    // получаем текущий конечный элемент
                                    int[] LKnots = Mesh.AreaElems[fe];
                                    int Lm1 = LKnots[0];
                                    int Lm2 = LKnots[1];
                                    int Lm3 = LKnots[2];
                                    // нахождение площади треугольника
                                    double LSk = Sk[fe];
                                    // расчитываем геометрию элемента 
                                    double Lb1 = b1[fe];
                                    double Lb2 = b2[fe];
                                    double Lb3 = b3[fe];
                                    double Lc1 = c1[fe];
                                    double Lc2 = c2[fe];
                                    double Lc3 = c3[fe];
                                    //
                                    double LU1 = U[Lm1]; double LU2 = U[Lm2]; double LU3 = U[Lm3];
                                    double LV1 = V[Lm1]; double LV2 = V[Lm2]; double LV3 = V[Lm3];
                                    //правая часть - неразрывность
                                    double LSR = rho_w * LSk / (3 * tau) * ((Lb1 * LU1 + Lb2 * LU2 + Lb3 * LU3) + (Lc1 * LV1 + Lc2 * LV2 + Lc3 * LV3));
                                    RR[0] = alpha_n * LSR;
                                    RR[1] = alpha_n * LSR;
                                    RR[2] = alpha_n * LSR;
                                    //правая часть поправка КГД
                                    double LBUU = (Lb1 * LU1 + Lb2 * LU2 + Lb3 * LU3) * (LU1 + LU2 + LU3);
                                    double LCUV = (Lc1 * LU1 + Lc2 * LU2 + Lc3 * LU3) * (LV1 + LV2 + LV3);
                                    double LBVU = (Lb1 * LV1 + Lb2 * LV2 + Lb3 * LV3) * (LU1 + LU2 + LU3);
                                    double LCVV = (Lc1 * LV1 + Lc2 * LV2 + Lc3 * LV3) * (LV1 + LV2 + LV3);
                                    //
                                    RR[0] += alpha_r * rho_w * LSk / 3.0 * (Lb1 * (LBUU + LCUV) + Lc1 * (LBVU + LCVV));
                                    RR[1] += alpha_r * rho_w * LSk / 3.0 * (Lb2 * (LBUU + LCUV) + Lc2 * (LBVU + LCVV));
                                    RR[2] += alpha_r * rho_w * LSk / 3.0 * (Lb3 * (LBUU + LCUV) + Lc3 * (LBVU + LCVV));
                                    //ГУ по Фомину
                                    //RR[0] += alpha_p * rho_w * LSk / 3.0 * (1 / dt * qf);
                                    //RR[1] += alpha_p * rho_w * LSk / 3.0 * (1 / dt * qf);
                                    //RR[2] += alpha_p * rho_w * LSk / 3.0 * (1 / dt * qf);
                                    //
                                    //для отображения невязки
                                    R[Lm1] += RR[0];
                                    R[Lm2] += RR[1];
                                    R[Lm3] += RR[2];
                                    //}
                                }

                            });
                    //
                    Sys.BuildRight(R, null);
                    //ГУ слева
                    Sys.BuildRight(BV, BLeftKnots);
                    //главные ГУ справа 2
                    //if (iteration == iter - 1)
                    //    DongBC_PE();
                    //else
                    //    DongBC_P();
                    // ГУ P=0 справа    //
                    RBC = new double[NRight];
                    // для Dong убрать  //
                    Sys.SetBoundary(RBC, BRightKnots);
                    //Sys.SetBoundary(BV2, BRightKnots);
                    //Sys.SetBoundary(new double[] { 0 }, new int[] { BRightKnots[NRight - 1] }); // задаем ноль в правой верхней точке
                    // решение системы алгебраических уравнений
                    Sys.Accept(Alg);
                    Result = Sys.GetX;
                    //для отладки
                    for (int i = 0; i < NLeft; i++)
                        R[BLeftKnots[i]] += BV[i];
                    for (int i = 0; i < NRight; i++)
                        R[BRightKnots[i]] = 0;
                    //
                    // релаксация решения, буферизация и вычисление погрешности
                    MaxError = 0;// масимальная ошибка в области
                    for (int i = 0; i < CountKnots; i++)
                    {
                        //релаксация
                        P[i] = (1 - relaxP) * P[i] + relaxP * Result[i];
                        //вычисление погрешности
                        double CurErr = Math.Abs((P[i] - buffP[i]) / P[i]);
                        if (MaxError < CurErr)
                            MaxError = CurErr;
                        ErrP[i] = CurErr;
                        //буферизация
                        buffP[i] = P[i];
                    }
                    #endregion

                    ///------Протестировано ОК
                    ////////////////// МКО скорость /////////////////////
                    #region Расчет скоростей
                    //
                    //цикл по внутренним КО
                    if (iteration == 0)
                        iteration = QHDUS(iteration);
                    else
                        iteration = QHDUS2(iteration);
                    if (err != "ok")
                        return;
                    //

                    #endregion
                    // 
                    #region Расчет K, epsilon
                    iteration = QHDKE(iteration);
                    
                    #endregion
                    //
                    
                    
                        //
                        for (int i = 0; i < CountKnots; i++)
                        {
                            buffU[i] = U[i];
                            buffV[i] = V[i];
                            buffK[i] = K[i];
                            buffE[i] = E[i];
                            buffS[i] = S[i];
                            buffNu[i] = nuT[i];
                        }
                    //выход из цикла если ошибка меньше или равно errP
                    if (MaxError <= errP)
                    {
                        Iter = iteration + 1;
                        break;
                    }
                    //
                    beginIter = iteration + 1;
                    if (SerializeNow)
                    {
                        status = "Stoped";
                        return;
                    }
                    Iter = iteration + 1;
                    //расход на входе и выходе из расчетной области
                    Q_in = 0; Q_out = 0;
                    for (int k = 0; k < NLeft - 1; k++)
                    {
                        int a = BLeftKnots[k];
                        int b = BLeftKnots[k + 1];
                        Q_in += (U[a] + U[b]) * 0.5f * Math.Abs(Y[a] - Y[b]);
                    }
                    //
                    for (int k = 1; k < NRight - 1; k++)
                    {
                        int a = BRightKnots[k];
                        int b = BRightKnots[k + 1];
                        Q_out += (U[a] + U[b]) * 0.5f * Math.Abs(Y[a] - Y[b]);
                    }

                    //if ((iteration % 500 == 0) && (iteration != 0))
                    //{
                    //    OutflowProfileInflow();
                    //}
                }
                //Iter = iter;
                
                beginIter = 0;
                //Q_in = 0; Q_out = 0;
                //for (int k = 0; k < NLeft - 1; k++)
                //{
                //    int a = BLeftKnots[k];
                //    int b = BLeftKnots[k + 1];
                //    Q_in += (U[a] + U[b]) * 0.5f * Math.Abs(Y[a] - Y[b]);
                //}
                ////
                //for (int k = 1; k < NRight - 1; k++)
                //{
                //    int a = BRightKnots[k];
                //    int b = BRightKnots[k + 1];
                //    Q_out += (U[a] + U[b]) * 0.5f * Math.Abs(Y[a] - Y[b]);
                //}
            }
            catch (Exception ex)
            {
                err = err + "WaterTask.Run " + ex.Message;
            }
            //вычисление сдвиговых напряжений на дне через скорости по уравненям Рейнольдса
            ////ShearStresses();
            //ShearStress(BBottomKnots, CBottom, BTriangles, out BTau, out BTauC, out arg);
            //ShearStress(BTopKnots, CTop, TTriangles, out TTau, out TTauC, out argT);
            //
            // напряжения на дне находятся по функции стенки при вычислении k-e
        }
        /// <summary>
        /// Метод переносит профиль с выхода из расчетной области на вход для установления
        /// Справедливо только, когда количество узлов на входной и выходной стенках совпадают
        /// </summary>
        private void OutflowProfileInflow()
        {
            int lknot = BLeftKnots[0];
            int rknot = BRightKnots[NRight-1]; // берем профиль на выходной границе
            double dx = Mesh.X[BBottomKnots[1]];
            //int rknot = Convert.ToInt32(0.75 / dx - 1) * _Ny - 1;
            for (int i = 0; i < NLeft; i++)
            {
                //lknot = BLeftKnots[i];
                //rknot = BRightKnots[i];
                //
                U[lknot] = U[rknot];
                V[lknot] = V[rknot];
                //P[lknot] = P[rknot];
                //
                //S[lknot] = S[rknot];
                nuT[lknot] = nuT[rknot];
                K[lknot] = K[rknot];
                E[lknot] = E[rknot];
                lknot--;
                rknot--;
            }
            // меняем dPdx_in
            //dPdx = 0;
            //int Knot = 0;
            //// -- с середины области
            //double point = 0.45;
            //for (int j = 0; j < NBottom; j++)
            //{
            //    Knot = BBottomKnots[j];
            //    if ((point - X[Knot]) < 0.0001)
            //        break;
            //}
            //for (int i = 0; i < NLeft; i++)
            //{
            //    dPdx += (P[Knot] - P[Knot - _Ny]) / (X[Knot] - X[Knot - _Ny]);
            //    Knot++;

            //}
            //dPdx /= NRight;
            ////--
            // -- с выходной границы
            //for (int i = 0; i < NRight; i++)
            //{
            //    // с сечения на выходе
            //    Knot = BRightKnots[i];
            //    dPdx += (P[Knot] - P[Knot - _Ny]) / (X[Knot] - X[Knot - _Ny]);

            //}
            ////--
            //dPdx /= NRight;
            // -- с середины выходной границы
            //Knot = BRightKnots[_Ny/2];
            //dPdx = (P[Knot] - P[Knot - _Ny]) / (X[Knot] - X[Knot - _Ny]);
            ////
            //for (int i = 0; i < NLeft - 1; i++)
            //{
            //    double y1 = Y[BLeftKnots[i]];
            //    double y2 = Y[BLeftKnots[i + 1]];
            //    //
            //    double r3 = (double)(-Math.Abs(y1 - y2) / 2.0 * (dPdx) * (-1));
            //    //
            //    BV[i] += r3;
            //    BV[i + 1] += r3;
            //}
        }
        private int QHDUS(int iteration)
        {
            OrderablePartitioner<Tuple<int, int>> rangePartitioner3 = Partitioner.Create(0, CV.Length);
            Parallel.ForEach(rangePartitioner3,
                    (range, loopState) =>
                    {
                        for (int i = range.Item1; i < range.Item2; i++)
                        //for (int i = 0; i < CV.Length; i++)
                        {
                            double LsummU = 0;//потоки U скорости
                            double LsummV = 0;//потоки V скорости
                            double LsummS = 0;//потоки s концентрации
                            //
                            int p0 = CV[i][0];
                            int jj = CV[i].Length - 1;//количество КО, связанных с данным узлом
                            for (int j = 0; j < jj; j++)
                            {
                                double _lx10 = Lx10[p0][j]; double _lx32 = Lx32[p0][j];
                                double _ly01 = Ly01[p0][j]; double _ly23 = Ly23[p0][j];
                                //площадь
                                double LS = SS[p0][j];
                                //сосоедние элементы
                                int Lv1 = CV[i][(j + 1) % jj + 1];
                                int Lv2 = CV[i][j + 1];
                                //вторая точка общей грани
                                int Lp1 = P1[p0][j];
                                //находим значения функций в центрах масс 1ого и 2ого треугольника как средние значения по элементу
                                int[] Knots1 = Mesh.AreaElems[Lv1];
                                int Lt1 = Knots1[0]; int Lt2 = Knots1[1]; int Lt3 = Knots1[2];
                                double LUc1 = (U[Lt1] + U[Lt2] + U[Lt3]) / 3.0;
                                double LVc1 = (V[Lt1] + V[Lt2] + V[Lt3]) / 3.0;
                                double LPc1 = (P[Lt1] + P[Lt2] + P[Lt3]) / 3.0;
                                double LSc1 = (S[Lt1] + S[Lt2] + S[Lt3]) / 3.0;
                                int[] Knots2 = Mesh.AreaElems[Lv2];
                                int Lz1 = Knots2[0]; int Lz2 = Knots2[1]; int Lz3 = Knots2[2];
                                double LUc2 = (U[Lz1] + U[Lz2] + U[Lz3]) / 3.0;
                                double LVc2 = (V[Lz1] + V[Lz2] + V[Lz3]) / 3.0;
                                double LPc2 = (P[Lz1] + P[Lz2] + P[Lz3]) / 3.0;
                                double LSc2 = (S[Lz1] + S[Lz2] + S[Lz3]) / 3.0;
                                //значения производных в точке пересечения граней
                                double Ls2 = 2 * LS;
                                double Ldudx = ((LUc1 - LUc2) * _ly01 + (U[Lp1] - U[p0]) * _ly23) / Ls2;
                                double Ldudy = ((LUc1 - LUc2) * _lx10 + (U[Lp1] - U[p0]) * _lx32) / Ls2;
                                double Ldvdx = ((LVc1 - LVc2) * _ly01 + (V[Lp1] - V[p0]) * _ly23) / Ls2;
                                double Ldvdy = ((LVc1 - LVc2) * _lx10 + (V[Lp1] - V[p0]) * _lx32) / Ls2;
                                double Ldpdx = ((LPc1 - LPc2) * _ly01 + (P[Lp1] - P[p0]) * _ly23) / Ls2;
                                double Ldpdy = ((LPc1 - LPc2) * _lx10 + (P[Lp1] - P[p0]) * _lx32) / Ls2;
                                double Ldsdx = ((LSc1 - LSc2) * _ly01 + (S[Lp1] - S[p0]) * _ly23) / Ls2;
                                double Ldsdy = ((LSc1 - LSc2) * _lx10 + (S[Lp1] - S[p0]) * _lx32) / Ls2;
                                //внешняя нормаль к грани КО (контуру КО)
                                double Lnx = Nx[p0][j]; double Lny = Ny[p0][j];
                                ////значение функций в точке пересечения грани КО и основной грани
                                double Lalpha = Alpha[p0][j];
                                double LUcr = Lalpha * U[p0] + (1 - Lalpha) * U[Lp1];
                                double LVcr = Lalpha * V[p0] + (1 - Lalpha) * V[Lp1];
                                double LPcr = Lalpha * P[p0] + (1 - Lalpha) * P[Lp1];
                                double LScr = Lalpha * S[p0] + (1 - Lalpha) * S[Lp1];
                                double LNucr = Lalpha * nuT[p0] + (1 - Lalpha) * nuT[Lp1] + nu_mol;
                                double LKcr = Lalpha * K[p0] + (1 - Lalpha) * K[Lp1];
                                //длина текущего фрагмента внешнего контура КО
                                double LLk = _Lk[p0][j];
                                //расчет потоков
                                double LpressU = -1.0 / rho_w * LPcr * Lnx - 2.0 / 3.0 * LKcr * Lnx;
                                double LconvU = -LUcr * LUcr * Lnx - (LUcr * LVcr) * Lny;
                                double LdiffU = (nu_mol + LNucr) * (2.0 * Ldudx * Lnx - 2.0 / 3.0 * (Ldudx + Ldvdy) * Lnx + Ldudy * Lny + Ldvdx * Lny);
                                double wx = tau * (LUcr * Ldudx + LVcr * Ldudy + 1.0 / rho_w * Ldpdx);
                                double wy = tau * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0 / rho_w * Ldpdy);
                                double LregU1 = 2.0 * LUcr * wx * Lnx;
                                double LregU2 = (LVcr * wx + LUcr * wy) * Lny;
                                double LregU = LregU1 + LregU2;
                                LsummU += (LconvU + LdiffU + LregU + LpressU) * LLk;
                                //                  
                                double LpressV = -1.0 / rho_w * LPcr * Lny - 2.0 / 3.0 * LKcr * Lny;
                                double LconvV = -(LUcr * LVcr) * Lnx - LVcr * LVcr * Lny;
                                double LdiffV = (nu_mol + LNucr) * (2.0 * Ldvdy * Lny - 2.0 / 3.0 * (Ldudx + Ldvdy) * Lny + Ldvdx * Lnx + Ldudy * Lnx);
                                double LregV1 = 2.0 * LVcr * wy * Lny;
                                double LregV2 = (LVcr * wx + LUcr * wy) * Lnx;
                                double LregV = LregV1 + LregV2;
                                LsummV += (LconvV + LdiffV + LregV + LpressV) * LLk;
                                //
                                double LconvS = -LScr * (LUcr + W * Math.Sin(J)) * Lnx - LScr * (LVcr - W * Math.Cos(J)) * Lny;
                                double LdiffS = LNucr / sigma_s * (Ldsdx * Lnx + Ldsdy * Lny);
                                double LregS = LScr * (wx * Lnx + wy * Lny);
                                LsummS += (LconvS + LdiffS + LregS) * LLk;
                            }
                            //
                            U[p0] = U[p0] + dt / S0[p0] * LsummU;
                            V[p0] = V[p0] + dt / S0[p0] * LsummV;
                            S[p0] = S[p0] + dt / S0[p0] * LsummS;
                            //
                            if (double.IsNaN(U[p0]))
                            {
                                err = " U в бесконечность";
                                //iteration = iter;
                                break;
                            }
                            //}

                        }

                    });
            //если задача со свободной поверхностью
            //if (surf_flag)
            //    U[BLeftKnots[0]] = U[BTopKnots[BTopKnots.Length - 2]];
            //ГУ Dong
            //if (iteration == iter - 1)
            //    DongBC_UE();
            //else
            //    DongBC_U();
            //ГУ справа - снос
            for (int i = 0; i < NRight; i++)
            {
                int knot = BRightKnots[i];
                //
                U[knot] = U[knot - NRight];
                V[knot] = V[knot - NRight];
                //S[knot] = S[knot - NRight];
            }
            for (int i = 0; i < NTop; i++)
            {
                int knot = BTopKnots[i];
                S[knot] = S[knot - 1];
                knot = BBottomKnots[i];
                S[knot] = S[knot + 1];
            }
            //
            ////----------------
            //если задача со свободной поверхностью
            if (surf_flag)
            {
                for (int i = 0; i < NTop; i++)
                {
                    int knot = BTopKnots[i];
                    U[knot] = U[knot - 1];
                    V[knot] = 0;
                }
            }
            //
            return iteration;
        }
        private int QHDUS2(int iteration)
        {
            #region Расчет u, v во внутренних узлах без узлов WallKnot
            OrderablePartitioner<Tuple<int, int>> rangePartitioner3 = Partitioner.Create(0, CV2.Length);
            Parallel.ForEach(rangePartitioner3,
                    (range, loopState) =>
                    {
                        for (int i = range.Item1; i < range.Item2; i++)
                    //for (int i = 0; i < CV2.Length; i++)
                    {
                        double LsummU = 0;//потоки U скорости
                        double LsummV = 0;//потоки V скорости
                        double LsummS = 0;//потоки s концентрации
                        //
                        int p0 = CV2[i][0];
                        int jj = CV2[i].Length - 1;//количество КО, связанных с данным узлом
                        for (int j = 0; j < jj; j++)
                        {
                            double _lx10 = Lx10[p0][j]; double _lx32 = Lx32[p0][j];
                            double _ly01 = Ly01[p0][j]; double _ly23 = Ly23[p0][j];
                            //площадь
                            double LS = SS[p0][j];
                            //сосоедние элементы
                            int Lv1 = CV2[i][(j + 1) % jj + 1];
                            int Lv2 = CV2[i][j + 1];
                            //вторая точка общей грани
                            int Lp1 = P1[p0][j];
                            //находим значения функций в центрах масс 1ого и 2ого треугольника как средние значения по элементу
                            int[] Knots1 = Mesh.AreaElems[Lv1];
                            int Lt1 = Knots1[0]; int Lt2 = Knots1[1]; int Lt3 = Knots1[2];
                            double LUc1 = (U[Lt1] + U[Lt2] + U[Lt3]) / 3.0;
                            double LVc1 = (V[Lt1] + V[Lt2] + V[Lt3]) / 3.0;
                            double LPc1 = (P[Lt1] + P[Lt2] + P[Lt3]) / 3.0;
                            double LSc1 = (S[Lt1] + S[Lt2] + S[Lt3]) / 3.0;
                            int[] Knots2 = Mesh.AreaElems[Lv2];
                            int Lz1 = Knots2[0]; int Lz2 = Knots2[1]; int Lz3 = Knots2[2];
                            double LUc2 = (U[Lz1] + U[Lz2] + U[Lz3]) / 3.0;
                            double LVc2 = (V[Lz1] + V[Lz2] + V[Lz3]) / 3.0;
                            double LPc2 = (P[Lz1] + P[Lz2] + P[Lz3]) / 3.0;
                            double LSc2 = (S[Lz1] + S[Lz2] + S[Lz3]) / 3.0;
                            //значения производных в точке пересечения граней
                            double Ls2 = 2 * LS;
                            double Ldudx = ((LUc1 - LUc2) * _ly01 + (U[Lp1] - U[p0]) * _ly23) / Ls2;
                            double Ldudy = ((LUc1 - LUc2) * _lx10 + (U[Lp1] - U[p0]) * _lx32) / Ls2;
                            double Ldvdx = ((LVc1 - LVc2) * _ly01 + (V[Lp1] - V[p0]) * _ly23) / Ls2;
                            double Ldvdy = ((LVc1 - LVc2) * _lx10 + (V[Lp1] - V[p0]) * _lx32) / Ls2;
                            double Ldpdx = ((LPc1 - LPc2) * _ly01 + (P[Lp1] - P[p0]) * _ly23) / Ls2;
                            double Ldpdy = ((LPc1 - LPc2) * _lx10 + (P[Lp1] - P[p0]) * _lx32) / Ls2;
                            double Ldsdx = ((LSc1 - LSc2) * _ly01 + (S[Lp1] - S[p0]) * _ly23) / Ls2;
                            double Ldsdy = ((LSc1 - LSc2) * _lx10 + (S[Lp1] - S[p0]) * _lx32) / Ls2;
                            //внешняя нормаль к грани КО (контуру КО)
                            double Lnx = Nx[p0][j]; double Lny = Ny[p0][j];
                            ////значение функций в точке пересечения грани КО и основной грани
                            double Lalpha = Alpha[p0][j];
                            double LUcr = Lalpha * U[p0] + (1 - Lalpha) * U[Lp1];
                            double LVcr = Lalpha * V[p0] + (1 - Lalpha) * V[Lp1];
                            double LPcr = Lalpha * P[p0] + (1 - Lalpha) * P[Lp1];
                            double LScr = Lalpha * S[p0] + (1 - Lalpha) * S[Lp1];
                            double LNucr = Lalpha * nuT[p0] + (1 - Lalpha) * nuT[Lp1] + nu_mol;
                            double LKcr = Lalpha * K[p0] + (1 - Lalpha) * K[Lp1];               
                            //длина текущего фрагмента внешнего контура КО
                            double LLk = _Lk[p0][j];
                            //расчет потоков
                            double LpressU = -1.0 / rho_w * LPcr * Lnx - 2.0 / 3.0 * LKcr * Lnx;
                            double LconvU = -LUcr * LUcr * Lnx - (LUcr * LVcr) * Lny;
                            double LdiffU = (nu_mol + LNucr) * (2.0 * Ldudx * Lnx - 2.0 / 3.0 * (Ldudx + Ldvdy) * Lnx + Ldudy * Lny + Ldvdx * Lny);
                            double wx = tau * (LUcr * Ldudx + LVcr * Ldudy + 1.0 / rho_w * Ldpdx);
                            double wy = tau * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0 / rho_w * Ldpdy);
                            double LregU1 = 2.0 * LUcr * wx * Lnx;
                            double LregU2 = (LVcr * wx + LUcr * wy) * Lny;
                            double LregU = LregU1 + LregU2;
                            LsummU += (LconvU + LdiffU + LregU + LpressU) * LLk;
                            //                  
                            double LpressV = -1.0 / rho_w * LPcr * Lny - 2.0 / 3.0 * LKcr * Lny;
                            double LconvV = -(LUcr * LVcr) * Lnx - LVcr * LVcr * Lny;
                            double LdiffV = (nu_mol + LNucr) * (2.0 * Ldvdy * Lny - 2.0 / 3.0 * (Ldudx + Ldvdy) * Lny + Ldvdx * Lnx + Ldudy * Lnx);
                            double LregV1 = 2.0 * LVcr * wy * Lny;
                            double LregV2 = (LVcr * wx + LUcr * wy) * Lnx;
                            double LregV = LregV1 + LregV2;
                            LsummV += (LconvV + LdiffV + LregV + LpressV) * LLk;
                            //
                            double LconvS = -LScr * (LUcr + W * Math.Sin(J)) * Lnx - LScr * (LVcr - W * Math.Cos(J)) * Lny;
                            double LdiffS = LNucr / sigma_s * (Ldsdx * Lnx + Ldsdy * Lny);
                            double LregS = LScr * (wx * Lnx + wy * Lny);
                            LsummS += (LconvS + LdiffS + LregS) * LLk;
                        }
                        //
                        U[p0] = U[p0] + dt / S0[p0] * LsummU;
                        V[p0] = V[p0] + dt / S0[p0] * LsummV;
                        S[p0] = S[p0] + dt / S0[p0] * LsummS;
                        //
                        if (double.IsNaN(U[p0]))
                        {
                            err = " U в бесконечность";
                            //iteration = iter;
                            break;
                        }
                        //}

                    }

              });
            #endregion
            //
            #region Расчет u, v в узлах WallKnot
            rangePartitioner3 = Partitioner.Create(0, CV_WallKnots.Length);
            Parallel.ForEach(rangePartitioner3,
                    (range, loopState) =>
                    {
                        for (int i = range.Item1; i < range.Item2; i++)
                        //for (int i = 0; i < CV_WallKnots.Length; i++)
                        {
                            double LsummU = 0;//потоки U скорости
                            double LsummV = 0;//потоки V скорости
                            double LsummS = 0;//потоки s концентрации
                            //
                            int p0 = CV_WallKnots[i][0];
                            int jj = CV_WallKnots[i].Length - 1; // количество КО, связанных с данным узлом
                            for (int j = 0; j < jj; j++)
                            {
                                double _lx10 = Lx10[p0][j]; double _lx32 = Lx32[p0][j];
                                double _ly01 = Ly01[p0][j]; double _ly23 = Ly23[p0][j];
                                //площадь
                                double LS = SS[p0][j];
                                //сосоедние элементы
                                int Lv1 = CV_WallKnots[i][(j + 1) % jj + 1];
                                int Lv2 = CV_WallKnots[i][j + 1];
                                //вторая точка общей грани
                                int Lp1 = P1[p0][j];
                                //находим значения функций в центрах масс 1ого и 2ого треугольника как средние значения по элементу
                                int[] Knots1 = Mesh.AreaElems[Lv1];
                                int Lt1 = Knots1[0]; int Lt2 = Knots1[1]; int Lt3 = Knots1[2];
                                double LUc1 = (U[Lt1] + U[Lt2] + U[Lt3]) / 3.0;
                                double LVc1 = (V[Lt1] + V[Lt2] + V[Lt3]) / 3.0;
                                double LPc1 = (P[Lt1] + P[Lt2] + P[Lt3]) / 3.0;
                                double LSc1 = (S[Lt1] + S[Lt2] + S[Lt3]) / 3.0;
                                int[] Knots2 = Mesh.AreaElems[Lv2];
                                int Lz1 = Knots2[0]; int Lz2 = Knots2[1]; int Lz3 = Knots2[2];
                                double LUc2 = (U[Lz1] + U[Lz2] + U[Lz3]) / 3.0;
                                double LVc2 = (V[Lz1] + V[Lz2] + V[Lz3]) / 3.0;
                                double LPc2 = (P[Lz1] + P[Lz2] + P[Lz3]) / 3.0;
                                double LSc2 = (S[Lz1] + S[Lz2] + S[Lz3]) / 3.0;
                                //значения производных в точке пересечения граней
                                double Ls2 = 2 * LS;
                                double Ldudx = ((LUc1 - LUc2) * _ly01 + (U[Lp1] - U[p0]) * _ly23) / Ls2;
                                double Ldudy = ((LUc1 - LUc2) * _lx10 + (U[Lp1] - U[p0]) * _lx32) / Ls2;
                                double Ldvdx = ((LVc1 - LVc2) * _ly01 + (V[Lp1] - V[p0]) * _ly23) / Ls2;
                                double Ldvdy = ((LVc1 - LVc2) * _lx10 + (V[Lp1] - V[p0]) * _lx32) / Ls2;
                                double Ldpdx = ((LPc1 - LPc2) * _ly01 + (P[Lp1] - P[p0]) * _ly23) / Ls2;
                                double Ldpdy = ((LPc1 - LPc2) * _lx10 + (P[Lp1] - P[p0]) * _lx32) / Ls2;
                                double Ldsdx = ((LSc1 - LSc2) * _ly01 + (S[Lp1] - S[p0]) * _ly23) / Ls2;
                                double Ldsdy = ((LSc1 - LSc2) * _lx10 + (S[Lp1] - S[p0]) * _lx32) / Ls2;
                                //внешняя нормаль к грани КО (контуру КО)
                                double Lnx = Nx[p0][j]; double Lny = Ny[p0][j];
                                ////значение функций в точке пересечения грани КО и основной грани
                                double Lalpha = Alpha[p0][j];
                                double LUcr = Lalpha * U[p0] + (1 - Lalpha) * U[Lp1];
                                double LVcr = Lalpha * V[p0] + (1 - Lalpha) * V[Lp1];
                                double LPcr = Lalpha * P[p0] + (1 - Lalpha) * P[Lp1];
                                double LScr = Lalpha * S[p0] + (1 - Lalpha) * S[Lp1];
                                double LNucr = Lalpha * nuT[p0] + (1 - Lalpha) * nuT[Lp1] + nu_mol;
                                double LKcr = Lalpha * K[p0] + (1 - Lalpha) * K[Lp1];
                                //длина текущего фрагмента внешнего контура КО
                                double LLk = _Lk[p0][j];
                                //расчет потоков
                                double LpressU = -1.0 / rho_w * LPcr * Lnx;
                                double LconvU = -LUcr * LUcr * Lnx - (LUcr * LVcr) * Lny;
                                double LdiffU = 0;
                                if (Lp1 % NLeft == 0) //|| (Lp1 + 1) % NLeft == 0) //только для нижней границы
                                {
                                    double Tau = CV_WallTau[i];
                                    int sl = Lp1 / NLeft - p0 / NLeft;
                                    if (sl == -1)// левее рассматриваемого узла
                                        Tau = BTau[i];
                                    if (sl == 1)// правее рассматриваемого узла
                                        Tau = BTau[i + 1];
                                    LdiffU = Tau / rho_w * Lny - nu_mol * 2.0 / 3.0 * (Ldudx + Ldvdy) * Lnx;
                                }
                                else
                                    LdiffU = (nu_mol + LNucr) * (2.0 * Ldudx * Lnx - 2.0 / 3.0 * (Ldudx + Ldvdy) * Lnx + Ldudy * Lny + Ldvdx * Lny) - 2.0 / 3.0 * LKcr * Lnx;
                                double wx = tau * (LUcr * Ldudx + LVcr * Ldudy + 1.0 / rho_w * Ldpdx);
                                double wy = tau * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0 / rho_w * Ldpdy);
                                double LregU1 = 2.0 * LUcr * wx * Lnx;
                                double LregU2 = (LVcr * wx + LUcr * wy) * Lny;
                                double LregU = LregU1 + LregU2;
                                LsummU += (LconvU + LdiffU + LregU + LpressU) * LLk;
                                //                  
                                double LpressV = -1.0 / rho_w * LPcr * Lny;
                                double LconvV = -(LUcr * LVcr) * Lnx - LVcr * LVcr * Lny;
                                double LdiffV = 0;
                                if (Lp1 % NLeft == 0)// || (Lp1 + 1) % NLeft == 0) // только для нижней границе
                                {
                                    double Tau = CV_WallTau[i];
                                    int sl = Lp1 / NLeft - p0 / NLeft;
                                    if (sl == -1)// левее рассматриваемого узла
                                        Tau = BTau[i];
                                    if (sl == 1)// правее рассматриваемого узла
                                        Tau = BTau[i + 1];
                                    LdiffV = Tau / rho_w * Lnx - nu_mol * 2.0 / 3.0 * (Ldudx + Ldvdy) * Lny;
                                }
                                else
                                    LdiffV = (nu_mol + LNucr) * (2.0 * Ldvdy * Lny - 2.0 / 3.0 * (Ldudx + Ldvdy) * Lny + Ldvdx * Lnx + Ldudy * Lnx) - 2.0 / 3.0 * LKcr * Lny;
                                double LregV1 = 2.0 * LVcr * wy * Lny;
                                double LregV2 = (LVcr * wx + LUcr * wy) * Lnx;
                                double LregV = LregV1 + LregV2;
                                LsummV += (LconvV + LdiffV + LregV + LpressV) * LLk;
                                //
                                double LconvS = -LScr * (LUcr + W * Math.Sin(J)) * Lnx - LScr * (LVcr - W * Math.Cos(J)) * Lny;
                                double LdiffS = LNucr / sigma_s * (Ldsdx * Lnx + Ldsdy * Lny);
                                double LregS = LScr * (wx * Lnx + wy * Lny);
                                LsummS += (LconvS + LdiffS + LregS) * LLk;
                            }
                            //
                            U[p0] = U[p0] + dt / S0[p0] * LsummU;
                            V[p0] = V[p0] + dt / S0[p0] * LsummV;
                            S[p0] = S[p0] + dt / S0[p0] * LsummS;
                            //
                            if (double.IsNaN(U[p0]))
                            {
                                err = " U в бесконечность";
                                //iteration = iter;
                                break;
                            }
                            //}

                        }

                    });
            #endregion
            //если задача со свободной поверхностью
            //if (surf_flag)
            //    U[BLeftKnots[0]] = U[BTopKnots[BTopKnots.Length - 2]];
            //ГУ Dong
            //if (iteration == iter - 1)
            //    DongBC_UE();
            //else
            //    DongBC_U();
            //ГУ справа - снос
            for (int i = 0; i < NRight; i++)
            {
                int knot = BRightKnots[i];
                //
                U[knot] = U[knot - NRight];
                V[knot] = V[knot - NRight];
                S[knot] = S[knot - NRight];
            }
            for (int i = 0; i < NTop; i++)
            {
                int knot = BTopKnots[i];
                S[knot] = S[knot - 1];
                knot = BBottomKnots[i];
                S[knot] = S[knot + 1];
            }
            //
            ////----------------
            //если задача со свободной поверхностью
            if (surf_flag)
            {
                for (int i = 0; i < NTop; i++)
                {
                    int knot = BTopKnots[i];
                    U[knot] = U[knot - 1];
                    V[knot] = 0;
                }
            }
            //
            return iteration;
        }
        //
        private int QHDKE(int iteration)
        {
            #region Расчет k и e во внутренних узлах без узлов WallKnots
            OrderablePartitioner<Tuple<int, int>> rangePartitioner3 = Partitioner.Create(0, CV2.Length);
            Parallel.ForEach(rangePartitioner3,
                    (range, loopState) =>
                    {
                        for (int i = range.Item1; i < range.Item2; i++)
                        //for (int i = 0; i < CV2.Length; i++)
                        {
                            double LsummK = 0;//потоки k 
                            double LsummE = 0;//потоки e 
                            double LLrightK = 0;//потоки k 
                            double LLrightE = 0;//потоки e 
                            //
                            double ldudx = 0, ldudy = 0, ldvdx = 0, ldvdy = 0;
                            //
                            int p0 = CV2[i][0];
                            // убираем из расчета узлы, в которых устанавливается WallFunc

                            int jj = CV2[i].Length - 1;//количество КО, связанных с данным узлом
                            for (int j = 0; j < jj; j++)
                            {
                                double _lx10 = Lx10[p0][j]; double _lx32 = Lx32[p0][j];
                                double _ly01 = Ly01[p0][j]; double _ly23 = Ly23[p0][j];
                                //площадь
                                double LS = SS[p0][j];
                                //сосоедние элементы
                                int Lv1 = CV2[i][(j + 1) % jj + 1];
                                int Lv2 = CV2[i][j + 1];
                                //вторая точка общей грани
                                int Lp1 = P1[p0][j];
                                //находим значения функций в центрах масс 1ого и 2ого треугольника как средние значения по элементу
                                int[] Knots1 = Mesh.AreaElems[Lv1];
                                int Lt1 = Knots1[0]; int Lt2 = Knots1[1]; int Lt3 = Knots1[2];
                                double LUc1 = (U[Lt1] + U[Lt2] + U[Lt3]) / 3.0;
                                double LVc1 = (V[Lt1] + V[Lt2] + V[Lt3]) / 3.0;
                                double LPc1 = (P[Lt1] + P[Lt2] + P[Lt3]) / 3.0;
                                double LKc1 = (K[Lt1] + K[Lt2] + K[Lt3]) / 3.0;
                                double LEc1 = (E[Lt1] + E[Lt2] + E[Lt3]) / 3.0;
                                int[] Knots2 = Mesh.AreaElems[Lv2];
                                int Lz1 = Knots2[0]; int Lz2 = Knots2[1]; int Lz3 = Knots2[2];
                                double LUc2 = (U[Lz1] + U[Lz2] + U[Lz3]) / 3.0;
                                double LVc2 = (V[Lz1] + V[Lz2] + V[Lz3]) / 3.0;
                                double LPc2 = (P[Lz1] + P[Lz2] + P[Lz3]) / 3.0;
                                double LKc2 = (K[Lz1] + K[Lz2] + K[Lz3]) / 3.0;
                                double LEc2 = (E[Lz1] + E[Lz2] + E[Lz3]) / 3.0;
                                //значения производных в точке пересечения граней
                                double Ls2 = 2 * LS;
                                double Ldudx = ((LUc1 - LUc2) * _ly01 + (U[Lp1] - U[p0]) * _ly23) / Ls2;
                                double Ldudy = ((LUc1 - LUc2) * _lx10 + (U[Lp1] - U[p0]) * _lx32) / Ls2;
                                double Ldvdx = ((LVc1 - LVc2) * _ly01 + (V[Lp1] - V[p0]) * _ly23) / Ls2;
                                double Ldvdy = ((LVc1 - LVc2) * _lx10 + (V[Lp1] - V[p0]) * _lx32) / Ls2;
                                double Ldpdx = ((LPc1 - LPc2) * _ly01 + (P[Lp1] - P[p0]) * _ly23) / Ls2;
                                double Ldpdy = ((LPc1 - LPc2) * _lx10 + (P[Lp1] - P[p0]) * _lx32) / Ls2;
                                //
                                double Ldkdx = ((LKc1 - LKc2) * _ly01 + (K[Lp1] - K[p0]) * _ly23) / Ls2;
                                double Ldkdy = ((LKc1 - LKc2) * _lx10 + (K[Lp1] - K[p0]) * _lx32) / Ls2;
                                double Ldedx = ((LEc1 - LEc2) * _ly01 + (E[Lp1] - E[p0]) * _ly23) / Ls2;
                                double Ldedy = ((LEc1 - LEc2) * _lx10 + (E[Lp1] - E[p0]) * _lx32) / Ls2;
                                //внешняя нормаль к грани КО (контуру КО)
                                double Lnx = Nx[p0][j]; double Lny = Ny[p0][j];
                                ////значение функций в точке пересечения грани КО и основной грани
                                double Lalpha = Alpha[p0][j];
                                double LUcr = Lalpha * U[p0] + (1 - Lalpha) * U[Lp1];
                                double LVcr = Lalpha * V[p0] + (1 - Lalpha) * V[Lp1];
                                double LKcr = Lalpha * K[p0] + (1 - Lalpha) * K[Lp1];
                                double LEcr = Lalpha * E[p0] + (1 - Lalpha) * E[Lp1];
                                double LNucrT = Lalpha * nuT[p0] + (1 - Lalpha) * nuT[Lp1];
                                //длина текущего фрагмента внешнего контура КО
                                double LLk = _Lk[p0][j];
                                //расчет потоков
                                double wx = tau * (LUcr * Ldudx + LVcr * Ldudy + 1.0 / rho_w * Ldpdx);
                                double wy = tau * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0 / rho_w * Ldpdy);
                                double wk = tau * (LUcr * Ldkdx + LVcr * Ldkdy - (LNucrT * (2 * Ldudx * Ldudx + (Ldvdx + Ldudy) * (Ldvdx + Ldudy) + 2 * Ldvdy * Ldvdy)) - LEcr);
                                double we = tau * (LUcr * Ldedx + LVcr * Ldedy - (LEcr / LKcr * (C_e1 * LNucrT * (2 * Ldudx * Ldudx + (Ldvdx + Ldudy) * (Ldvdx + Ldudy) + 2 * Ldvdy * Ldvdy)) - C_e2 * LEcr));
                                //
                                double LconvK = -LUcr * LKcr * Lnx - LVcr * LKcr * Lny;
                                double LdiffK = (LNucrT / sigma_k + nu_mol) * (Ldkdx * Lnx + Ldkdy * Lny);
                                double LregK = LKcr * wx * Lnx + LKcr * wy * Lny + LUcr * wk * Lnx + LVcr * wk * Lny;
                                //
                                LsummK += (LconvK + LdiffK + LregK) * LLk;
                                //                  
                                double LconvE = -LUcr * LEcr * Lnx - LVcr * LEcr * Lny;
                                double LdiffE = (LNucrT / sigma_e + nu_mol) * (Ldedx * Lnx + Ldedy * Lny);
                                double LregE = LEcr * wx * Lnx + LEcr * wy * Lny + LUcr * we * Lnx + LVcr * we * Lny;
                                // 
                                LsummE += (LconvE + LdiffE + LregE) * LLk;
                                //
                                // компоненты производных для Pk
                                ldudx += LUcr * Lnx * LLk;
                                ldudy += LUcr * Lny * LLk;
                                ldvdx += LVcr * Lnx * LLk;
                                ldvdy += LVcr * Lny * LLk;
                                //запись в массивы
                                ConvK[p0] += LconvK * LLk;
                                ConvE[p0] += LconvE * LLk;
                                DiffK[p0] += LdiffK * LLk;
                                DiffE[p0] += LdiffE * LLk;
                                RegK[p0] += (LUcr * wk * Lnx + LVcr * wk * Lny) * LLk;
                                RegE[p0] += (LUcr * we * Lnx + LVcr * we * Lny) * LLk;
                                //RegK[p0] += LregK * LLk;
                                //RegE[p0] += LregE * LLk;
                            }
                            //
                            ldudx /= S0[p0];
                            ldudy /= S0[p0];
                            ldvdx /= S0[p0];
                            ldvdy /= S0[p0];
                            //double tPk = 1.4142135623730950488016887242097 * nuT[p0] * (ldudx * ldudx + (ldvdx + ldudy) * (ldvdx + ldudy) + ldvdy * ldvdy); //- 2.0 / 3.0 * K[p0];
                            double tPk = nuT[p0] * (2 * ldudx * ldudx + (ldvdx + ldudy) * (ldvdx + ldudy) + 2 * ldvdy * ldvdy);
                            double Pk = tPk;//Math.Min(tPk, 10 * E[p0]);
                            LLrightK = (Pk - E[p0]);
                            LLrightE = E[p0] / K[p0] * (C_e1 * Pk - C_e2 * E[p0]);
                            //
                            K[p0] = K[p0] + dt / S0[p0] * LsummK + dt * LLrightK;
                            E[p0] = E[p0] + dt / S0[p0] * LsummE + dt * LLrightE;
                            //
                            ConvK[p0] /= S0[p0];
                            ConvE[p0] /= S0[p0];
                            DiffK[p0] /= S0[p0];
                            DiffE[p0] /= S0[p0];
                            RegK[p0] /= S0[p0];
                            RegE[p0] /= S0[p0];
                            //
                            rightK[p0] = LLrightK;
                            rightE[p0] = LLrightE;
                            ReT[p0] = K[p0] * K[p0] / E[p0] / nu_mol;
                            //
                            if (double.IsNaN(E[p0]))
                            {
                                err = " KE в бесконечность";
                                iteration = iter;
                                break;
                                //return iteration;
                            }
                            //}
                        }
                    });
            #endregion
            //
            #region Расчет k и e в узлах WallKnots
            rangePartitioner3 = Partitioner.Create(0, CV_WallKnots.Length);
            Parallel.ForEach(rangePartitioner3,
                    (range, loopState) =>
                    {
                        for (int i = range.Item1; i < range.Item2; i++)
                        //for (int i = 0; i < CV_WallKnots.Length; i++)
                        {
                            double LsummK = 0;//потоки k 
                            double LLrightK = 0;//потоки k  
                            //
                            int p0 = CV_WallKnots[i][0];
                            int jj = CV_WallKnots[i].Length - 1;//количество КО, связанных с данным узлом
                            //
                            
                            for (int j = 0; j < jj; j++)
                            {
                                double _lx10 = Lx10[p0][j]; double _lx32 = Lx32[p0][j];
                                double _ly01 = Ly01[p0][j]; double _ly23 = Ly23[p0][j];
                                //площадь
                                double LS = SS[p0][j];
                                //сосоедние элементы
                                int Lv1 = CV_WallKnots[i][(j + 1) % jj + 1];
                                int Lv2 = CV_WallKnots[i][j + 1];
                                //вторая точка общей грани
                                int Lp1 = P1[p0][j];
                                //находим значения функций в центрах масс 1ого и 2ого треугольника как средние значения по элементу
                                int[] Knots1 = Mesh.AreaElems[Lv1];
                                int Lt1 = Knots1[0]; int Lt2 = Knots1[1]; int Lt3 = Knots1[2];
                                double LUc1 = (U[Lt1] + U[Lt2] + U[Lt3]) / 3.0;
                                double LVc1 = (V[Lt1] + V[Lt2] + V[Lt3]) / 3.0;
                                double LPc1 = (P[Lt1] + P[Lt2] + P[Lt3]) / 3.0;
                                double LKc1 = (K[Lt1] + K[Lt2] + K[Lt3]) / 3.0;
                                double LEc1 = (E[Lt1] + E[Lt2] + E[Lt3]) / 3.0;
                                int[] Knots2 = Mesh.AreaElems[Lv2];
                                int Lz1 = Knots2[0]; int Lz2 = Knots2[1]; int Lz3 = Knots2[2];
                                double LUc2 = (U[Lz1] + U[Lz2] + U[Lz3]) / 3.0;
                                double LVc2 = (V[Lz1] + V[Lz2] + V[Lz3]) / 3.0;
                                double LPc2 = (P[Lz1] + P[Lz2] + P[Lz3]) / 3.0;
                                double LKc2 = (K[Lz1] + K[Lz2] + K[Lz3]) / 3.0;
                                double LEc2 = (E[Lz1] + E[Lz2] + E[Lz3]) / 3.0;
                                //значения производных в точке пересечения граней
                                double Ls2 = 2 * LS;
                                double Ldudx = ((LUc1 - LUc2) * _ly01 + (U[Lp1] - U[p0]) * _ly23) / Ls2;
                                double Ldudy = ((LUc1 - LUc2) * _lx10 + (U[Lp1] - U[p0]) * _lx32) / Ls2;
                                double Ldvdx = ((LVc1 - LVc2) * _ly01 + (V[Lp1] - V[p0]) * _ly23) / Ls2;
                                double Ldvdy = ((LVc1 - LVc2) * _lx10 + (V[Lp1] - V[p0]) * _lx32) / Ls2;
                                double Ldpdx = ((LPc1 - LPc2) * _ly01 + (P[Lp1] - P[p0]) * _ly23) / Ls2;
                                double Ldpdy = ((LPc1 - LPc2) * _lx10 + (P[Lp1] - P[p0]) * _lx32) / Ls2;
                                //
                                double Ldkdx = ((LKc1 - LKc2) * _ly01 + (K[Lp1] - K[p0]) * _ly23) / Ls2;
                                double Ldkdy = ((LKc1 - LKc2) * _lx10 + (K[Lp1] - K[p0]) * _lx32) / Ls2;
                                //внешняя нормаль к грани КО (контуру КО)
                                double Lnx = Nx[p0][j]; double Lny = Ny[p0][j];
                                ////значение функций в точке пересечения грани КО и основной грани
                                double Lalpha = Alpha[p0][j];
                                double LUcr = Lalpha * U[p0] + (1 - Lalpha) * U[Lp1];
                                double LVcr = Lalpha * V[p0] + (1 - Lalpha) * V[Lp1];
                                double LKcr = Lalpha * K[p0] + (1 - Lalpha) * K[Lp1];
                                double LEcr = Lalpha * E[p0] + (1 - Lalpha) * E[Lp1];
                                double LNucrT = Lalpha * nuT[p0] + (1 - Lalpha) * nuT[Lp1];
                                //длина текущего фрагмента внешнего контура КО
                                double LLk = _Lk[p0][j];
                                //расчет потоков
                                double wx = tau * (LUcr * Ldudx + LVcr * Ldudy + 1.0 / rho_w * Ldpdx);
                                double wy = tau * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0 / rho_w * Ldpdy);
                                double wk = tau * (LUcr * Ldkdx + LVcr * Ldkdy);
                                //
                                double LconvK = -LUcr * LKcr * Lnx - LVcr * LKcr * Lny;
                                double LdiffK = (LNucrT / sigma_k + nu_mol) * (Ldkdx * Lnx + Ldkdy * Lny);
                                double LregK = LKcr * wx * Lnx + LKcr * wy * Lny;
                                //
                                LsummK += (LconvK + LdiffK + LregK) * LLk;
                                //
                                //запись в массивы
                                ConvK[p0] += LconvK * LLk;
                                DiffK[p0] += LdiffK * LLk;
                                RegK[p0] += LregK * LLk;
                            }
                            //
                            double y_p_plus = cm14 * Math.Sqrt(K[p0]) * CV_WallKnotsDistance[i] / nu_mol;
                            double Pk = 0;
                            if (y_p_plus > y_p_0)
                            {
                                E[p0] = cm14 * cm14 * cm14 * Math.Pow(K[p0], 1.5) / kappa / CV_WallKnotsDistance[i];
                                Pk = E[p0];
                            }
                            else
                                E[p0] = 2.0 * K[p0] / CV_WallKnotsDistance[i] / CV_WallKnotsDistance[i] * nu_mol;
                            //
                            LLrightK = (Pk - E[p0]);
                            //
                            K[p0] = K[p0] + dt / S0[p0] * LsummK + dt * LLrightK;
                            //
                            ConvK[p0] /= S0[p0];
                            ConvE[p0] /= S0[p0];
                            DiffK[p0] /= S0[p0];
                            //
                            rightK[p0] = LLrightK;
                            ReT[p0] = K[p0] * K[p0] / E[p0] / nu_mol;
                            //
                            if (double.IsNaN(K[p0]))
                            {
                                err = " KE WallKnots в бесконечность";
                                iteration = iter;
                                break;
                                //return iteration;
                            }
                            //}

                        }

                    });
            #endregion

            //ГУ справа снос
            int Bknot=0;
            for (int i = 0; i < NRight; i++)
            {
                Bknot = BRightKnots[i];
                //
                K[Bknot] = K[Bknot - NRight];
                E[Bknot] = E[Bknot - NRight];
            }
            //
            if (surf_flag)
            {
                int knot;
                for (int i = 0; i < NTop; i++)
                {
                    knot = BTopKnots[i];
                    K[knot] = K[knot - 1];
                    E[knot] = E[knot - 1];
                }
            }
            // вычисление напряжения по пристеночной функции
            for (int i = 0; i < CV_WallKnots.Length; i++)
            {
                int knot = CV_WallKnots[i][0];
                CV_WallTau[i] = WallFuncSnegirev(knot, CV_WallKnotsDistance[i]);
            }
            // вычисление напряжения по пристеночной функции для отрисовки
            for (int i = 0; i < NBottom; i++)
            {
                int knot = BBottomKnots[i] + 1;
                //
                BTauC[i] = WallFuncSnegirev(knot, BWallDistance[i]);
            }
            for (int i = 0; i < NBottom - 1; i++)
            {
                BTau[i] = 2 * BTauC[i] * BTauC[i + 1] / (BTauC[i] + BTauC[i + 1]);
            }
            BTau[NBottom - 1] = BTau[NBottom - 2];
            //
            // поправка по пристеночной функции для верхней границы
            // ставить минус, так как обход области против часовой стрелки?
            if (!surf_flag)
            {
                for (int i = 0; i < NTop; i++)
                {
                    int knot = BTopKnots[i]-1;
                    //
                    TTauC[i] = WallFuncSnegirev(knot, TWallDistance[i]);
                }
                for (int i = 0; i < NTop - 1; i++)
                {
                    TTau[i] = 2 * TTauC[i] * TTauC[i + 1] / (TTauC[i] + TTauC[i + 1]);
                }
                TTau[NTop - 1] = TTau[NTop - 2];
            }
            //
            return iteration;
        }
        private double WallFuncSnegirev(int knot_p, double dy)
        {
            double y_p_plus = cm14 * Math.Sqrt(K[knot_p]) * dy / nu_mol;
            double u2_tau = 0;
            if (y_p_plus > y_p_0)
                u2_tau = cm14 * cm14 * K[knot_p];
            else
                u2_tau = nu_mol * U[knot_p] / dy;
            double tau_w = u2_tau * rho_w;
            return tau_w;
        }
        /// <summary>
        /// Функция стенки по Волкову упрощенная
        /// </summary>
        /// <param name="knot">узел на границе</param>
        /// <param name="knot_p">узел не на границе, но ближайший к ней</param>
        /// <returns></returns>
        private double WallFunc(int knot, int knot_p)
        {
            double kp = K[knot_p];
            double Dy = Math.Abs(Y[knot_p] - Y[knot]);
            double Du = Math.Abs(U[knot] - U[knot_p]);
            double Re = rho_w * cm14 * Math.Sqrt(kp) * Dy / mu;
            // tau
            double tauw = (rho_w * cm14 * Math.Sqrt(kp) * Du) / (1.0 / kappa * Math.Log(8.8 * Re));
            // квадрат u_tau
            double ut2 = tauw / rho_w;
            double k = ut2 / Math.Sqrt(C_m);
            K[knot_p] = k;
            double eps = ut2 * Math.Sqrt(ut2) / kappa / Dy;
            E[knot_p] = eps;
            nuT[knot_p] = C_m * k * k / eps + nu_mol;
            return tauw;
        }
        /// <summary>
        /// Функция стенки по Луцкому с буферным слоем
        /// </summary>
        /// <param name="knot">узел на границе</param>
        /// <param name="knot_p">узел не на границе, но ближайший к ней</param>
        /// <returns></returns>
        private double WallFuncPlus(int knot, int knot_p)
        {
            double y1 = Math.Abs(Y[knot_p] - Y[knot]);
            double F = U[knot_p] * y1 / nu_mol;
            double y_plus = 0;
            if (F <= 2) // ламинарный слой
                y_plus = Math.Sqrt(2 * F);
            else if (F >= 696.68) // логарифмический слой
            {
                double y_i = 60;
                double F_i = 0, u_i = 0, y_i1 = 0;
                for (int i = 0; i < 7; i++)
                {
                    F_i = 2.5 * y_i * (Math.Log(y_i / 0.13) - 1) - 73.50481;
                    u_i = 2.5 * Math.Log(y_i / 0.13);
                    y_i1 = y_i + (F - F_i) / u_i;
                    if (Math.Abs(y_i - y_i1) < 0.000001)
                    {
                        y_i = y_i1;
                        break;
                    }
                    y_i = y_i1;
                }
                y_plus = y_i1;
            }
            else // буферный слой
                y_plus = alglib.spline1dcalc(bufF, F);
            // tau
            double utau = y_plus / y1 * nu_mol;
            double k = utau * utau / Math.Sqrt(C_m);
            K[knot_p] = k;
            double eps = utau * utau * utau / kappa / y1;
            E[knot_p] = eps;
            nuT[knot_p] = C_m * k * k / eps + nu_mol;
            double tauw = utau * utau * rho_w;
            return tauw;
        }
        /// <summary>
        /// Функция стенки для шероховатой функции по алгоритму Луцкого без буферного слоя
        /// </summary>
        /// <param name="knot">узел на границе</param>
        /// <param name="knot_p">узел не на границе, но ближайший к ней</param>
        /// <returns></returns>
        private double WallFuncSharpPlus(int knot, int knot_p)
        {
            double y1 = Math.Abs(Y[knot_p] - Y[knot]);
            double F = U[knot_p] * y1 / nu_mol;
            double y_plus = 0;
            if (F <= 805.6098) // ламинарный слой
                y_plus = Math.Sqrt(2 * F);
            else  // логарифмический слой
            {
                double y_i = 40.14;
                double F_i = 0, u_i = 0, y_i1 = 0;
                for (int i = 0; i < 7; i++)
                {
                    F_i = 2.5 * y_i * (Math.Log(22.48 * y_i / (0.6 * d)) - 1) - 705.27603;
                    u_i = 2.5 * Math.Log(22.48 * y_i / (0.6 * d));
                    y_i1 = y_i + (F - F_i) / u_i;
                    if (Math.Abs(y_i - y_i1) < 0.000001)
                    {
                        y_i = y_i1;
                        break;
                    }
                    y_i = y_i1;
                }
                y_plus = y_i1;
            }
            // буферный слой отсутствует
            // tau
            double utau = y_plus / y1 * nu_mol;
            double k = utau * utau / Math.Sqrt(C_m);
            K[knot_p] = k;
            double eps = utau * utau * utau / kappa / y1;
            E[knot_p] = eps;
            nuT[knot_p] = C_m * k * k / eps + nu_mol;
            double tauw = utau * utau * rho_w;
            return tauw;
        }
        //
        public double[] CalcTauEverywhere()
        {
            double[] tau = new double[CountKnots];
            if (surf_flag)
            {  
                #region Расчет Tau во всех узлах по КО
                // По МКО находим касательное напряжение во внутренних узлах
                int knot = 0;
                OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, CV.Length);
                Parallel.ForEach(rangePartitioner,
                        (range, loopState) =>
                        {
                            for (int i = range.Item1; i < range.Item2; i++)
                            //for (int i = 0; i < CV.Length; i++)
                            {
                                double LsummTau = 0;//потоки касательного напряжения
                                //
                                int p0 = CV[i][0];
                                int jj = CV[i].Length - 1;//количество КО, связанных с данным узлом
                                for (int j = 0; j < jj; j++)
                                {
                                    //вторая точка общей грани
                                    int Lp1 = P1[p0][j];
                                    //внешняя нормаль к грани КО (контуру КО)
                                    double Lnx = Nx[p0][j]; double Lny = Ny[p0][j];
                                    ////значение функций в точке пересечения грани КО и основной грани
                                    double Lalpha = Alpha[p0][j];
                                    double LUcr = Lalpha * U[p0] + (1 - Lalpha) * U[Lp1];
                                    double LVcr = Lalpha * V[p0] + (1 - Lalpha) * V[Lp1];
                                    //длина текущего фрагмента внешнего контура КО
                                    double LLk = _Lk[p0][j];
                                    //расчет потоков
                                    double LTau = LUcr * Lny + LVcr * Lnx;
                                    //
                                    LsummTau += LTau * LLk;
                                }
                                //
                                tau[p0] =  nuT[p0] * rho_w / S0[p0] * LsummTau; // * 2
                                //
                                if (double.IsNaN(tau[p0]))
                                {
                                    err = " tau в бесконечность";
                                    //iteration = iter;
                                    break;
                                }
                                //}

                            }

                        });
                #endregion
                #region Нахождение tau на границах
                for (int i = 0; i < NBottom; i++)
                {
                    knot = BBottomKnots[i];
                    tau[knot] = BTauC[i];
                }
                int ch = 1; bool flag = true;
                while (flag)
                {
                    knot = BBottomKnots[0] + ch;
                    double y_p_plus = cm14 * Math.Sqrt(K[knot]) * Mesh.GetNormalDistanceBottom(knot) / nu_mol;
                    //if (y_p_plus > 140)//300
                    if (ch >= 3)
                    {
                        flag = false;
                        break;
                    }
                    for (int i = 0; i < NBottom; i++)
                    {
                        knot = BBottomKnots[i] + ch;
                        double dy = Mesh.GetNormalDistanceBottom(knot);
                        y_p_plus = cm14 * Math.Sqrt(K[knot]) * dy / nu_mol;
                        double u2_tau = cm14 * cm14 * K[knot];
                        tau[knot] = u2_tau * rho_w;
                    }
                    ch++;
                }
                // 
                for (int i = 0; i < NLeft; i++)
                {
                    knot = BLeftKnots[i];
                    tau[knot] = tau[knot + NLeft];
                }
                //
                for (int i = 0; i < NRight; i++)
                {
                    knot = BRightKnots[i];
                    tau[knot] = tau[knot - NLeft];
                }
                //
                for (int i = 0; i < NTop; i++)
                {
                    knot = BTopKnots[i];
                    tau[knot] = tau[knot - 1];
                }

            }
                #endregion
            //
            return tau;
        }
        //
        /// <summary>
        /// Расчет k-e вместе с пристеночной функцией по Жлуткову 2015 Пристеночные функции для высокорейнольдсовых расчетов в программном комплексеFlowVision
        /// Сначала ставится значение при стенке, потом идет расчет k-e равновесный (в прилегающей к границе ко не считает)
        /// очень осциллирует решение -- можно поправить по Снегиреву по технике установки ГУ
        /// </summary>
        /// <param name="iteration"></param>
        /// <returns></returns>
        private int QHDKE2(int iteration)
        {
            //
            for (int i = 0; i < NBottom; i++)
            {
                int knot = BBottomKnots[i] + 1;
                double y = Y[knot] - Y[knot - 1];
                double dpdx = 0;
                if (i != NBottom - 1)
                    dpdx = (P[knot + _Ny] - P[knot]) / (X[_Ny] - X[0]);
                else
                    dpdx = (P[knot] - P[knot - _Ny]) / (X[_Ny] - X[0]);
                if (dudy[i] == 0)
                    dudy[i] = (U[knot] - U[knot - 1]) / (Y[knot] - Y[knot - 1]);
                double tauw = (nu_mol + nuT[knot]) * dudy[i];
                //
                double utau = (tauw / rho_w);
                double y1_plus = rho_w * utau * y / mu;
                double l1 = 0.41 * y * (1 - Math.Exp(-y1_plus / 25.0));
                //
                double up = Math.Pow(mu / rho_w / rho_w * Math.Abs(dpdx), 1.0 / 3.0);
                double y2_plus = rho_w * up * y / mu;
                double l2 = 0.2 * y * Math.Sqrt(y2_plus) * (1 - Math.Exp(-y2_plus / 13.6));
                double ll2 = Math.Max(Math.Sign(tauw) * l1 * l1 + Math.Sign(dpdx) * l2 * l2, 0);
                //
                double mut = 1.0 / 2.0 * (-mu + mu * (Math.Sqrt(1 + 4 * rho_w * ll2 / mu / mu * (tauw + dpdx * y))));
                dudy[i] = mut / rho_w / ll2 / 2.0;

                //
                double a = 0, b = y;
                double ab = (a + b) / 2.0;
                double l1_plusa = kappa * a * (1 - Math.Exp(-a / 25.0));
                double l1_plusb = kappa * b * (1 - Math.Exp(-b / 25.0));
                double l1_plusab = kappa * ab * (1 - Math.Exp(-ab / 25.0));
                //
                double l2_plusa = kappa * a * Math.Sqrt(a) * (1 - Math.Exp(-a / 13.6));
                double l2_plusb = kappa * b * Math.Sqrt(b) * (1 - Math.Exp(-b / 13.6));
                double l2_plusab = kappa * ab * Math.Sqrt(ab) * (1 - Math.Exp(-ab / 13.6));
                //
                double ua = (-1 + Math.Sqrt(1 + 4 * l1_plusa * l1_plusa)) / 2.0 / (l1_plusa * l1_plusa + 0.000000001);
                double ub = (-1 + Math.Sqrt(1 + 4 * l1_plusb * l1_plusb)) / 2.0 / l1_plusb / l1_plusb;
                double uab = (-1 + Math.Sqrt(1 + 4 * l1_plusab * l1_plusab)) / 2.0 / l1_plusab / l1_plusab;
                double u1_plus = (b - a) / 6.0 * (ua + 4 * uab + ub);
                //
                ua = (-1 + Math.Sqrt(1 + 4 * l2_plusa * l2_plusa * a)) / 2.0 / (l2_plusa * l2_plusa + 0.000000001);
                ub = (-1 + Math.Sqrt(1 + 4 * l2_plusb * l2_plusb * b)) / 2.0 / l2_plusb / l2_plusb;
                uab = (-1 + Math.Sqrt(1 + 4 * l2_plusab * l2_plusab * ab)) / 2.0 / l2_plusab / l2_plusab;
                double u2_plus = (b - a) / 6.0 * (ua + 4 * uab + ub);
                //
                double u_plus = Math.Sign(tauw) * u1_plus + Math.Sign(dpdx) * u2_plus;
                double ux = 0;
                if (U[knot]>= 0)
                    ux = u_plus * utau;
                else
                    ux = u_plus * up;
                //
                double utaup = Math.Sqrt(Math.Max(Math.Sign(tauw) * utau * utau + Math.Sign(dpdx) * up * up * up / nu_mol * y, 0));
                double ytaup_plus = rho_w * utaup * y / mu;
                double kc = utaup * utaup / (0.3 + 1.0 / (0.003 * Math.Pow(ytaup_plus, 3.5)));
                double kc2 = utau * utau / 0.3;
                //
                double uk = cm14 * Math.Sqrt(kc);
                double yk = rho_w * uk * y / mu;
                double le = 0.41 * y * (1 - Math.Exp(-yk / 15.0));
                double ec = uk * uk * uk / le;
                //
                nuT[knot] = mut / rho_w;
                //U[knot] = ux;
                K[knot] = kc;
                E[knot] = ec;
                BTau[i] = tauw;
            }
            if (!surf_flag)
            {
                for (int i = 0; i < NTop; i++)
                {
                    int knot = BTopKnots[i] - 1;
                    double y = Y[knot+1] - Y[knot];
                    double dpdx = 0;
                    if (i != NBottom - 1)
                        dpdx = (P[knot + _Ny] - P[knot]) / (X[_Ny] - X[0]);
                    else
                        dpdx = (P[knot] - P[knot - _Ny]) / (X[_Ny] - X[0]);
                    if (dudy[i] == 0)
                        dudy[i] = (U[knot+1] - U[knot]) / (Y[knot+1] - Y[knot]);
                    double tauw = (nu_mol + nuT[knot]) * dudy[i];
                    //
                    double utau = (tauw / rho_w);
                    double y1_plus = rho_w * utau * y / mu;
                    double l1 = 0.41 * y * (1 - Math.Exp(-y1_plus / 25.0));
                    //
                    double up = Math.Pow(mu / rho_w / rho_w * Math.Abs(dpdx), 1.0 / 3.0);
                    double y2_plus = rho_w * up * y / mu;
                    double l2 = 0.2 * y * Math.Sqrt(y2_plus) * (1 - Math.Exp(-y2_plus / 13.6));
                    double ll2 = Math.Max(Math.Sign(tauw) * l1 * l1 + Math.Sign(dpdx) * l2 * l2, 0);
                    //
                    double mut = 1.0 / 2.0 * (-mu + mu * (Math.Sqrt(1 + 4 * rho_w * ll2 / mu / mu * (tauw + dpdx * y))));
                    dudy[i] = mut / rho_w / ll2 / 2.0;

                    //
                    double a = 0, b = y;
                    double ab = (a + b) / 2.0;
                    double l1_plusa = kappa * a * (1 - Math.Exp(-a / 25.0));
                    double l1_plusb = kappa * b * (1 - Math.Exp(-b / 25.0));
                    double l1_plusab = kappa * ab * (1 - Math.Exp(-ab / 25.0));
                    //
                    double l2_plusa = kappa * a * Math.Sqrt(a) * (1 - Math.Exp(-a / 13.6));
                    double l2_plusb = kappa * b * Math.Sqrt(b) * (1 - Math.Exp(-b / 13.6));
                    double l2_plusab = kappa * ab * Math.Sqrt(ab) * (1 - Math.Exp(-ab / 13.6));
                    //
                    double ua = (-1 + Math.Sqrt(1 + 4 * l1_plusa * l1_plusa)) / 2.0 / (l1_plusa * l1_plusa + 0.000000001);
                    double ub = (-1 + Math.Sqrt(1 + 4 * l1_plusb * l1_plusb)) / 2.0 / l1_plusb / l1_plusb;
                    double uab = (-1 + Math.Sqrt(1 + 4 * l1_plusab * l1_plusab)) / 2.0 / l1_plusab / l1_plusab;
                    double u1_plus = (b - a) / 6.0 * (ua + 4 * uab + ub);
                    //
                    ua = (-1 + Math.Sqrt(1 + 4 * l2_plusa * l2_plusa * a)) / 2.0 / (l2_plusa * l2_plusa + 0.000000001);
                    ub = (-1 + Math.Sqrt(1 + 4 * l2_plusb * l2_plusb * b)) / 2.0 / l2_plusb / l2_plusb;
                    uab = (-1 + Math.Sqrt(1 + 4 * l2_plusab * l2_plusab * ab)) / 2.0 / l2_plusab / l2_plusab;
                    double u2_plus = (b - a) / 6.0 * (ua + 4 * uab + ub);
                    //
                    double u_plus = Math.Sign(tauw) * u1_plus + Math.Sign(dpdx) * u2_plus;
                    double ux = 0;
                    if (U[knot] >= 0)
                        ux = u_plus * utau;
                    else
                        ux = u_plus * up;
                    //
                    double utaup = Math.Sqrt(Math.Max(Math.Sign(tauw) * utau * utau + Math.Sign(dpdx) * up * up * up / nu_mol * y, 0));
                    double ytaup_plus = rho_w * utaup * y / mu;
                    double kc = utaup * utaup / (0.3 + 1.0 / (0.003 * Math.Pow(ytaup_plus, 3.5)));
                    double kc2 = utau * utau / 0.3;
                    //
                    double uk = cm14 * Math.Sqrt(kc);
                    double yk = rho_w * uk * y / mu;
                    double le = 0.41 * y * (1 - Math.Exp(-yk / 15.0));
                    double ec = uk * uk * uk / le;
                    //
                    nuT[knot] = mut / rho_w;
                    //U[knot] = ux;
                    K[knot] = kc;
                    E[knot] = ec;
                    BTau[i] = tauw;
                }
            }
            //
            for (int i = 0; i < NBottom - 1; i++)
            {
                BTau[i] = 2 * BTauC[i] * BTauC[i + 1] / (BTauC[i] + BTauC[i + 1]);
            }
            BTau[NBottom - 1] = BTau[NBottom - 2];
            //
            OrderablePartitioner<Tuple<int, int>> rangePartitioner3 = Partitioner.Create(0, CV2.Length);
            Parallel.ForEach(rangePartitioner3,
                    (range, loopState) =>
                    {
                        for (int i = range.Item1; i < range.Item2; i++)
                        //for (int i = 0; i < CV.Length; i++)
                        {
                            double LsummK = 0;//потоки k 
                            double LsummE = 0;//потоки e 
                            double LLrightK = 0;//потоки k 
                            double LLrightE = 0;//потоки e 
                            //
                            int p0 = CV2[i][0];
                            // убираем из расчета узлы, в которых устанавливается WallFunc

                            int jj = CV2[i].Length - 1;//количество КО, связанных с данным узлом
                            for (int j = 0; j < jj; j++)
                            {
                                double _lx10 = Lx10[i][j]; double _lx32 = Lx32[i][j];
                                double _ly01 = Ly01[i][j]; double _ly23 = Ly23[i][j];
                                //площадь
                                double LS = SS[i][j];
                                //сосоедние элементы
                                int Lv1 = CV2[i][(j + 1) % jj + 1];
                                int Lv2 = CV2[i][j + 1];
                                //вторая точка общей грани
                                int Lp1 = P1[i][j];
                                //находим значения функций в центрах масс 1ого и 2ого треугольника как средние значения по элементу
                                int[] Knots1 = Mesh.AreaElems[Lv1];
                                int Lt1 = Knots1[0]; int Lt2 = Knots1[1]; int Lt3 = Knots1[2];
                                double LUc1 = (U[Lt1] + U[Lt2] + U[Lt3]) / 3.0;
                                double LVc1 = (V[Lt1] + V[Lt2] + V[Lt3]) / 3.0;
                                double LPc1 = (P[Lt1] + P[Lt2] + P[Lt3]) / 3.0;
                                double LKc1 = (K[Lt1] + K[Lt2] + K[Lt3]) / 3.0;
                                double LEc1 = (E[Lt1] + E[Lt2] + E[Lt3]) / 3.0;
                                int[] Knots2 = Mesh.AreaElems[Lv2];
                                int Lz1 = Knots2[0]; int Lz2 = Knots2[1]; int Lz3 = Knots2[2];
                                double LUc2 = (U[Lz1] + U[Lz2] + U[Lz3]) / 3.0;
                                double LVc2 = (V[Lz1] + V[Lz2] + V[Lz3]) / 3.0;
                                double LPc2 = (P[Lz1] + P[Lz2] + P[Lz3]) / 3.0;
                                double LKc2 = (K[Lz1] + K[Lz2] + K[Lz3]) / 3.0;
                                double LEc2 = (E[Lz1] + E[Lz2] + E[Lz3]) / 3.0;
                                //значения производных в точке пересечения граней
                                double Ls2 = 2 * LS;
                                double Ldudx = ((LUc1 - LUc2) * _ly01 + (U[Lp1] - U[p0]) * _ly23) / Ls2;
                                double Ldudy = ((LUc1 - LUc2) * _lx10 + (U[Lp1] - U[p0]) * _lx32) / Ls2;
                                double Ldvdx = ((LVc1 - LVc2) * _ly01 + (V[Lp1] - V[p0]) * _ly23) / Ls2;
                                double Ldvdy = ((LVc1 - LVc2) * _lx10 + (V[Lp1] - V[p0]) * _lx32) / Ls2;
                                double Ldpdx = ((LPc1 - LPc2) * _ly01 + (P[Lp1] - P[p0]) * _ly23) / Ls2;
                                double Ldpdy = ((LPc1 - LPc2) * _lx10 + (P[Lp1] - P[p0]) * _lx32) / Ls2;
                                //
                                double Ldkdx = ((LKc1 - LKc2) * _ly01 + (K[Lp1] - K[p0]) * _ly23) / Ls2;
                                double Ldkdy = ((LKc1 - LKc2) * _lx10 + (K[Lp1] - K[p0]) * _lx32) / Ls2;
                                double Ldedx = ((LEc1 - LEc2) * _ly01 + (E[Lp1] - E[p0]) * _ly23) / Ls2;
                                double Ldedy = ((LEc1 - LEc2) * _lx10 + (E[Lp1] - E[p0]) * _lx32) / Ls2;
                                //внешняя нормаль к грани КО (контуру КО)
                                double Lnx = Nx[i][j]; double Lny = Ny[i][j];
                                ////значение функций в точке пересечения грани КО и основной грани
                                double Lalpha = Alpha[i][j];
                                double LUcr = Lalpha * U[p0] + (1 - Lalpha) * U[Lp1];
                                double LVcr = Lalpha * V[p0] + (1 - Lalpha) * V[Lp1];
                                double LKcr = Lalpha * K[p0] + (1 - Lalpha) * K[Lp1];
                                double LEcr = Lalpha * E[p0] + (1 - Lalpha) * E[Lp1];
                                double LNucrT = Lalpha * nuT[p0] + (1 - Lalpha) * nuT[Lp1];
                                //длина текущего фрагмента внешнего контура КО
                                double LLk = _Lk[i][j];
                                //расчет потоков
                                double wx = tau * (LUcr * Ldudx + LVcr * Ldudy + 1.0 / rho_w * Ldpdx);
                                double wy = tau * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0 / rho_w * Ldpdy);
                                //double tPk = 1.4142135623730950488016887242097 * nuT[p0] * (Ldudx * Ldudx + (Ldvdx + Ldudy) * (Ldvdx + Ldudy) + Ldvdy * Ldvdy); //- 2.0 / 3.0 * LKcr;
                                double Pk = nuT[p0] * (2 * (Ldudx * Ldudx + (Ldvdx + Ldudy) * (Ldvdx + Ldudy) + Ldvdy * Ldvdy) - 2.0 / 3.0 * (Ldudx + Ldvdy) * (Ldudx + Ldvdy));
                                //double Pk = Math.Min(tPk, 10 * LEcr);
                                //
                                double LconvK = -LUcr * LKcr * Lnx - LVcr * LKcr * Lny;
                                double LdiffK = (LNucrT / sigma_k + nu_mol) * (Ldkdx * Lnx + Ldkdy * Lny);
                                double LregK = LKcr * wx * Lnx + LKcr * wy * Lny;
                                double LrightK = Pk - LEcr;
                                //
                                LsummK += (LconvK + LdiffK + LregK + LrightK) * LLk;
                                LLrightK += LrightK * LLk;
                                //                  
                                double LconvE = -LUcr * LEcr * Lnx - LVcr * LEcr * Lny;
                                double LdiffE = (LNucrT / sigma_e + nu_mol) * (Ldedx * Lnx + Ldedy * Lny);
                                double LregE = LEcr * wx * Lnx + LEcr * wy * Lny;
                                double LrightE = LEcr / (LKcr) * (C_e1 * Pk - C_e2 * LEcr);
                                LsummE += (LconvE + LdiffE + LregE + LrightE) * LLk;
                                LLrightE += LrightE * LLk;
                                //запись в массивы
                                ConvK[p0] += LconvK * LLk;
                                ConvE[p0] += LconvE * LLk;
                                DiffK[p0] += LdiffK * LLk;
                                DiffE[p0] += LdiffE * LLk;
                                RegK[p0] += LregK * LLk;
                                RegE[p0] += LregE * LLk;
                            }


                            K[p0] = K[p0] + dt / S0[i] * LsummK;
                            E[p0] = E[p0] + dt / S0[i] * LsummE;
                            rightK[p0] = LLrightK / S0[i];
                            rightE[p0] = LLrightE / S0[i];
                            ReT[p0] = K[p0] * K[p0] / E[p0] / nu_mol;
                            //
                            ConvK[p0] /= S0[i];
                            ConvE[p0] /= S0[i];
                            DiffK[p0] /= S0[i];
                            DiffE[p0] /= S0[i];
                            RegK[p0] /= S0[i];
                            RegE[p0] /= S0[i];
                            //
                            if (double.IsNaN(E[p0]))
                            {
                                err = " KE в бесконечность";
                                iteration = iter;
                                break;
                                //return iteration;
                            }
                            //}

                        }

                    });


            //ГУ справа снос
            int Bknot = 0;
            for (int i = 0; i < NRight; i++)
            {
                Bknot = BRightKnots[i];
                //
                K[Bknot] = K[Bknot - NRight];
                E[Bknot] = E[Bknot - NRight];
            }
            //
            if (surf_flag)
            {
                int knot;
                for (int i = 0; i < NTop; i++)
                {
                    knot = BTopKnots[i];
                    K[knot] = K[knot - 1];
                    E[knot] = E[knot - 1];
                }
            }
           
            //
            return iteration;
        }
        double[] dudy;

        //----Тест        ///
        public double[] p_conv, p_kinet;
        public double[] u_press, u_kinet, u_cont;
        private void DongBC_UE(double delta = 0.05)
        {
            u_cont = new double[NRight];
            u_kinet = new double[NRight];
            u_press = new double[NRight];
            //
            int knot = BRightKnots[0];
            double du = 0, dv = 0;
            double dx = (X[knot] - X[knot - NRight]);
            double dy = (Y[knot + 2] - Y[knot + 1]);
            for (int i = 1; i < NRight - 1; i++)
            {
                knot = BRightKnots[i];
                du = (U[knot] - U[knot - NRight]) / dx;
                if (V[knot] < 0)
                    dv = (V[knot] - V[knot - 1]) / dy;
                else
                    dv = (V[knot + 1] - V[knot]) / dy;
                u_press[i] = 1.0 / mu * P[knot];
                u_kinet[i] = rho_w / 4.0 / mu * (U[knot] * U[knot] + V[knot] * V[knot]) * (1 - Math.Tanh(+U[knot] / Ucp / delta));
                u_cont[i] = du + dv;
                U[knot] = U[knot - NRight] + dx * (u_press[i] + u_kinet[i] - u_cont[i]);
                V[knot] = V[knot - NRight];
            }
        }

        private void DongBC_PE(double delta = 0.05)
        {
            p_conv = new double[NRight];
            p_kinet = new double[NRight];
            //
            int knot = 0;
            for (int i = 0; i < NRight; i++)
            {
                RBC[i] = 0;
                knot = BRightKnots[i];
                p_kinet[i] = 0.25 * rho_w * (U[knot] * U[knot] + V[knot] * V[knot]) * (1 - Math.Tanh(U[knot] / Ucp / delta));
                p_conv[i] = mu * (U[knot] - U[knot - NRight]) / (X[knot] - X[knot - NRight]);
                //
                RBC[i] = p_conv[i] - p_kinet[i];
            }
            RBC[0] = RBC[1];
            RBC[NRight - 1] = RBC[NRight - 2];
            //
            p_kinet[0] = p_kinet[1];
            p_conv[0] = p_conv[1];
            p_kinet[NRight - 1] = p_kinet[NRight - 2];
            p_conv[NRight - 1] = p_conv[NRight - 2];
        }
        //
        //----  ///
        private void DongBC_U(double delta = 0.05)
        {
            int knot = BRightKnots[0];
            double du = 0, dv = 0;
            double dx = (X[knot] - X[knot - NRight]);
            double dy = (Y[knot + 2] - Y[knot + 1]);
            for (int i = 1; i < NRight - 1; i++)
            {
                knot = BRightKnots[i];
                du = (U[knot] - U[knot - NRight]) / dx;
                if (V[knot] < 0)
                    dv = (V[knot] - V[knot - 1]) / dy;
                else
                    dv = (V[knot + 1] - V[knot]) / dy;
                U[knot] = U[knot - NRight] + dx / mu * (P[knot] + rho_w / 4.0 * (U[knot] * U[knot] + V[knot] * V[knot]) * (1 - Math.Tanh(+U[knot] / Ucp / delta))) - dx * (du + dv);
                V[knot] = V[knot - NRight];
            }
        }

        private void DongBC_P(double delta = 0.05)
        {
            int knot = 0;
            for (int i = 0; i < NRight; i++)
            {
                RBC[i] = 0;
                knot = BRightKnots[i];
                RBC[i] = mu * (U[knot] - U[knot - NRight]) / (X[knot] - X[knot - NRight]) - 0.25 * rho_w * (U[knot] * U[knot] + V[knot] * V[knot]) * (1 - Math.Tanh(U[knot] / Ucp / delta));
            }
            RBC[0] = RBC[1];
            RBC[NRight - 1] = RBC[NRight - 2];
        }
        //
        //
        /// <summary>
        /// нахождение размерного касательного напряжения на дне
        /// </summary>
        void ShearStresses()
        {
            System.Object lockThis = new System.Object();
            //
            int IndexMethod = 0;// через ленту tau_l
            IndexMethod = 2;// через ленту тензор TT
            //IndexMethod = 1;// через конечные разности -  для сильновырожденной области не годится
            try
            {
                if (IndexMethod == 2)
                {
                    //компоненты тензора напряжений
                    double[] Tx1 = new double[BTriangles.Length];
                    double[] Tx2 = new double[BTriangles.Length];
                    double[] Ty1 = new double[BTriangles.Length];
                    double[] Ty2 = new double[BTriangles.Length];
                    //
                    double[] tau_mid = new double[BTriangles.Length];
                    //double e1x = 1, e1y = 0, e2x = 0, e2y = 1;//проекции
                    //
                    OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, BTriangles.Length);
                    Parallel.ForEach(rangePartitioner,
                           (range, loopState) =>
                           {
                               for (int i = range.Item1; i < range.Item2; i++)
                               //for (int i = 0; i < BTriangles.Length; i++)
                               {

                                   double[] xL = new double[3];
                                   double[] yL = new double[3];
                                   //
                                   int LcurV = BTriangles[i];
                                   int[] Knots = Mesh.AreaElems[LcurV];
                                   //
                                   int Lnum1 = Knots[0];
                                   int Lnum2 = Knots[1];
                                   int Lnum3 = Knots[2];
                                   // получаем координаты узлов элемента
                                   xL[0] = X[Lnum1]; xL[1] = X[Lnum2]; xL[2] = X[Lnum3];
                                   yL[0] = Y[Lnum1]; yL[1] = Y[Lnum2]; yL[2] = Y[Lnum3];
                                   // нахождение площади треугольника
                                   double LS = Sk[LcurV];
                                   // скорости в вершинах треугольника
                                   double LU1 = U[Lnum1];
                                   double LU2 = U[Lnum2];
                                   double LU3 = U[Lnum3];
                                   //
                                   double LV1 = V[Lnum1];
                                   double LV2 = V[Lnum2];
                                   double LV3 = V[Lnum3];
                                   // производные в центре треугольника
                                   double Ldu_dx = 1.0f / 2.0f / LS * (LU1 * (yL[1] - yL[2]) + LU2 * (yL[2] - yL[0]) + LU3 * (yL[0] - yL[1]));
                                   double Ldu_dy = 1.0f / 2.0f / LS * (LU1 * (xL[2] - xL[1]) + LU2 * (xL[0] - xL[2]) + LU3 * (xL[1] - xL[0]));
                                   double Ldv_dx = 1.0f / 2.0f / LS * (LV1 * (yL[1] - yL[2]) + LV2 * (yL[2] - yL[0]) + LV3 * (yL[0] - yL[1]));
                                   double Ldv_dy = 1.0f / 2.0f / LS * (LV1 * (xL[2] - xL[1]) + LV2 * (xL[0] - xL[2]) + LV3 * (xL[1] - xL[0]));
                                   // давление в центре треугольника
                                   double LP_mid = (P[Lnum1] + P[Lnum2] + P[Lnum3]) / 3.0f;
                                   double Mu_mid = (nuT[Lnum1] + nuT[Lnum2] + nuT[Lnum3]) / 3.0f * rho_w;
                                   // составляющие тензора напряжений
                                   Tx1[i] = -LP_mid + 2.0f * Mu_mid * Ldu_dx;
                                   Tx2[i] = Mu_mid * (Ldu_dy + Ldv_dx);
                                   Ty1[i] = Mu_mid * (Ldu_dy + Ldv_dx);
                                   Ty2[i] = -LP_mid + 2.0f * Mu_mid * Ldv_dy;
                               }
                           });
                    // Вычисление tau в узлах сетки по сглаженной методике вычисления 
                    //double[] Tau_all = Aproximate(tau_mid, CBottom, BTriangles);

                    //вычисление тензора напряжений по сглаженной методике
                    double[] Tx1_all = Aproximate(Tx1, CBottom, BTriangles);
                    double[] Tx2_all = Aproximate(Tx2, CBottom, BTriangles);
                    double[] Ty1_all = Aproximate(Ty1, CBottom, BTriangles);
                    double[] Ty2_all = Aproximate(Ty2, CBottom, BTriangles);
                    //подготовка приграничных значений tau между граничными точками и координат для сплайна
                    int count = BBottomKnots.Length;
                    BTau = new double[count];
                    BTauC = new double[count];
                    arg = new double[count - 1];
                    int cKnot = BBottomKnots[0];
                    double prevTx1 = 0, prevTx2 = 0, prevTy1 = 0, prevTy2 = 0;
                    //
                    for (int i = 0; i < BBottomKnots.Length; i++)
                    {
                        cKnot = BBottomKnots[i];
                        for (int j = 0; j < CBottom.Length; j++)
                        {
                            if (cKnot == CBottom[j])
                            {
                                if (i != 0)
                                {
                                    int prevKnot = BBottomKnots[i - 1];
                                    double delx = (X[cKnot] - X[prevKnot]);
                                    double dely = (Y[cKnot] - Y[prevKnot]);
                                    double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
                                    // компоненты касательной между граничными точками
                                    double lx = 1 / ss * delx;
                                    double ly = 1 / ss * dely;
                                    double nx = -ly;
                                    double ny = lx;
                                    //
                                    double LsigX = (prevTx1 + Tx1_all[j]) / 2.0f * nx + (prevTx2 + Tx2_all[j]) / 2.0f * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
                                    double LsigY = (prevTy1 + Ty1_all[j]) / 2.0f * nx + (prevTy2 + Ty2_all[j]) / 2.0f * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
                                    //double LsigX = 2 * prevTx1 * Tx1_all[j] / (prevTx1 + Tx1_all[j]) * nx + 2 * prevTx2 * Tx2_all[j] / (prevTx2 + Tx2_all[j]) * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
                                    //double LsigY = 2 * prevTy1 * Ty1_all[j] / (prevTy1 + Ty1_all[j]) * nx + 2 * prevTy2 * Ty2_all[j] / (prevTy2 + Ty2_all[j]) * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
                                    //в полуцелых узлах
                                    BTau[i - 1] = (LsigX * lx + LsigY * ly);
                                    arg[i - 1] = X[prevKnot] + delx / 2.0f;
                                    //
                                    LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
                                    LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
                                    BTauC[i] = (LsigX * lx + LsigY * ly);

                                }
                                else
                                {
                                    int nextKnot = BBottomKnots[i + 1];
                                    double delx = (X[nextKnot] - X[cKnot]);
                                    double dely = (Y[nextKnot] - Y[cKnot]);
                                    double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
                                    // компоненты касательной между граничными точками
                                    double lx = 1 / ss * delx;
                                    double ly = 1 / ss * dely;
                                    double nx = -ly;
                                    double ny = lx;
                                    //
                                    double LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
                                    double LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
                                    BTauC[i] = (LsigX * lx + LsigY * ly);
                                }
                                //
                                prevTx1 = Tx1_all[j];
                                prevTx2 = Tx2_all[j];
                                prevTy1 = Ty1_all[j];
                                prevTy2 = Ty2_all[j];
                                break;
                            }
                        }
                    }
                    BTau[count - 1] = BTau[count - 2];
                    /////
                    Tx1 = new double[TTriangles.Length];
                    Tx2 = new double[TTriangles.Length];
                    Ty1 = new double[TTriangles.Length];
                    Ty2 = new double[TTriangles.Length];
                    //
                    tau_mid = new double[TTriangles.Length];
                    //double e1x = 1, e1y = 0, e2x = 0, e2y = 1;//проекции
                    //
                    rangePartitioner = Partitioner.Create(0, TTriangles.Length);
                    Parallel.ForEach(rangePartitioner,
                           (range, loopState) =>
                           {
                               for (int i = range.Item1; i < range.Item2; i++)
                               //for (int i = 0; i < BTriangles.Length; i++)
                               {

                                   double[] xL = new double[3];
                                   double[] yL = new double[3];
                                   //
                                   int LcurV = TTriangles[i];
                                   int[] Knots = Mesh.AreaElems[LcurV];
                                   //
                                   int Lnum1 = Knots[0];
                                   int Lnum2 = Knots[1];
                                   int Lnum3 = Knots[2];
                                   // получаем координаты узлов элемента
                                   xL[0] = X[Lnum1]; xL[1] = X[Lnum2]; xL[2] = X[Lnum3];
                                   yL[0] = Y[Lnum1]; yL[1] = Y[Lnum2]; yL[2] = Y[Lnum3];
                                   // нахождение площади треугольника
                                   double LS = Sk[LcurV];
                                   // скорости в вершинах треугольника
                                   double LU1 = U[Lnum1];
                                   double LU2 = U[Lnum2];
                                   double LU3 = U[Lnum3];
                                   //
                                   double LV1 = V[Lnum1];
                                   double LV2 = V[Lnum2];
                                   double LV3 = V[Lnum3];
                                   // производные в центре треугольника
                                   double Ldu_dx = 1.0f / 2.0f / LS * (LU1 * (yL[1] - yL[2]) + LU2 * (yL[2] - yL[0]) + LU3 * (yL[0] - yL[1]));
                                   double Ldu_dy = 1.0f / 2.0f / LS * (LU1 * (xL[2] - xL[1]) + LU2 * (xL[0] - xL[2]) + LU3 * (xL[1] - xL[0]));
                                   double Ldv_dx = 1.0f / 2.0f / LS * (LV1 * (yL[1] - yL[2]) + LV2 * (yL[2] - yL[0]) + LV3 * (yL[0] - yL[1]));
                                   double Ldv_dy = 1.0f / 2.0f / LS * (LV1 * (xL[2] - xL[1]) + LV2 * (xL[0] - xL[2]) + LV3 * (xL[1] - xL[0]));
                                   // давление в центре треугольника
                                   double LP_mid = (P[Lnum1] + P[Lnum2] + P[Lnum3]) / 3.0f;
                                   double Mu_mid = (nuT[Lnum1] + nuT[Lnum2] + nuT[Lnum3]) / 3.0f * rho_w;
                                   // составляющие тензора напряжений
                                   Tx1[i] = -LP_mid + 2.0f * Mu_mid * Ldu_dx;
                                   Tx2[i] = Mu_mid * (Ldu_dy + Ldv_dx);
                                   Ty1[i] = Mu_mid * (Ldu_dy + Ldv_dx);
                                   Ty2[i] = -LP_mid + 2.0f * Mu_mid * Ldv_dy;
                               }
                           });
                    // Вычисление tau в узлах сетки по сглаженной методике вычисления 
                    //double[] Tau_all = Aproximate(tau_mid, CBottom, BTriangles);

                    //вычисление тензора напряжений по сглаженной методике
                    Tx1_all = Aproximate(Tx1, CTop, TTriangles);
                    Tx2_all = Aproximate(Tx2, CTop, TTriangles);
                    Ty1_all = Aproximate(Ty1, CTop, TTriangles);
                    Ty2_all = Aproximate(Ty2, CTop, TTriangles);
                    //подготовка приграничных значений tau между граничными точками и координат для сплайна
                    count = BTopKnots.Length;
                    TTau = new double[count];
                    TTauC = new double[count];
                    argT = new double[count - 1];
                    cKnot = BTopKnots[0];
                    prevTx1 = 0; prevTx2 = 0; prevTy1 = 0; prevTy2 = 0;
                    //
                    for (int i = 0; i < BTopKnots.Length; i++)
                    {
                        cKnot = BTopKnots[i];
                        for (int j = 0; j < CTop.Length; j++)
                        {
                            if (cKnot == CTop[j])
                            {
                                if (i != 0)
                                {
                                    int prevKnot = BTopKnots[i - 1];
                                    double delx = (X[cKnot] - X[prevKnot]);
                                    double dely = (Y[cKnot] - Y[prevKnot]);
                                    double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
                                    // компоненты касательной между граничными точками
                                    double lx = 1 / ss * delx;
                                    double ly = 1 / ss * dely;
                                    double nx = -ly;
                                    double ny = lx;
                                    //
                                    double LsigX = (prevTx1 + Tx1_all[j]) / 2.0f * nx + (prevTx2 + Tx2_all[j]) / 2.0f * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
                                    double LsigY = (prevTy1 + Ty1_all[j]) / 2.0f * nx + (prevTy2 + Ty2_all[j]) / 2.0f * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
                                    //в полуцелых узлах
                                    TTau[i - 1] = (LsigX * lx + LsigY * ly);
                                    argT[i - 1] = X[prevKnot] + delx / 2.0f;
                                    //
                                    LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
                                    LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
                                    TTauC[i] = (LsigX * lx + LsigY * ly);

                                }
                                else
                                {
                                    int nextKnot = BTopKnots[i + 1];
                                    double delx = (X[nextKnot] - X[cKnot]);
                                    double dely = (Y[nextKnot] - Y[cKnot]);
                                    double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
                                    // компоненты касательной между граничными точками
                                    double lx = 1 / ss * delx;
                                    double ly = 1 / ss * dely;
                                    double nx = -ly;
                                    double ny = lx;
                                    //
                                    double LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
                                    double LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
                                    TTauC[i] = (LsigX * lx + LsigY * ly);
                                }
                                //
                                prevTx1 = Tx1_all[j];
                                prevTx2 = Tx2_all[j];
                                prevTy1 = Ty1_all[j];
                                prevTy2 = Ty2_all[j];
                                break;
                            }
                        }
                    }
                    TTau[count - 1] = TTau[count - 2];

                }
                if (IndexMethod == 0) //!!!-- 1 ый порядок точности, для Tau в целых и полуцелых узлах надо использовать через сплайн!
                {
                    //
                    double[] tau_mid = new double[BTriangles.Length];
                    //
                    OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, BTriangles.Length);
                    Parallel.ForEach(rangePartitioner,
                           (range, loopState) =>
                           {
                               for (int i = range.Item1; i < range.Item2; i++)
                               //for (int i = 0; i < BTriangles.Length; i++)
                               {

                                   double[] xL = new double[3];
                                   double[] yL = new double[3];
                                   //
                                   int LcurV = BTriangles[i];
                                   int[] Knots = Mesh.AreaElems[LcurV];
                                   //
                                   int Lnum1 = Knots[0];
                                   int Lnum2 = Knots[1];
                                   int Lnum3 = Knots[2];
                                   // получаем координаты узлов элемента
                                   xL[0] = X[Lnum1]; xL[1] = X[Lnum2]; xL[2] = X[Lnum3];
                                   yL[0] = Y[Lnum1]; yL[1] = Y[Lnum2]; yL[2] = Y[Lnum3];
                                   // нахождение площади треугольника
                                   double LS = Sk[LcurV];
                                   // скорости в вершинах треугольника
                                   double LU1 = U[Lnum1];
                                   double LU2 = U[Lnum2];
                                   double LU3 = U[Lnum3];
                                   //
                                   double LV1 = V[Lnum1];
                                   double LV2 = V[Lnum2];
                                   double LV3 = V[Lnum3];
                                   // касательный вектор (обход против часовой стрелки)
                                   double Lsx = Sx[i];
                                   double Lsy = Sy[i];
                                   // нормаль (направлена во внутрь КО)
                                   double Lnx = -Lsy;
                                   double Lny = Lsx;
                                   // производные в центре треугольника
                                   double Ldu_dx = 1.0f / 2.0f / LS * (LU1 * (yL[1] - yL[2]) + LU2 * (yL[2] - yL[0]) + LU3 * (yL[0] - yL[1]));
                                   double Ldu_dy = 1.0f / 2.0f / LS * (LU1 * (xL[2] - xL[1]) + LU2 * (xL[0] - xL[2]) + LU3 * (xL[1] - xL[0]));
                                   double Ldv_dx = 1.0f / 2.0f / LS * (LV1 * (yL[1] - yL[2]) + LV2 * (yL[2] - yL[0]) + LV3 * (yL[0] - yL[1]));
                                   double Ldv_dy = 1.0f / 2.0f / LS * (LV1 * (xL[2] - xL[1]) + LV2 * (xL[0] - xL[2]) + LV3 * (xL[1] - xL[0]));
                                   // давление в центре треугольника
                                   double LP_mid = (P[Lnum1] + P[Lnum2] + P[Lnum3]) / 3.0f;
                                   double Mu_mid = (nuT[Lnum1] + nuT[Lnum2] + nuT[Lnum3]) / 3.0f * rho_w;
                                   // составляющие тензора напряжений
                                   double Tx1 = -LP_mid + 2.0f * Mu_mid * Ldu_dx;
                                   double Tx2 = Mu_mid * (Ldu_dy + Ldv_dx);
                                   double Ty1 = Mu_mid * (Ldu_dy + Ldv_dx);
                                   double Ty2 = -LP_mid + 2.0f * Mu_mid * Ldv_dy;
                                   // компоненты вектора придонного напряжения
                                   double LsigX = Tx1 * Lnx + Tx2 * Lny;
                                   double LsigY = Ty1 * Lnx + Ty2 * Lny;
                                   //
                                   tau_mid[i] = (LsigX * Lsx + LsigY * Lsy);
                               }
                           });

                    // Вычисление tau в узлах сетки по сглаженной методике вычисления 
                    double[] Tau_all = Aproximate(tau_mid, CBottom, BTriangles);
                    //
                    //подготовка приграничных значений tau между граничными точками и координат для сплайна
                    int count = BBottomKnots.Length;
                    BTau = new double[count];
                    arg = new double[count];
                    int cKnot;
                    //
                    for (int i = 0; i < BBottomKnots.Length; i++)
                    {
                        cKnot = BBottomKnots[i];
                        for (int j = 0; j < CBottom.Length; j++)
                        {
                            if (cKnot == CBottom[j])
                            {

                                BTau[i] = Tau_all[j];
                                arg[i] = X[cKnot]; // аргумент - только X (чтобы легче проецировать на дно)
                                //arg[i] = Math.Sqrt(X[cKnot] * X[cKnot] + Y[cKnot] * Y[cKnot]);
                                break;
                            }
                        }
                    }
                }
                //
                if (IndexMethod == 1)//!!!-- 1 ый порядок точности, для Tau в целых и полуцелых узлах надо использовать через сплайн!
                {
                    //подготовка приграничных значений tau между граничными точками и координат для сплайна
                    arg = new double[BBottomKnots.Length];
                    //
                    OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(1, BBottomKnots.Length - 1);
                    Parallel.ForEach(rangePartitioner,
                           (range, loopState) =>
                           {
                               for (int i = range.Item1; i < range.Item2; i++)
                               //for (int i = 1; i < BBottomKnots.Length - 1; i++)
                               {
                                   //
                                   //           nnK(2)
                                   //            |
                                   //           nK(1)
                                   //            |
                                   //--wK(3)---cKnot(0)---eK(4)
                                   int cKnot = BBottomKnots[i];
                                   int wK = BBottomKnots[i - 1];
                                   int eK = BBottomKnots[i + 1];
                                   int nK = 0, nnK = 0;
                                   double delx = (X[eK] - X[wK]);
                                   double dely = (Y[eK] - Y[wK]);
                                   double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
                                   // компоненты касательной между граничными точками
                                   double lx = 1 / ss * delx;
                                   double ly = 1 / ss * dely;
                                   //нормаль к поверхности между узлами wK и eK
                                   double nx = -ly;
                                   double ny = lx;
                                   //
                                   double Ldu_dx = 0;
                                   double Ldu_dy = 0;
                                   double Ldv_dx = 0;
                                   double Ldv_dy = 0;
                                   double P_c = 0;
                                   //если дно почти горизонтальное, то считаем, что оно горизонтальное
                                   if (lx > 0.98)
                                   {
                                       nK = cKnot + 1;
                                       nnK = cKnot + 2;
                                       //x - это y(координата), y - это U (функция)
                                       double x0 = Y[cKnot];
                                       double y0 = U[cKnot];
                                       double x1 = Y[nK];
                                       double y1 = U[nK];
                                       double x2 = Y[nnK];
                                       double y2 = U[nnK];
                                       Ldu_dy = 1.0f / (x0 - x1) * y0 + 1.0f / (x0 - x2) * y0 + 1.0f / (x1 - x0) * (x0 - x2) / (x1 - x2) * y1 + 1.0f / (x2 - x0) * (x0 - x1) / (x2 - x1) * y2;
                                       //функция V - это y
                                       y0 = V[cKnot];
                                       y1 = V[nK];
                                       y2 = V[nnK];
                                       Ldv_dy = 1.0f / (x0 - x1) * y0 + 1.0f / (x0 - x2) * y0 + 1.0f / (x1 - x0) * (x0 - x2) / (x1 - x2) * y1 + 1.0f / (x2 - x0) * (x0 - x1) / (x2 - x1) * y2;
                                       Ldv_dx = 0;
                                       Ldu_dx = 0;
                                   }
                                   // если дно не горизонтальное
                                   else
                                   {

                                       double k = dy;
                                       FPoint[] PointsNorm = new FPoint[2];
                                       FPoint[] PointsTang = new FPoint[2];
                                       double[] U12 = new double[2]; double[] V12 = new double[2];
                                       double[] U34 = new double[2]; double[] V34 = new double[2];
                                       //
                                       for (int j = 0; j < 2; j++)
                                       {
                                           //точка на расстоянии k по направлению нормали
                                           PointsNorm[j] = new FPoint(X[cKnot] + nx * k * (j + 1), Y[cKnot] + ny * k * (j + 1));
                                           //
                                           int Triangle = Mesh.GetTriangle(PointsNorm[j].X, PointsNorm[j].Y);
                                           //
                                           double s05 = 1.0f / 2.0f / Sk[Triangle];
                                           int[] Knots = Mesh.AreaElems[Triangle];
                                           double x1 = X[Knots[0]]; double x2 = X[Knots[1]]; double x3 = X[Knots[2]];
                                           double y1 = Y[Knots[0]]; double y2 = Y[Knots[1]]; double y3 = Y[Knots[2]];
                                           double L1 = s05 * ((x2 * y3 - x3 * y2) + PointsNorm[j].X * (y2 - y3) + PointsNorm[j].Y * (x3 - x2));
                                           double L2 = s05 * ((x3 * y1 - x1 * y3) + PointsNorm[j].X * (y3 - y1) + PointsNorm[j].Y * (x1 - x3));
                                           double L3 = s05 * ((x1 * y2 - x2 * y1) + PointsNorm[j].X * (y1 - y2) + PointsNorm[j].Y * (x2 - x1));
                                           //
                                           U12[j] = L1 * U[Knots[0]] + L2 * U[Knots[1]] + L3 * U[Knots[2]];
                                           V12[j] = L1 * V[Knots[0]] + L2 * V[Knots[1]] + L3 * V[Knots[2]];
                                       }
                                       //аппроксимация по 4 точкам
                                       //double dPhids = (2 * PhiNormal[0] - 5 * PhiNormal[1] + 4 * PhiNormal[2] - PhiNormal[3]) / k / k;
                                       //аппрроксимация по трем точкам
                                       Ldu_dy = (-7 * U[cKnot] + 8 * U12[0] - U12[1]) / k / k / 2.0f;
                                       Ldv_dy = (-7 * V[cKnot] + 8 * V12[0] - V12[1]) / k / k / 2.0f;
                                       //
                                       //точка на расстоянии k по обоим направлениям по касательной от точки cKnot
                                       PointsTang[0] = new FPoint(X[cKnot] - lx * k, Y[cKnot] - ly * k);
                                       PointsTang[1] = new FPoint(X[cKnot] + lx * k, Y[cKnot] + ly * k);
                                       //
                                       for (int j = 0; j < 2; j++)
                                       {
                                           int Triangle = Mesh.GetTriangle(PointsTang[j].X, PointsTang[j].Y);
                                           //если область вогнутая, то хотя бы одна точка вдоль касательной бдует лежать вне области
                                           // здесь в таком случае влияние производных U и V  вдоль касательной не учитываем
                                           if (Triangle == -1)
                                           {
                                               U34[0] = 0; U34[1] = 0;
                                               V34[0] = 0; V34[1] = 0;
                                               break;
                                           }
                                           //
                                           double s05 = 1.0f / 2.0f / Sk[Triangle];
                                           int[] Knots = Mesh.AreaElems[Triangle];
                                           double x1 = X[Knots[0]]; double x2 = X[Knots[1]]; double x3 = X[Knots[2]];
                                           double y1 = Y[Knots[0]]; double y2 = Y[Knots[1]]; double y3 = Y[Knots[2]];
                                           double L1 = s05 * ((x2 * y3 - x3 * y2) + PointsNorm[j].X * (y2 - y3) + PointsNorm[j].Y * (x3 - x2));
                                           double L2 = s05 * ((x3 * y1 - x1 * y3) + PointsNorm[j].X * (y3 - y1) + PointsNorm[j].Y * (x1 - x3));
                                           double L3 = s05 * ((x1 * y2 - x2 * y1) + PointsNorm[j].X * (y1 - y2) + PointsNorm[j].Y * (x2 - x1));
                                           //
                                           U34[j] = L1 * U[Knots[0]] + L2 * U[Knots[1]] + L3 * U[Knots[2]];
                                           V34[j] = L1 * V[Knots[0]] + L2 * V[Knots[1]] + L3 * V[Knots[2]];

                                       }
                                       Ldu_dx = (U34[1] - U34[0]) / k / 2.0f;
                                       Ldv_dx = (V34[1] - V34[0]) / k / 2.0f;

                                   }
                                   //
                                   // давление в узле
                                   P_c = P[cKnot];
                                   double mu_c = nuT[cKnot] * rho_w;
                                   // составляющие тензора напряжений
                                   double Tx1 = -P_c + 2.0f * mu_c * Ldu_dx;
                                   double Tx2 = mu_c * (Ldu_dy + Ldv_dx);
                                   double Ty1 = mu_c * (Ldu_dy + Ldv_dx);
                                   double Ty2 = -P_c + 2.0f * mu_c * Ldv_dy;
                                   // компоненты вектора придонного напряжения
                                   double LsigX = Tx1 * nx + Tx2 * ny;
                                   double LsigY = Ty1 * nx + Ty2 * ny;
                                   // проекция вектора придонного напряжения на касательный вектор
                                   BTau[i] = (LsigX * lx + LsigY * ly);
                                   arg[i] = X[cKnot];

                                   //1/(x0-x1)*y0+1/(x0-x2)*y0+1/(x1-x0)*(x0-x2)/(x1-x2)*y1+1/(x2-x0)*(x0-x1)/(x2-x1)*y2

                               }
                           });
                    //
                }
            }
            catch (Exception e)
            {
                err = e.Message + "ShearStressesCalculation";
            }

        }
        void ShearStress(int[] BBottomKnots, int[] CBottom, int[] BTriangles, out double[] BTau, out double[] BTauC, out double[] arg)
        {
            BTauC = new double[BBottomKnots.Length];
            BTau = new double[BBottomKnots.Length];
            arg = new double[BBottomKnots.Length - 1];
            try
            {
                int count = BBottomKnots.Length;
                //
                double[] Tx1 = new double[BTriangles.Length];
                double[] Tx2 = new double[BTriangles.Length];
                double[] Ty1 = new double[BTriangles.Length];
                double[] Ty2 = new double[BTriangles.Length];
                //
                double[] tau_mid = new double[BTriangles.Length];
                //double e1x = 1, e1y = 0, e2x = 0, e2y = 1;//проекции
                //
                OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, BTriangles.Length);
                Parallel.ForEach(rangePartitioner,
                        (range, loopState) =>
                        {
                            for (int i = range.Item1; i < range.Item2; i++)
                            //for (int i = 0; i < BTriangles.Length; i++)
                            {

                                double[] xL = new double[3];
                                double[] yL = new double[3];
                                //
                                int LcurV = BTriangles[i];
                                int[] Knots = Mesh.AreaElems[LcurV];
                                //
                                int Lnum1 = Knots[0];
                                int Lnum2 = Knots[1];
                                int Lnum3 = Knots[2];
                                // получаем координаты узлов элемента
                                xL[0] = X[Lnum1]; xL[1] = X[Lnum2]; xL[2] = X[Lnum3];
                                yL[0] = Y[Lnum1]; yL[1] = Y[Lnum2]; yL[2] = Y[Lnum3];
                                // нахождение площади треугольника
                                double LS = Sk[LcurV];
                                // скорости в вершинах треугольника
                                double LU1 = U[Lnum1];
                                double LU2 = U[Lnum2];
                                double LU3 = U[Lnum3];
                                //
                                double LV1 = V[Lnum1];
                                double LV2 = V[Lnum2];
                                double LV3 = V[Lnum3];
                                // производные в центре треугольника
                                double Ldu_dx = 1.0f / 2.0f / LS * (LU1 * (yL[1] - yL[2]) + LU2 * (yL[2] - yL[0]) + LU3 * (yL[0] - yL[1]));
                                double Ldu_dy = 1.0f / 2.0f / LS * (LU1 * (xL[2] - xL[1]) + LU2 * (xL[0] - xL[2]) + LU3 * (xL[1] - xL[0]));
                                double Ldv_dx = 1.0f / 2.0f / LS * (LV1 * (yL[1] - yL[2]) + LV2 * (yL[2] - yL[0]) + LV3 * (yL[0] - yL[1]));
                                double Ldv_dy = 1.0f / 2.0f / LS * (LV1 * (xL[2] - xL[1]) + LV2 * (xL[0] - xL[2]) + LV3 * (xL[1] - xL[0]));
                                // давление в центре треугольника
                                double LP_mid = (P[Lnum1] + P[Lnum2] + P[Lnum3]) / 3.0f;
                                double Mu_mid = (nuT[Lnum1] + nuT[Lnum2] + nuT[Lnum3]) / 3.0f * rho_w;
                                // составляющие тензора напряжений
                                Tx1[i] = -LP_mid + 2.0f * Mu_mid * Ldu_dx;
                                Tx2[i] = Mu_mid * (Ldu_dy + Ldv_dx);
                                Ty1[i] = Mu_mid * (Ldu_dy + Ldv_dx);
                                Ty2[i] = -LP_mid + 2.0f * Mu_mid * Ldv_dy;
                            }
                        });
                // Вычисление tau в узлах сетки по сглаженной методике вычисления 
                //double[] Tau_all = Aproximate(tau_mid, CBottom, BTriangles);

                //вычисление тензора напряжений по сглаженной методике
                double[] Tx1_all = Aproximate(Tx1, CBottom, BTriangles);
                double[] Tx2_all = Aproximate(Tx2, CBottom, BTriangles);
                double[] Ty1_all = Aproximate(Ty1, CBottom, BTriangles);
                double[] Ty2_all = Aproximate(Ty2, CBottom, BTriangles);
                //подготовка приграничных значений tau между граничными точками и координат для сплайна

                int cKnot = BBottomKnots[0];
                double prevTx1 = 0, prevTx2 = 0, prevTy1 = 0, prevTy2 = 0;
                //
                for (int i = 0; i < BBottomKnots.Length; i++)
                {
                    cKnot = BBottomKnots[i];
                    for (int j = 0; j < CBottom.Length; j++)
                    {
                        if (cKnot == CBottom[j])
                        {
                            if (i != 0)
                            {
                                int prevKnot = BBottomKnots[i - 1];
                                double delx = (X[cKnot] - X[prevKnot]);
                                double dely = (Y[cKnot] - Y[prevKnot]);
                                double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
                                // компоненты касательной между граничными точками
                                double lx = 1 / ss * delx;
                                double ly = 1 / ss * dely;
                                double nx = -ly;
                                double ny = lx;
                                //
                                double LsigX = (prevTx1 + Tx1_all[j]) / 2.0f * nx + (prevTx2 + Tx2_all[j]) / 2.0f * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
                                double LsigY = (prevTy1 + Ty1_all[j]) / 2.0f * nx + (prevTy2 + Ty2_all[j]) / 2.0f * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
                                //в полуцелых узлах
                                BTau[i - 1] = (LsigX * lx + LsigY * ly);
                                arg[i - 1] = X[prevKnot] + delx / 2.0f;
                                //
                                LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
                                LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
                                BTauC[i] = (LsigX * lx + LsigY * ly);

                            }
                            else
                            {
                                int nextKnot = BBottomKnots[i + 1];
                                double delx = (X[nextKnot] - X[cKnot]);
                                double dely = (Y[nextKnot] - Y[cKnot]);
                                double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
                                // компоненты касательной между граничными точками
                                double lx = 1 / ss * delx;
                                double ly = 1 / ss * dely;
                                double nx = -ly;
                                double ny = lx;
                                //
                                double LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
                                double LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
                                BTauC[i] = (LsigX * lx + LsigY * ly);
                            }
                            //
                            prevTx1 = Tx1_all[j];
                            prevTx2 = Tx2_all[j];
                            prevTy1 = Ty1_all[j];
                            prevTy2 = Ty2_all[j];
                            break;
                        }
                    }
                }
                BTau[count - 1] = BTau[count - 2];
            }
            catch (Exception e)
            {
                err = e.Message + "ShearStressesCalculation";
            }
        }
        double[] Aproximate(double[] MiddleFunction, int[] GLKnots, int[] GTriangs)
        {
            int Count = GLKnots.Length;
            //
            double[] ExactFunc = new double[Count];
            //
            double[][] Matrix = new double[3][];
            for (int i = 0; i < 3; i++)
                Matrix[i] = new double[3];
            //
            try
            {
                SBand AlgB = new SBand();
                AlgB.SetSystem(Count, BWidth);
                // Вычисляем локальные матрицы жесткости и производим сборку глобальной матрицы жесткости
                int tr = 0;
                int[] GKnots, LKnots = new int[3];
                double S = 0; ;
                for (int k = 0; k < GTriangs.Length; k++)
                {
                    tr = GTriangs[k];
                    S = Sk[tr];
                    //S = Mesh.GetSquare(tr);
                    //переходим к локальной нумерации для СЛАУ
                    GKnots = Mesh.AreaElems[tr];
                    for (int i = 0; i < 3; i++)
                    {
                        for (int j = 0; j < Count; j++)
                        {
                            if (GKnots[i] == GLKnots[j])
                            {
                                LKnots[i] = j;
                                break;
                            }
                        }
                    }
                    //
                    // Вычисляем локальную матрицу жесткости 
                    // Расчет локальной матрицы жесткости для диффузионного члена
                    Matrix[0][0] = 1.0 / 6.0 * S;
                    Matrix[0][1] = 1.0 / 12.0 * S;
                    Matrix[0][2] = 1.0 / 12.0 * S;

                    Matrix[1][0] = 1.0 / 12.0 * S;
                    Matrix[1][1] = 1.0 / 6.0 * S;
                    Matrix[1][2] = 1.0 / 12.0 * S;

                    Matrix[2][0] = 1.0 / 12.0 * S;
                    Matrix[2][1] = 1.0 / 12.0 * S;
                    Matrix[2][2] = 1.0 / 6.0 * S;
                    // Формирование глобальной матрицы жесткости
                    AlgB.BuildMatrix(Matrix, LKnots);
                    //Mesh.SaveMesh("nn");
                    //
                    double[] tmpU = { MiddleFunction[k] * S / 3.0f, MiddleFunction[k] * S / 3.0f, MiddleFunction[k] * S / 3.0f };
                    //
                    AlgB.BuildRight(tmpU, LKnots);
                }
                // Решение системы алгебраических уравнений
                AlgGauss.Solve(AlgB);
                ExactFunc = AlgB.GetX;
            }
            catch (Exception e)
            {
                err = e.Message + "Aproximate fell down";
            }
            return ExactFunc;
        }
    }
    public class FPoint
    {
        public double X;
        public double Y;
        public FPoint(double x, double y)
        {
            X = x; Y = y;
        }
    }
}
//--------------------------------------------
//using AlgebraLibrary;
//using MeshLibrary;
//using System;
//using System.Collections.Concurrent;
//using System.Collections.Generic;
//using System.Diagnostics;
//using System.Linq;
//using System.Text;
//using System.Threading.Tasks;

//namespace HydrodynamicLibrary
//{
//    [Serializable]
//    public class WaterTaskEliz
//    {
//        #region Искомые величины и объекты для работы
//        public bool SerializeNow = false;
//        public string status = "Running";
//        public string err = "ok";
//        public int Iter = 0;
//        int beginIter = 0;
//        //
//        public double[] U = null;
//        public double[] V = null;
//        public double[] P = null;
//        public double[] ErrP = null;
//        double[] buffP = null;
//        double[] buffU = null;
//        double[] buffV = null;
//        public double[] BTau = null;
//        public double[] BTauС = null;
//        public double[] arg = null;//аргумент к BTau для сплайна
//        public double[] TTau = null;
//        public double[] TTauС = null;
//        public double[] argT = null;
//        //
//        /// <summary>
//        /// максимальная горизонтальная скорость
//        /// </summary>
//        double U_max = 0;
//        /// <summary>
//        /// Рейнольдс x = U*L/nu
//        /// </summary>
//        double Re = 1;
//        //
//        double rho_w = 1000;
//        /// <summary>
//        /// штраф неразрывности в давлении
//        /// </summary>
//        double alpha_n = 0.5f;
//        /// <summary>
//        /// штраф регуляризационной части в давлении
//        /// </summary>
//        double alpha_r = 0.5f;
//        /// <summary>
//        /// штраф фиктивного источника на правой границе
//        /// </summary>
//        double alpha_p = 0.5f;
//        //
//        //для контроля потери массы
//        //перемнные для баланса массы на входе и выходе
//        public double Q_in = 0;
//        public double Q_out = 0;
//        /// <summary>
//        /// ширина ленты
//        /// </summary>
//        public int BWidth = 0;
//        // 
//        /// <summary>
//        /// лист связности центрального узла CV[i][0] и окружающих его элементов (треугольников) CV[i][1..7]
//        /// </summary>
//        int[][] CV = null;
//        /// <summary>
//        /// упрощеная версия хранения граничных треугольников у дна
//        /// </summary>
//        int[] BTriangles = null;
//        /// <summary>
//        /// массив связности окружающих дно точек в глобальной и локальной нумерации
//        /// </summary>
//        int[] CBottom = null;
//        /// <summary>
//        /// упрощеная версия хранения граничных треугольников у своб. пов.
//        /// </summary>
//        int[] TTriangles = null;
//        /// <summary>
//        /// массив связности окружающих своб пов. точек в глобальной и локальной нумерации
//        /// </summary>
//        int[] CTop = null;
//        /// <summary>
//        /// массив - [] граничная точка на правой стенке, [] вершины треугольников, создающих грань с этой точкой, но не лежащие на нранице
//        /// </summary>
//        int[][] RightKnotsList = null;
//        int[][] TopKnotsList = null;
//        /// <summary>
//        /// генератор КЭ сетки для тестовой задачи
//        /// </summary>
//        public Mesh Mesh;
//        /// <summary>
//        /// решатель алгебраической задачи
//        /// </summary>
//        public SBand ABand = null;
//        public SSystem Sys = null;
//        /// <summary>
//        /// секундомер
//        /// </summary>
//        [NonSerialized]
//        Stopwatch stopW = null;
//        [NonSerialized]
//        TimeSpan timeSpan;
//        int remainTimeMin;
//        //
//        #endregion
//        //
//        double[] X = null, Y = null;
//        int iter = 1;
//        double dt = 0.0001f;
//        double tau = 0.01f;
//        double Q = 0;
//        public double dPdx = 0;
//        [NonSerialized]
//        double delta = 0.05;
//        double relaxP = 0.1f;
//        double nu = 0;
//        double mu = 0;
//        public int CountKnots = 0, CountTriangles = 0;
//        public double Ucp = 0;// значение средней скорости по суммированию профиля
//        double errP = 0.001f; // пмаксимальная допустимая погршность по давлению
//        //
//        AlgorythmGauss AlgGauss = new AlgorythmGauss();
//        Algorythm Alg = null;
//        //
//        public int _Nx = 0, _Ny = 0;
//        double dy = 0;
//        //
//        int NBottom = 0;
//        int NLeft = 0;
//        int NRight = 0;
//        int NTop = 0;
//        //
//        int[] BLeftKnots = null;
//        int[] BRightKnots = null;
//        int[] BBottomKnots = null;
//        int[] BTopKnots = null;
//        //
//        double[] RBC = null;
//        double[] BV = null;
//        bool surf_flag = false;
//        bool flag = true;
//        double[] R = null;
//        //
//        double[] Sk = null;
//        double[] b1 = null, b2 = null, b3 = null;
//        double[] c1 = null, c2 = null, c3 = null;
//        double[][] Lx10 = null;
//        double[][] Lx32 = null;
//        double[][] Ly01 = null;
//        double[][] Ly23 = null;
//        double[][] Alpha = null;
//        double[][] SS = null;
//        double[] S0 = null;
//        double[][] _Lk = null;
//        int[][] P1 = null;
//        double[][] Nx = null;
//        double[][] Ny = null;
//        double[] Sx, Sy;
//        public WaterTaskEliz(WElizParameter p, Mesh m, SSystem a, Algorythm Alg)
//        {
//            CountKnots = m.CountKnots;
//            CountTriangles = m.CountElems;
//            this.Alg = Alg;
//            //
//            BWidth = m.BandWidth();
//            //
//            Sys = a;
//            Sys.SetSystem(CountKnots, BWidth);
//            //
//            ABand = new SBand(CountKnots, BWidth);
//            //
//            InitMassives();
//            //
//            Re = p.Re;
//            alpha_n = p.alpha_n;
//            alpha_r = p.alpha_r;
//            //alpha_p = p.alpha_p;
//            Q = p.Q;
//            dt = p.dt_local;
//            tau = p.tau;
//            relaxP = p.relaxP;
//            mu = p.mu;
//            errP = p.errP;
//            surf_flag = p.surf_flag;
//            iter = p.iter;
//            nu = p.nu_m;
//            delta = p.delta;
//            //
//            //ChangeMesh(m);
//        }

//        private void InitMassives()
//        {
//            U = new double[CountKnots];
//            V = new double[CountKnots];
//            P = new double[CountKnots];
//            ErrP = new double[CountKnots];

//        }
//        public void ChangeMesh(Mesh m)
//        {
//            Mesh = m;
//            //обновление геометрии
//            Sk = Mesh.Sk;
//            b1 = Mesh.b1;
//            b2 = Mesh.b2;
//            b3 = Mesh.b3;
//            c1 = Mesh.c1;
//            c2 = Mesh.c2;
//            c3 = Mesh.c3;
//            BLeftKnots = Mesh.LeftKnots;
//            BRightKnots = Mesh.RightKnots;
//            BBottomKnots = Mesh.BottomKnots;
//            BTopKnots = Mesh.TopKnots;
//            NLeft = Mesh.CountLeft;
//            NRight = Mesh.CountRight;
//            NTop = Mesh.CountTop;
//            NBottom = Mesh.CountBottom;
//            X = Mesh.X;
//            Y = Mesh.Y;
//            _Ny = NLeft;
//            _Nx = NBottom;
//            RightKnotsList = Mesh.CPRight;
//            TopKnotsList = Mesh.CPTop;
//            BTriangles = Mesh.BTriangles;
//            CBottom = Mesh.CBottom;
//            TTriangles = Mesh.TTriangles;
//            CTop = Mesh.CTop;
//            CV = Mesh.CVolumes;
//            //
//            Lx10 = Mesh.Lx10;
//            Lx32 = Mesh.Lx32;
//            Ly01 = Mesh.Ly01;
//            Ly23 = Mesh.Ly23;
//            Alpha = Mesh.Alpha;
//            S0 = Mesh.S0;
//            SS = Mesh.S;
//            P1 = Mesh.P1;
//            _Lk = Mesh.Lk;
//            Nx = Mesh.Nx;
//            Ny = Mesh.Ny;
//            Sx = Mesh.Sx;
//            Sy = Mesh.Sy;
//            //

//            InitialConditions();
//        }
//        void InitialConditions()
//        {
//            //Начальное условие для скорости
//            double[] u0 = new double[NLeft];
//            double y;
//            //double Hn = Y[BLeftKnots[0]] - Y[BLeftKnots[NLeft - 1]];
//            //
//            //U_max = (double)(3.0 / 2.0 * Q / Hn);
//            //dPdx = (double)(-8.0 * U_max * mu / Hn / Hn);
//            //
//            if (!surf_flag)
//            {
//                //левая и правая граница


//                // ГУ уступ
//                //double Hn = Y[BLeftKnots[0]] - Y[BLeftKnots[NLeft / 2]];
//                //U_max = 3.0 / 2.0 * Q / Hn;
//                //dPdx = -8.0 * U_max * mu / Hn / Hn;
//                //for (int i = 0; i < NLeft / 2; i++)
//                //{
//                //    int knot = BLeftKnots[i];
//                //    y = (Y[knot] - Y[0]);
//                //    U[knot] = 1.0 / 2.0 / mu * dPdx * (y - Hn) * (y - H);
//                //    Ucp += U[knot];
//                //    //knot = BRightKnots[i];
//                //    //U[knot] = 1.0 / 2.0 / mu * dPdx * (y - Hn) * y;
//                //}
//                // ГУ поток
//                double H = Y[BLeftKnots[0]] - Y[BLeftKnots[NLeft - 1]];
//                U_max = 3.0 / 2.0 * Q / H;
//                dPdx = -8.0 * U_max * mu / H / H;
//                for (int i = 0; i < NLeft; i++)
//                {
//                    int knot = BLeftKnots[i];
//                    y = (Y[knot] - Y[0]);
//                    U[knot] = (double)(1.0 / 2.0 / mu * dPdx * (y - H) * y);
//                    Ucp += U[knot];
//                    //Тест
//                    //P[knot] = -dPdx * (L - X[knot]);
//                    ////
//                    knot = BRightKnots[i];
//                    U[knot] = (double)(1.0 / 2.0 / mu * dPdx * (y - H) * y);
//                }
//                Ucp /= NLeft;

//                if (flag)
//                {

//                    // внутренняя область
//                    //идеальное НУ
//                    for (int i = 0; i < CV.Length; i++)
//                    {
//                        int knot = CV[i][0];
//                        y = (Y[knot] - Y[0]);
//                        if (y >= 0)
//                            U[knot] = (double)(1.0 / 2.0 / mu * dPdx * (y - H) * y);
//                    }
//                    //
//                    buffP = new double[CountKnots];
//                    buffU = new double[CountKnots];
//                    buffV = new double[CountKnots];
//                    flag = false;
//                }
//                else
//                {
//                    // решение с предыдущего расчета
//                    for (int i = 0; i < CountKnots; i++)
//                    {
//                        U[i] = buffU[i];
//                        V[i] = buffV[i];
//                        P[i] = buffP[i];
//                    }
//                }
//            }
//            else
//            {
//                for (int i = 0; i < NLeft; i++)
//                {
//                    int knot = BLeftKnots[i];
//                    y = Y[knot];
//                    U[knot] = (double)(1 / 2.0 / mu * dPdx * (-y) * y);
//                }
//            }
//            //ГУ на левой стенке для КЭ
//            // массивы для ГУ
//            RBC = new double[NRight];
//            BV = new double[NLeft];
//            //главные ГУ
//            for (int i = 0; i < NLeft - 1; i++)
//            {
//                double y1 = Y[BLeftKnots[i]];
//                double y2 = Y[BLeftKnots[i + 1]];
//                //
//                double r3 = (double)(-Math.Abs(y1 - y2) / 2.0 * (dPdx) * (-1));
//                //
//                BV[i] += r3;
//                BV[i + 1] += r3;
//            }
//        }
//        public void Run()
//        {

//            double MaxError = 0; // максимальная порешность по давлению
//            //pr(new Form1.ReportDelegate(Program.mm.Report), "Расчет гидродинамики");
//            //////////
//            int knot = 0;
//            int count = 0;
//            double sumBU = 0;
//            //
//            int knotUp = 0, knotRightU = 0, knotRightD = 0, knotDown = 0;
//            //
//            double[] Result = null;
//            //
//            double[] BV2 = new double[NRight];
//            //
//            stopW = new Stopwatch();
//            double qf = 0;
//            //WriteToData();
//            try
//            {
//                System.Object lockThis = new System.Object();
//                //stopW.Start();
//                for (int iteration = beginIter; iteration < iter; iteration++)
//                {
//                    //System.Threading.Thread.Sleep(5000);

//                    ///------Протестировано ОК
//                    ////////////////// МКЭ давление /////////////////////
//                    #region Расчет давления
//                    Sys.ClearSystem();
//                    if (iteration != 0)
//                        Sys.SetX(Result);
//                    // выделение памяти под результат решения задачи
//                    Result = new double[Mesh.CountKnots];
//                    //выделяем масивы для локальных правых частей
//                    // основной цикл по конечным элементам
//                    // вычисляем локальные матрицы жесткости и производим сборку глобальной матрицы жесткости
//                    //OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, Mesh.CountElems);
//                    //Parallel.ForEach(rangePartitioner,
//                    //      (range, loopState) =>
//                    //      {
//                    //          for (int fe = range.Item1; fe < range.Item2; fe++)
//                    for (int fe = 0; fe < Mesh.CountElems; fe++)
//                    {
//                        // выделяем массивы для локальных матриц жесткости
//                        double[][] M = new double[3][];
//                        for (int k = 0; k < 3; k++)
//                        {
//                            M[k] = new double[3];
//                        }
//                        //и номера его вершин
//                        int[] LKnots = Mesh.AreaElems[fe];
//                        // нахождение площади треугольника
//                        double LSk = Sk[fe];
//                        // расчитываем геометрию элемента 
//                        double Lb1 = b1[fe];
//                        double Lb2 = b2[fe];
//                        double Lb3 = b3[fe];
//                        double Lc1 = c1[fe];
//                        double Lc2 = c2[fe];
//                        double Lc3 = c3[fe];
//                        // расчет локальной матрицы жесткости для диффузионного члена
//                        M[0][0] = -LSk * (Lb1 * Lb1 + Lc1 * Lc1);
//                        M[0][1] = -LSk * (Lb1 * Lb2 + Lc1 * Lc2);
//                        M[0][2] = -LSk * (Lb1 * Lb3 + Lc1 * Lc3);

//                        M[1][0] = -LSk * (Lb2 * Lb1 + Lc2 * Lc1);
//                        M[1][1] = -LSk * (Lb2 * Lb2 + Lc2 * Lc2);
//                        M[1][2] = -LSk * (Lb2 * Lb3 + Lc2 * Lc3);

//                        M[2][0] = -LSk * (Lb3 * Lb1 + Lc3 * Lc1);
//                        M[2][1] = -LSk * (Lb3 * Lb2 + Lc3 * Lc2);
//                        M[2][2] = -LSk * (Lb3 * Lb3 + Lc3 * Lc3);
//                        lock (lockThis)
//                            Sys.BuildMatrix(M, LKnots);
//                    }

//                    // });
//                    R = new double[CountKnots];
//                    //сборка правой части
//                    OrderablePartitioner<Tuple<int, int>> rangePartitioner1 = Partitioner.Create(0, Mesh.CountElems);
//                    Parallel.ForEach(rangePartitioner1,
//                            (range, loopState) =>
//                            {
//                                for (int fe = range.Item1; fe < range.Item2; fe++)
//                                //for(int fe=0;fe<Mesh.CountElem;fe++)
//                                {

//                                    //for (int fe = 0; fe < Mesh.CountElem; fe++)
//                                    //{
//                                    double[] RR = new double[3];
//                                    // получаем текущий конечный элемент
//                                    int[] LKnots = Mesh.AreaElems[fe];
//                                    int Lm1 = LKnots[0];
//                                    int Lm2 = LKnots[1];
//                                    int Lm3 = LKnots[2];
//                                    // нахождение площади треугольника
//                                    double LSk = Sk[fe];
//                                    // расчитываем геометрию элемента 
//                                    double Lb1 = b1[fe];
//                                    double Lb2 = b2[fe];
//                                    double Lb3 = b3[fe];
//                                    double Lc1 = c1[fe];
//                                    double Lc2 = c2[fe];
//                                    double Lc3 = c3[fe];
//                                    //
//                                    double LU1 = U[Lm1]; double LU2 = U[Lm2]; double LU3 = U[Lm3];
//                                    double LV1 = V[Lm1]; double LV2 = V[Lm2]; double LV3 = V[Lm3];
//                                    //правая часть - неразрывность
//                                    double LSR = rho_w * LSk / (3 * tau) * ((Lb1 * LU1 + Lb2 * LU2 + Lb3 * LU3) + (Lc1 * LV1 + Lc2 * LV2 + Lc3 * LV3));
//                                    RR[0] = alpha_n * LSR;
//                                    RR[1] = alpha_n * LSR;
//                                    RR[2] = alpha_n * LSR;
//                                    //правая часть поправка КГД
//                                    double LBUU = (Lb1 * LU1 + Lb2 * LU2 + Lb3 * LU3) * (LU1 + LU2 + LU3);
//                                    double LCUV = (Lc1 * LU1 + Lc2 * LU2 + Lc3 * LU3) * (LV1 + LV2 + LV3);
//                                    double LBVU = (Lb1 * LV1 + Lb2 * LV2 + Lb3 * LV3) * (LU1 + LU2 + LU3);
//                                    double LCVV = (Lc1 * LV1 + Lc2 * LV2 + Lc3 * LV3) * (LV1 + LV2 + LV3);
//                                    //
//                                    RR[0] += alpha_r * rho_w * LSk / 3.0 * (Lb1 * (LBUU + LCUV) + Lc1 * (LBVU + LCVV));
//                                    RR[1] += alpha_r * rho_w * LSk / 3.0 * (Lb2 * (LBUU + LCUV) + Lc2 * (LBVU + LCVV));
//                                    RR[2] += alpha_r * rho_w * LSk / 3.0 * (Lb3 * (LBUU + LCUV) + Lc3 * (LBVU + LCVV));
//                                    //ГУ по Фомину
//                                    //RR[0] += alpha_p * rho_w * LSk / 3.0 * (1 / dt * qf);
//                                    //RR[1] += alpha_p * rho_w * LSk / 3.0 * (1 / dt * qf);
//                                    //RR[2] += alpha_p * rho_w * LSk / 3.0 * (1 / dt * qf);
//                                    //
//                                    //для отображения невязки
//                                    R[Lm1] += RR[0];
//                                    R[Lm2] += RR[1];
//                                    R[Lm3] += RR[2];
//                                    //}
//                                }

//                            });
//                    //
//                    Sys.BuildRight(R, null);
//                    //ГУ слева
//                    Sys.BuildRight(BV, BLeftKnots);
//                    //главные ГУ справа 2
//                    //if (iteration == iter - 1)
//                    //    DongBC_PE();
//                    //else
//                    //    DongBC_P();
//                    // ГУ P=0 справа    //
//                    RBC = new double[NRight];
//                    // для Dong убрать  //
//                    Sys.SetBoundary(RBC, BRightKnots);
//                    //Sys.SetBoundary(BV2, BRightKnots);
//                    //Sys.SetBoundary(new double[] { 0 }, new int[] { BRightKnots[NRight - 1] }); // задаем ноль в правой верхней точке
//                    // решение системы алгебраических уравнений
//                    Sys.Accept(Alg);
//                    Result = Sys.GetX;
//                    //для отладки
//                    for (int i = 0; i < NLeft; i++)
//                        R[BLeftKnots[i]] += BV[i];
//                    for (int i = 0; i < NRight; i++)
//                        R[BRightKnots[i]] = 0;
//                    //
//                    // релаксация решения, буферизация и вычисление погрешности
//                    MaxError = 0;// масимальная ошибка в области
//                    for (int i = 0; i < CountKnots; i++)
//                    {
//                        //релаксация
//                        P[i] = (1 - relaxP) * P[i] + relaxP * Result[i];
//                        //вычисление погрешности
//                        double CurErr = Math.Abs((P[i] - buffP[i]) / P[i]);
//                        if (MaxError < CurErr)
//                            MaxError = CurErr;
//                        ErrP[i] = CurErr;
//                        //буферизация
//                        buffP[i] = P[i];
//                    }
//                    #endregion

//                    ///------Протестировано ОК
//                    ////////////////// МКО скорость /////////////////////
//                    #region Расчет скоростей
//                    //int knotCorner = 0;
//                    //for (int j = 0; j < NBottom - 1; j++)
//                    //{
//                    //    knotCorner = Mesh.BottomKnots[j];
//                    //    int knot2 = Mesh.BottomKnots[j + 1];
//                    //    if (Mesh.Y[knotCorner] - Mesh.Y[knot2] > 0.0000001)
//                    //        break;
//                    //}
//                    //knotCorner += (NLeft + NRight / 2);
//                    //цикл по внутренним КО
//                    OrderablePartitioner<Tuple<int, int>> rangePartitioner3 = Partitioner.Create(0, CV.Length);
//                    Parallel.ForEach(rangePartitioner3,
//                            (range, loopState) =>
//                            {
//                                for (int i = range.Item1; i < range.Item2; i++)
//                                //for (int i = 0; i < CV.Length; i++)
//                                {
//                                    double LsummU = 0;//потоки U скорости
//                                    double LsummV = 0;//потоки V скорости
//                                    //
//                                    int p0 = CV[i][0];
//                                    int jj = CV[i].Length - 1;//количество КО, связанных с данным узлом
//                                    //if (p0 == knotCorner)
//                                    //    continue;
//                                    for (int j = 0; j < jj; j++)
//                                    {
//                                        double _lx10 = Lx10[i][j]; double _lx32 = Lx32[i][j];
//                                        double _ly01 = Ly01[i][j]; double _ly23 = Ly23[i][j];
//                                        //площадь
//                                        double LS = SS[i][j];
//                                        //сосоедние элементы
//                                        int Lv1 = CV[i][(j + 1) % jj + 1];
//                                        int Lv2 = CV[i][j + 1];
//                                        //вторая точка общей грани
//                                        int Lp1 = P1[i][j];
//                                        //находим значения функций в центрах масс 1ого и 2ого треугольника как средние значения по элементу
//                                        int[] Knots1 = Mesh.AreaElems[Lv1];
//                                        int Lt1 = Knots1[0]; int Lt2 = Knots1[1]; int Lt3 = Knots1[2];
//                                        double LUc1 = (U[Lt1] + U[Lt2] + U[Lt3]) / 3.0;
//                                        double LVc1 = (V[Lt1] + V[Lt2] + V[Lt3]) / 3.0;
//                                        double LPc1 = (P[Lt1] + P[Lt2] + P[Lt3]) / 3.0;
//                                        int[] Knots2 = Mesh.AreaElems[Lv2];
//                                        int Lz1 = Knots2[0]; int Lz2 = Knots2[1]; int Lz3 = Knots2[2];
//                                        double LUc2 = (U[Lz1] + U[Lz2] + U[Lz3]) / 3.0;
//                                        double LVc2 = (V[Lz1] + V[Lz2] + V[Lz3]) / 3.0;
//                                        double LPc2 = (P[Lz1] + P[Lz2] + P[Lz3]) / 3.0;
//                                        //значения производных в точке пересечения граней
//                                        double Ls2 = 2 * LS;
//                                        double Ldudx = ((LUc1 - LUc2) * _ly01 + (U[Lp1] - U[p0]) * _ly23) / Ls2;
//                                        double Ldudy = ((LUc1 - LUc2) * _lx10 + (U[Lp1] - U[p0]) * _lx32) / Ls2;
//                                        double Ldvdx = ((LVc1 - LVc2) * _ly01 + (V[Lp1] - V[p0]) * _ly23) / Ls2;
//                                        double Ldvdy = ((LVc1 - LVc2) * _lx10 + (V[Lp1] - V[p0]) * _lx32) / Ls2;
//                                        double Ldpdx = ((LPc1 - LPc2) * _ly01 + (P[Lp1] - P[p0]) * _ly23) / Ls2;
//                                        double Ldpdy = ((LPc1 - LPc2) * _lx10 + (P[Lp1] - P[p0]) * _lx32) / Ls2;
//                                        //внешняя нормаль к грани КО (контуру КО)
//                                        double Lnx = Nx[i][j]; double Lny = Ny[i][j];
//                                        ////значение функций в точке пересечения грани КО и основной грани
//                                        double Lalpha = Alpha[i][j];
//                                        double LUcr = Lalpha * U[p0] + (1 - Lalpha) * U[Lp1];
//                                        double LVcr = Lalpha * V[p0] + (1 - Lalpha) * V[Lp1];
//                                        double LPcr = Lalpha * P[p0] + (1 - Lalpha) * P[Lp1];
//                                        //длина текущего фрагмента внешнего контура КО
//                                        double LLk = _Lk[i][j];
//                                        //расчет потоков
//                                        double Lpress = -1.0 / rho_w * LPcr * Lnx;
//                                        double LconvU = -LUcr * LUcr * Lnx - (LUcr * LVcr) * Lny;
//                                        double LdiffU = nu * (2.0 * Ldudx * Lnx - 2.0 / 3.0 * (Ldudx + Ldvdy) * Lnx + Ldudy * Lny + Ldvdx * Lny);
//                                        double LregU1 = 2.0 * tau * LUcr * (LUcr * Ldudx + LVcr * Ldudy + 1.0 / rho_w * Ldpdx) * Lnx;
//                                        double LregU2 = tau * (LVcr * (LUcr * Ldudx + LVcr * Ldudy + 1.0 / rho_w * Ldpdx) + LUcr * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0 / rho_w * Ldpdy)) * Lny;
//                                        double LregU = LregU1 + LregU2;
//                                        LsummU += (LconvU + LdiffU + LregU + Lpress) * LLk;
//                                        //                  
//                                        double LpressV = -1.0 / rho_w * LPcr * Lny;
//                                        double LconvV = -(LUcr * LVcr) * Lnx - LVcr * LVcr * Lny;
//                                        double LdiffV = nu * (2.0 * Ldvdy * Lny - 2.0 / 3.0 * (Ldudx + Ldvdy) * Lny + Ldvdx * Lnx + Ldudy * Lnx);
//                                        double LregV1 = 2.0 * tau * LVcr * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0 / rho_w * Ldpdy) * Lny;
//                                        double LregV2 = tau * (LVcr * (LUcr * Ldudx + LVcr * Ldudy + 1.0 / rho_w * Ldpdx) + LUcr * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0 / rho_w * Ldpdy)) * Lnx;
//                                        double LregV = LregV1 + LregV2;
//                                        LsummV += (LconvV + LdiffV + LregV + LpressV) * LLk;
//                                    }
//                                    //
//                                    //lock (lockThis)
//                                    //{
//                                    U[p0] = U[p0] + dt / S0[i] * LsummU;
//                                    V[p0] = V[p0] + dt / S0[i] * LsummV;
//                                    //
//                                    if ((U[p0] > 10000) || (double.IsNaN(U[p0])))
//                                    {
//                                        err = " U в бесконечность";
//                                        //iteration = iter;
//                                        return;
//                                    }
//                                    //}

//                                }

//                            });


//                    //U[knotCorner] = U[knotCorner - 1];
//                    //если задача со свободной поверхностью
//                    if (surf_flag)
//                        U[BLeftKnots[0]] = U[BTopKnots[BTopKnots.Length - 2]];
//                    //ГУ на правой стенке - по КО
//                    //for (int i = 0; i < NRight - 2; i++)
//                    //{
//                    //    knot = RightKnotsList[i][0];
//                    //    count = RightKnotsList[i].Length - 1;
//                    //    sumBU = 0;
//                    //    sumBV = 0;
//                    //    for (int m = 0; m < count; m++)
//                    //    {
//                    //        sumBU += (double)1 / count * U[RightKnotsList[i][m + 1]];
//                    //        sumBV += (double)1 / count * V[RightKnotsList[i][m + 1]];
//                    //    }
//                    //    U[knot] = sumBU;
//                    //    V[knot] = sumBV;
//                    //}
//                    //
//                    //ГУ Dong
//                    //if (iteration == iter - 1)
//                    //    DongBC_UE();
//                    //else
//                    //    DongBC_U();
//                    //ГУ справа - снос
//                    for (int i = 0; i < NRight; i++)
//                    {
//                        knot = BRightKnots[i];
//                        //
//                        U[knot] = U[knot - NRight];
//                        V[knot] = V[knot - NRight];
//                    }
//                    //
//                    //
//                    //TEST - на вход то же, что и на выходе
//                    //for (int i = 0; i < NLeft; i++)
//                    //{
//                    //    int r = BRightKnots[i];
//                    //    int l = BLeftKnots[NLeft - i - 1];
//                    //    U[l] = U[r];
//                    //}
//                    //for (int i = 0; i < NLeft; i++)
//                    //{
//                    //    int r = BRightKnots[i];
//                    //    int l = BLeftKnots[NLeft - i - 1];
//                    //    U[r] = U[l];
//                    //}
//                    ////----------------
//                    //если задача со свободной поверхностью
//                    if (surf_flag)
//                    {
//                        //ГУ на верхней стенке 
//                        for (int i = 0; i < NTop - 2; i++)
//                        {
//                            knot = TopKnotsList[i][0];
//                            count = TopKnotsList[i].Length - 1;
//                            sumBU = 0;
//                            for (int m = 0; m < count; m++)
//                                sumBU += (double)1 / count * U[TopKnotsList[i][m + 1]];
//                            //    
//                            U[knot] = sumBU;
//                        }
//                        //
//                        knotUp = Mesh.TopKnots[1];
//                        knotRightU = BRightKnots[NRight - 1];
//                        U[knotRightU] = U[knotUp];
//                        //
//                        knotDown = BBottomKnots[NBottom - 2];
//                        knotRightD = BRightKnots[0];
//                        U[knotRightD] = U[knotDown];
//                    }
//                    //

//                    #endregion
//                    // 
//                    for (int i = 0; i < CountKnots; i++)
//                    {
//                        buffU[i] = U[i];
//                        buffV[i] = V[i];
//                    }
//                    //ГУ Фомин
//                    //вычисление коррекции скорости на выходе
//                    //расходы на границах
//                    //Q_in = 0; Q_out = 0;
//                    //double Qaout = 0;
//                    //double[] _dy = new double[NLeft];
//                    //int _b0 = 0, _b1 = 0;
//                    //for (int i = 1; i < _Ny - 1; i++)
//                    //{
//                    //    _b0 = BLeftKnots[i - 1];
//                    //    _b1 = BLeftKnots[i + 1];
//                    //    //
//                    //    _dy[i] = (Y[_b0] - Y[_b1]) / 2.0;
//                    //}
//                    //_dy[0] = (Y[BLeftKnots[0]] - Y[BLeftKnots[1]]);
//                    //_dy[NLeft - 1] = (Y[BLeftKnots[NLeft - 2]] - Y[BLeftKnots[NLeft - 1]]);
//                    ////
//                    //for (int i = 0; i < _Ny; i++)
//                    //{
//                    //    Q_in += U[BLeftKnots[NLeft - 1 - i]] * _dy[i];
//                    //    Q_out += U[BRightKnots[i]] * _dy[i];
//                    //    Qaout += Math.Abs(U[BRightKnots[i]] * _dy[i]);
//                    //}
//                    //// корректирующий коэффициент
//                    //double alphaM = 0.1;
//                    //double alphaOut = Math.Max(-alphaM, Math.Min(alphaM, (Q_in - Q_out) / Qaout));
//                    //double bufU;
//                    //for (int i = 0; i < _Ny; i++)
//                    //{
//                    //    bufU = buffU[BRightKnots[i]];
//                    //    U[BRightKnots[i]] = (1 + Math.Sign(bufU) * alphaOut) * bufU;
//                    //}
//                    ////вычисление значения фиктивного источника
//                    //Q_out = 0;
//                    //for (int i = 0; i < _Ny; i++)
//                    //    Q_out += U[BRightKnots[i]] * _dy[i];
//                    //double H = Y[BLeftKnots[0]] - Y[BLeftKnots[NLeft - 1]];
//                    //double L = X[BBottomKnots[NBottom - 1]] - X[BBottomKnots[0]];
//                    //qf = (Q_out - Q_in) / (H * L);
//                    //
//                    //
//                    //выход из цикла если ошибка меньше или равно errP
//                    //if (MaxError <= errP)
//                    //{
//                    //    Iter = iteration + 1;
//                    //    break;
//                    //}
//                    //
//                    beginIter = iteration + 1;
//                    if (SerializeNow)
//                    {
//                        status = "Stoped";
//                        return;
//                    }
//                    Iter = iteration + 1;
//                    //Q_in = 0; Q_out = 0;
//                    //for (int k = 0; k < NLeft - 1; k++)
//                    //{
//                    //    int a = BLeftKnots[k];
//                    //    int b = BLeftKnots[k + 1];
//                    //    Q_in += (U[a] + U[b]) * 0.5f * Math.Abs(Y[a] - Y[b]);
//                    //}
//                    ////
//                    //for (int k = 1; k < NRight - 1; k++)
//                    //{
//                    //    int a = BRightKnots[k];
//                    //    int b = BRightKnots[k + 1];
//                    //    Q_out += (U[a] + U[b]) * 0.5f * Math.Abs(Y[a] - Y[b]);
//                    //}
//                }
//                //Iter = iter;
//                //расход на входе и выходе из расчетной области
//                beginIter = 0;
//                Q_in = 0; Q_out = 0;
//                for (int k = 0; k < NLeft - 1; k++)
//                {
//                    int a = BLeftKnots[k];
//                    int b = BLeftKnots[k + 1];
//                    Q_in += (U[a] + U[b]) * 0.5f * Math.Abs(Y[a] - Y[b]);
//                }
//                //
//                for (int k = 1; k < NRight - 1; k++)
//                {
//                    int a = BRightKnots[k];
//                    int b = BRightKnots[k + 1];
//                    Q_out += (U[a] + U[b]) * 0.5f * Math.Abs(Y[a] - Y[b]);
//                }
//            }
//            catch (Exception ex)
//            {
//                err = err + "WaterTask.Run " + ex.Message;
//            }
//            //вычисление сдвиговых напряжений на дне
//            //ShearStresses();
//            //ShearStress(BBottomKnots, CBottom, BTriangles, out BTau, out BTauС, out arg);
//            //ShearStress(BTopKnots, CTop, TTriangles, out TTau, out TTauС, out argT);
//        }
//        //----Тест        ///
//        public double[] p_conv, p_kinet;
//        public double[] u_press, u_kinet, u_cont;
//        private void DongBC_UE(double delta = 0.05)
//        {
//            u_cont = new double[NRight];
//            u_kinet = new double[NRight];
//            u_press = new double[NRight];
//            //
//            int knot = BRightKnots[0];
//            double du = 0, dv = 0;
//            double dx = (X[knot] - X[knot - NRight]);
//            double dy = (Y[knot + 2] - Y[knot + 1]);
//            for (int i = 1; i < NRight - 1; i++)
//            {
//                knot = BRightKnots[i];
//                du = (U[knot] - U[knot - NRight]) / dx;
//                if (V[knot] < 0)
//                    dv = (V[knot] - V[knot - 1]) / dy;
//                else
//                    dv = (V[knot + 1] - V[knot]) / dy;
//                u_press[i] = 1.0 / mu * P[knot];
//                u_kinet[i] = rho_w / 4.0 / mu * (U[knot] * U[knot] + V[knot] * V[knot]) * (1 - Math.Tanh(+U[knot] / Ucp / delta));
//                u_cont[i] = du + dv;
//                U[knot] = U[knot - NRight] + dx * (u_press[i] + u_kinet[i] - u_cont[i]);
//                V[knot] = V[knot - NRight];
//            }
//        }

//        private void DongBC_PE(double delta = 0.05)
//        {
//            p_conv = new double[NRight];
//            p_kinet = new double[NRight];
//            //
//            int knot = 0;
//            for (int i = 0; i < NRight; i++)
//            {
//                RBC[i] = 0;
//                knot = BRightKnots[i];
//                p_kinet[i] = 0.25 * rho_w * (U[knot] * U[knot] + V[knot] * V[knot]) * (1 - Math.Tanh(U[knot] / Ucp / delta));
//                p_conv[i] = mu * (U[knot] - U[knot - NRight]) / (X[knot] - X[knot - NRight]);
//                //
//                RBC[i] = p_conv[i] - p_kinet[i];
//            }
//            RBC[0] = RBC[1];
//            RBC[NRight - 1] = RBC[NRight - 2];
//            //
//            p_kinet[0] = p_kinet[1];
//            p_conv[0] = p_conv[1];
//            p_kinet[NRight - 1] = p_kinet[NRight - 2];
//            p_conv[NRight - 1] = p_conv[NRight - 2];
//        }
//        //----  ///
//        private void DongBC_U(double delta = 0.05)
//        {
//            int knot = BRightKnots[0];
//            double du = 0, dv = 0;
//            double dx = (X[knot] - X[knot - NRight]);
//            double dy = (Y[knot + 2] - Y[knot + 1]);
//            for (int i = 1; i < NRight - 1; i++)
//            {
//                knot = BRightKnots[i];
//                du = (U[knot] - U[knot - NRight]) / dx;
//                if (V[knot] < 0)
//                    dv = (V[knot] - V[knot - 1]) / dy;
//                else
//                    dv = (V[knot + 1] - V[knot]) / dy;
//                U[knot] = U[knot - NRight] + dx / mu * (P[knot] + rho_w / 4.0 * (U[knot] * U[knot] + V[knot] * V[knot]) * (1 - Math.Tanh(+U[knot] / Ucp / delta))) - dx * (du + dv);
//                V[knot] = V[knot - NRight];
//            }
//        }

//        private void DongBC_P(double delta = 0.05)
//        {
//            int knot = 0;
//            for (int i = 0; i < NRight; i++)
//            {
//                RBC[i] = 0;
//                knot = BRightKnots[i];
//                RBC[i] = mu * (U[knot] - U[knot - NRight]) / (X[knot] - X[knot - NRight]) - 0.25 * rho_w * (U[knot] * U[knot] + V[knot] * V[knot]) * (1 - Math.Tanh(U[knot] / Ucp / delta));
//            }
//            RBC[0] = RBC[1];
//            RBC[NRight - 1] = RBC[NRight - 2];
//        }
//        //
//        //
//        /// <summary>
//        /// нахождение размерного касательного напряжения на дне
//        /// </summary>
//        void ShearStresses()
//        {
//            System.Object lockThis = new System.Object();
//            //
//            int IndexMethod = 0;// через ленту tau_l
//            IndexMethod = 2;// через ленту тензор TT
//            //IndexMethod = 1;// через конечные разности -  для сильновырожденной области не годится
//            try
//            {
//                if (IndexMethod == 2)
//                {
//                    //компоненты тензора напряжений
//                    double[] Tx1 = new double[BTriangles.Length];
//                    double[] Tx2 = new double[BTriangles.Length];
//                    double[] Ty1 = new double[BTriangles.Length];
//                    double[] Ty2 = new double[BTriangles.Length];
//                    //
//                    double[] tau_mid = new double[BTriangles.Length];
//                    //double e1x = 1, e1y = 0, e2x = 0, e2y = 1;//проекции
//                    //
//                    OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, BTriangles.Length);
//                    Parallel.ForEach(rangePartitioner,
//                           (range, loopState) =>
//                           {
//                               for (int i = range.Item1; i < range.Item2; i++)
//                               //for (int i = 0; i < BTriangles.Length; i++)
//                               {

//                                   double[] xL = new double[3];
//                                   double[] yL = new double[3];
//                                   //
//                                   int LcurV = BTriangles[i];
//                                   int[] Knots = Mesh.AreaElems[LcurV];
//                                   //
//                                   int Lnum1 = Knots[0];
//                                   int Lnum2 = Knots[1];
//                                   int Lnum3 = Knots[2];
//                                   // получаем координаты узлов элемента
//                                   xL[0] = X[Lnum1]; xL[1] = X[Lnum2]; xL[2] = X[Lnum3];
//                                   yL[0] = Y[Lnum1]; yL[1] = Y[Lnum2]; yL[2] = Y[Lnum3];
//                                   // нахождение площади треугольника
//                                   double LS = Sk[LcurV];
//                                   // скорости в вершинах треугольника
//                                   double LU1 = U[Lnum1];
//                                   double LU2 = U[Lnum2];
//                                   double LU3 = U[Lnum3];
//                                   //
//                                   double LV1 = V[Lnum1];
//                                   double LV2 = V[Lnum2];
//                                   double LV3 = V[Lnum3];
//                                   // производные в центре треугольника
//                                   double Ldu_dx = 1.0f / 2.0f / LS * (LU1 * (yL[1] - yL[2]) + LU2 * (yL[2] - yL[0]) + LU3 * (yL[0] - yL[1]));
//                                   double Ldu_dy = 1.0f / 2.0f / LS * (LU1 * (xL[2] - xL[1]) + LU2 * (xL[0] - xL[2]) + LU3 * (xL[1] - xL[0]));
//                                   double Ldv_dx = 1.0f / 2.0f / LS * (LV1 * (yL[1] - yL[2]) + LV2 * (yL[2] - yL[0]) + LV3 * (yL[0] - yL[1]));
//                                   double Ldv_dy = 1.0f / 2.0f / LS * (LV1 * (xL[2] - xL[1]) + LV2 * (xL[0] - xL[2]) + LV3 * (xL[1] - xL[0]));
//                                   // давление в центре треугольника
//                                   double LP_mid = (P[Lnum1] + P[Lnum2] + P[Lnum3]) / 3.0f;
//                                   // составляющие тензора напряжений
//                                   Tx1[i] = -LP_mid + 2.0f * mu * Ldu_dx;
//                                   Tx2[i] = mu * (Ldu_dy + Ldv_dx);
//                                   Ty1[i] = mu * (Ldu_dy + Ldv_dx);
//                                   Ty2[i] = -LP_mid + 2.0f * mu * Ldv_dy;
//                               }
//                           });
//                    // Вычисление tau в узлах сетки по сглаженной методике вычисления 
//                    //double[] Tau_all = Aproximate(tau_mid, CBottom, BTriangles);

//                    //вычисление тензора напряжений по сглаженной методике
//                    double[] Tx1_all = Aproximate(Tx1, CBottom, BTriangles);
//                    double[] Tx2_all = Aproximate(Tx2, CBottom, BTriangles);
//                    double[] Ty1_all = Aproximate(Ty1, CBottom, BTriangles);
//                    double[] Ty2_all = Aproximate(Ty2, CBottom, BTriangles);
//                    //подготовка приграничных значений tau между граничными точками и координат для сплайна
//                    int count = BBottomKnots.Length;
//                    BTau = new double[count];
//                    BTauС = new double[count];
//                    arg = new double[count - 1];
//                    int cKnot = BBottomKnots[0];
//                    double prevTx1 = 0, prevTx2 = 0, prevTy1 = 0, prevTy2 = 0;
//                    //
//                    for (int i = 0; i < BBottomKnots.Length; i++)
//                    {
//                        cKnot = BBottomKnots[i];
//                        for (int j = 0; j < CBottom.Length; j++)
//                        {
//                            if (cKnot == CBottom[j])
//                            {
//                                if (i != 0)
//                                {
//                                    int prevKnot = BBottomKnots[i - 1];
//                                    double delx = (X[cKnot] - X[prevKnot]);
//                                    double dely = (Y[cKnot] - Y[prevKnot]);
//                                    double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
//                                    // компоненты касательной между граничными точками
//                                    double lx = 1 / ss * delx;
//                                    double ly = 1 / ss * dely;
//                                    double nx = -ly;
//                                    double ny = lx;
//                                    //
//                                    double LsigX = (prevTx1 + Tx1_all[j]) / 2.0f * nx + (prevTx2 + Tx2_all[j]) / 2.0f * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
//                                    double LsigY = (prevTy1 + Ty1_all[j]) / 2.0f * nx + (prevTy2 + Ty2_all[j]) / 2.0f * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
//                                    //double LsigX = 2 * prevTx1 * Tx1_all[j] / (prevTx1 + Tx1_all[j]) * nx + 2 * prevTx2 * Tx2_all[j] / (prevTx2 + Tx2_all[j]) * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
//                                    //double LsigY = 2 * prevTy1 * Ty1_all[j] / (prevTy1 + Ty1_all[j]) * nx + 2 * prevTy2 * Ty2_all[j] / (prevTy2 + Ty2_all[j]) * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
//                                    //в полуцелых узлах
//                                    BTau[i - 1] = (LsigX * lx + LsigY * ly);
//                                    arg[i - 1] = X[prevKnot] + delx / 2.0f;
//                                    //
//                                    LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
//                                    LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
//                                    BTauС[i] = (LsigX * lx + LsigY * ly);

//                                }
//                                else
//                                {
//                                    int nextKnot = BBottomKnots[i + 1];
//                                    double delx = (X[nextKnot] - X[cKnot]);
//                                    double dely = (Y[nextKnot] - Y[cKnot]);
//                                    double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
//                                    // компоненты касательной между граничными точками
//                                    double lx = 1 / ss * delx;
//                                    double ly = 1 / ss * dely;
//                                    double nx = -ly;
//                                    double ny = lx;
//                                    //
//                                    double LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
//                                    double LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
//                                    BTauС[i] = (LsigX * lx + LsigY * ly);
//                                }
//                                //
//                                prevTx1 = Tx1_all[j];
//                                prevTx2 = Tx2_all[j];
//                                prevTy1 = Ty1_all[j];
//                                prevTy2 = Ty2_all[j];
//                                break;
//                            }
//                        }
//                    }
//                    BTau[count - 1] = BTau[count - 2];
//                    /////
//                    Tx1 = new double[TTriangles.Length];
//                    Tx2 = new double[TTriangles.Length];
//                    Ty1 = new double[TTriangles.Length];
//                    Ty2 = new double[TTriangles.Length];
//                    //
//                    tau_mid = new double[TTriangles.Length];
//                    //double e1x = 1, e1y = 0, e2x = 0, e2y = 1;//проекции
//                    //
//                    rangePartitioner = Partitioner.Create(0, TTriangles.Length);
//                    Parallel.ForEach(rangePartitioner,
//                           (range, loopState) =>
//                           {
//                               for (int i = range.Item1; i < range.Item2; i++)
//                               //for (int i = 0; i < BTriangles.Length; i++)
//                               {

//                                   double[] xL = new double[3];
//                                   double[] yL = new double[3];
//                                   //
//                                   int LcurV = TTriangles[i];
//                                   int[] Knots = Mesh.AreaElems[LcurV];
//                                   //
//                                   int Lnum1 = Knots[0];
//                                   int Lnum2 = Knots[1];
//                                   int Lnum3 = Knots[2];
//                                   // получаем координаты узлов элемента
//                                   xL[0] = X[Lnum1]; xL[1] = X[Lnum2]; xL[2] = X[Lnum3];
//                                   yL[0] = Y[Lnum1]; yL[1] = Y[Lnum2]; yL[2] = Y[Lnum3];
//                                   // нахождение площади треугольника
//                                   double LS = Sk[LcurV];
//                                   // скорости в вершинах треугольника
//                                   double LU1 = U[Lnum1];
//                                   double LU2 = U[Lnum2];
//                                   double LU3 = U[Lnum3];
//                                   //
//                                   double LV1 = V[Lnum1];
//                                   double LV2 = V[Lnum2];
//                                   double LV3 = V[Lnum3];
//                                   // производные в центре треугольника
//                                   double Ldu_dx = 1.0f / 2.0f / LS * (LU1 * (yL[1] - yL[2]) + LU2 * (yL[2] - yL[0]) + LU3 * (yL[0] - yL[1]));
//                                   double Ldu_dy = 1.0f / 2.0f / LS * (LU1 * (xL[2] - xL[1]) + LU2 * (xL[0] - xL[2]) + LU3 * (xL[1] - xL[0]));
//                                   double Ldv_dx = 1.0f / 2.0f / LS * (LV1 * (yL[1] - yL[2]) + LV2 * (yL[2] - yL[0]) + LV3 * (yL[0] - yL[1]));
//                                   double Ldv_dy = 1.0f / 2.0f / LS * (LV1 * (xL[2] - xL[1]) + LV2 * (xL[0] - xL[2]) + LV3 * (xL[1] - xL[0]));
//                                   // давление в центре треугольника
//                                   double LP_mid = (P[Lnum1] + P[Lnum2] + P[Lnum3]) / 3.0f;
//                                   // составляющие тензора напряжений
//                                   Tx1[i] = -LP_mid + 2.0f * mu * Ldu_dx;
//                                   Tx2[i] = mu * (Ldu_dy + Ldv_dx);
//                                   Ty1[i] = mu * (Ldu_dy + Ldv_dx);
//                                   Ty2[i] = -LP_mid + 2.0f * mu * Ldv_dy;
//                               }
//                           });
//                    // Вычисление tau в узлах сетки по сглаженной методике вычисления 
//                    //double[] Tau_all = Aproximate(tau_mid, CBottom, BTriangles);

//                    //вычисление тензора напряжений по сглаженной методике
//                    Tx1_all = Aproximate(Tx1, CTop, TTriangles);
//                    Tx2_all = Aproximate(Tx2, CTop, TTriangles);
//                    Ty1_all = Aproximate(Ty1, CTop, TTriangles);
//                    Ty2_all = Aproximate(Ty2, CTop, TTriangles);
//                    //подготовка приграничных значений tau между граничными точками и координат для сплайна
//                    count = BTopKnots.Length;
//                    TTau = new double[count];
//                    TTauС = new double[count];
//                    argT = new double[count - 1];
//                    cKnot = BTopKnots[0];
//                    prevTx1 = 0; prevTx2 = 0; prevTy1 = 0; prevTy2 = 0;
//                    //
//                    for (int i = 0; i < BTopKnots.Length; i++)
//                    {
//                        cKnot = BTopKnots[i];
//                        for (int j = 0; j < CTop.Length; j++)
//                        {
//                            if (cKnot == CTop[j])
//                            {
//                                if (i != 0)
//                                {
//                                    int prevKnot = BTopKnots[i - 1];
//                                    double delx = (X[cKnot] - X[prevKnot]);
//                                    double dely = (Y[cKnot] - Y[prevKnot]);
//                                    double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
//                                    // компоненты касательной между граничными точками
//                                    double lx = 1 / ss * delx;
//                                    double ly = 1 / ss * dely;
//                                    double nx = -ly;
//                                    double ny = lx;
//                                    //
//                                    double LsigX = (prevTx1 + Tx1_all[j]) / 2.0f * nx + (prevTx2 + Tx2_all[j]) / 2.0f * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
//                                    double LsigY = (prevTy1 + Ty1_all[j]) / 2.0f * nx + (prevTy2 + Ty2_all[j]) / 2.0f * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
//                                    //в полуцелых узлах
//                                    TTau[i - 1] = (LsigX * lx + LsigY * ly);
//                                    argT[i - 1] = X[prevKnot] + delx / 2.0f;
//                                    //
//                                    LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
//                                    LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
//                                    TTauС[i] = (LsigX * lx + LsigY * ly);

//                                }
//                                else
//                                {
//                                    int nextKnot = BTopKnots[i + 1];
//                                    double delx = (X[nextKnot] - X[cKnot]);
//                                    double dely = (Y[nextKnot] - Y[cKnot]);
//                                    double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
//                                    // компоненты касательной между граничными точками
//                                    double lx = 1 / ss * delx;
//                                    double ly = 1 / ss * dely;
//                                    double nx = -ly;
//                                    double ny = lx;
//                                    //
//                                    double LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
//                                    double LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
//                                    TTauС[i] = (LsigX * lx + LsigY * ly);
//                                }
//                                //
//                                prevTx1 = Tx1_all[j];
//                                prevTx2 = Tx2_all[j];
//                                prevTy1 = Ty1_all[j];
//                                prevTy2 = Ty2_all[j];
//                                break;
//                            }
//                        }
//                    }
//                    TTau[count - 1] = TTau[count - 2];

//                }
//                if (IndexMethod == 0) //!!!-- 1 ый порядок точности, для Tau в целых и полуцелых узлах надо использовать через сплайн!
//                {
//                    //
//                    double[] tau_mid = new double[BTriangles.Length];
//                    //
//                    OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, BTriangles.Length);
//                    Parallel.ForEach(rangePartitioner,
//                           (range, loopState) =>
//                           {
//                               for (int i = range.Item1; i < range.Item2; i++)
//                               //for (int i = 0; i < BTriangles.Length; i++)
//                               {

//                                   double[] xL = new double[3];
//                                   double[] yL = new double[3];
//                                   //
//                                   int LcurV = BTriangles[i];
//                                   int[] Knots = Mesh.AreaElems[LcurV];
//                                   //
//                                   int Lnum1 = Knots[0];
//                                   int Lnum2 = Knots[1];
//                                   int Lnum3 = Knots[2];
//                                   // получаем координаты узлов элемента
//                                   xL[0] = X[Lnum1]; xL[1] = X[Lnum2]; xL[2] = X[Lnum3];
//                                   yL[0] = Y[Lnum1]; yL[1] = Y[Lnum2]; yL[2] = Y[Lnum3];
//                                   // нахождение площади треугольника
//                                   double LS = Sk[LcurV];
//                                   // скорости в вершинах треугольника
//                                   double LU1 = U[Lnum1];
//                                   double LU2 = U[Lnum2];
//                                   double LU3 = U[Lnum3];
//                                   //
//                                   double LV1 = V[Lnum1];
//                                   double LV2 = V[Lnum2];
//                                   double LV3 = V[Lnum3];
//                                   // касательный вектор (обход против часовой стрелки)
//                                   double Lsx = Sx[i];
//                                   double Lsy = Sy[i];
//                                   // нормаль (направлена во внутрь КО)
//                                   double Lnx = -Lsy;
//                                   double Lny = Lsx;
//                                   // производные в центре треугольника
//                                   double Ldu_dx = 1.0f / 2.0f / LS * (LU1 * (yL[1] - yL[2]) + LU2 * (yL[2] - yL[0]) + LU3 * (yL[0] - yL[1]));
//                                   double Ldu_dy = 1.0f / 2.0f / LS * (LU1 * (xL[2] - xL[1]) + LU2 * (xL[0] - xL[2]) + LU3 * (xL[1] - xL[0]));
//                                   double Ldv_dx = 1.0f / 2.0f / LS * (LV1 * (yL[1] - yL[2]) + LV2 * (yL[2] - yL[0]) + LV3 * (yL[0] - yL[1]));
//                                   double Ldv_dy = 1.0f / 2.0f / LS * (LV1 * (xL[2] - xL[1]) + LV2 * (xL[0] - xL[2]) + LV3 * (xL[1] - xL[0]));
//                                   // давление в центре треугольника
//                                   double LP_mid = (P[Lnum1] + P[Lnum2] + P[Lnum3]) / 3.0f;
//                                   // составляющие тензора напряжений
//                                   double Tx1 = -LP_mid + 2.0f * mu * Ldu_dx;
//                                   double Tx2 = mu * (Ldu_dy + Ldv_dx);
//                                   double Ty1 = mu * (Ldu_dy + Ldv_dx);
//                                   double Ty2 = -LP_mid + 2.0f * mu * Ldv_dy;
//                                   // компоненты вектора придонного напряжения
//                                   double LsigX = Tx1 * Lnx + Tx2 * Lny;
//                                   double LsigY = Ty1 * Lnx + Ty2 * Lny;
//                                   //
//                                   tau_mid[i] = (LsigX * Lsx + LsigY * Lsy);
//                               }
//                           });

//                    // Вычисление tau в узлах сетки по сглаженной методике вычисления 
//                    double[] Tau_all = Aproximate(tau_mid, CBottom, BTriangles);
//                    //
//                    //подготовка приграничных значений tau между граничными точками и координат для сплайна
//                    int count = BBottomKnots.Length;
//                    BTau = new double[count];
//                    arg = new double[count];
//                    int cKnot;
//                    //
//                    for (int i = 0; i < BBottomKnots.Length; i++)
//                    {
//                        cKnot = BBottomKnots[i];
//                        for (int j = 0; j < CBottom.Length; j++)
//                        {
//                            if (cKnot == CBottom[j])
//                            {

//                                BTau[i] = Tau_all[j];
//                                arg[i] = X[cKnot]; // аргумент - только X (чтобы легче проецировать на дно)
//                                //arg[i] = Math.Sqrt(X[cKnot] * X[cKnot] + Y[cKnot] * Y[cKnot]);
//                                break;
//                            }
//                        }
//                    }
//                }
//                //
//                if (IndexMethod == 1)//!!!-- 1 ый порядок точности, для Tau в целых и полуцелых узлах надо использовать через сплайн!
//                {
//                    //подготовка приграничных значений tau между граничными точками и координат для сплайна
//                    arg = new double[BBottomKnots.Length];
//                    //
//                    OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(1, BBottomKnots.Length - 1);
//                    Parallel.ForEach(rangePartitioner,
//                           (range, loopState) =>
//                           {
//                               for (int i = range.Item1; i < range.Item2; i++)
//                               //for (int i = 1; i < BBottomKnots.Length - 1; i++)
//                               {
//                                   //
//                                   //           nnK(2)
//                                   //            |
//                                   //           nK(1)
//                                   //            |
//                                   //--wK(3)---cKnot(0)---eK(4)
//                                   int cKnot = BBottomKnots[i];
//                                   int wK = BBottomKnots[i - 1];
//                                   int eK = BBottomKnots[i + 1];
//                                   int nK = 0, nnK = 0;
//                                   double delx = (X[eK] - X[wK]);
//                                   double dely = (Y[eK] - Y[wK]);
//                                   double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
//                                   // компоненты касательной между граничными точками
//                                   double lx = 1 / ss * delx;
//                                   double ly = 1 / ss * dely;
//                                   //нормаль к поверхности между узлами wK и eK
//                                   double nx = -ly;
//                                   double ny = lx;
//                                   //
//                                   double Ldu_dx = 0;
//                                   double Ldu_dy = 0;
//                                   double Ldv_dx = 0;
//                                   double Ldv_dy = 0;
//                                   double P_c = 0;
//                                   //если дно почти горизонтальное, то считаем, что оно горизонтальное
//                                   if (lx > 0.98)
//                                   {
//                                       nK = cKnot + 1;
//                                       nnK = cKnot + 2;
//                                       //x - это y(координата), y - это U (функция)
//                                       double x0 = Y[cKnot];
//                                       double y0 = U[cKnot];
//                                       double x1 = Y[nK];
//                                       double y1 = U[nK];
//                                       double x2 = Y[nnK];
//                                       double y2 = U[nnK];
//                                       Ldu_dy = 1.0f / (x0 - x1) * y0 + 1.0f / (x0 - x2) * y0 + 1.0f / (x1 - x0) * (x0 - x2) / (x1 - x2) * y1 + 1.0f / (x2 - x0) * (x0 - x1) / (x2 - x1) * y2;
//                                       //функция V - это y
//                                       y0 = V[cKnot];
//                                       y1 = V[nK];
//                                       y2 = V[nnK];
//                                       Ldv_dy = 1.0f / (x0 - x1) * y0 + 1.0f / (x0 - x2) * y0 + 1.0f / (x1 - x0) * (x0 - x2) / (x1 - x2) * y1 + 1.0f / (x2 - x0) * (x0 - x1) / (x2 - x1) * y2;
//                                       Ldv_dx = 0;
//                                       Ldu_dx = 0;
//                                   }
//                                   // если дно не горизонтальное
//                                   else
//                                   {

//                                       double k = dy;
//                                       FPoint[] PointsNorm = new FPoint[2];
//                                       FPoint[] PointsTang = new FPoint[2];
//                                       double[] U12 = new double[2]; double[] V12 = new double[2];
//                                       double[] U34 = new double[2]; double[] V34 = new double[2];
//                                       //
//                                       for (int j = 0; j < 2; j++)
//                                       {
//                                           //точка на расстоянии k по направлению нормали
//                                           PointsNorm[j] = new FPoint(X[cKnot] + nx * k * (j + 1), Y[cKnot] + ny * k * (j + 1));
//                                           //
//                                           int Triangle = Mesh.GetTriangle(PointsNorm[j].X, PointsNorm[j].Y);
//                                           //
//                                           double s05 = 1.0f / 2.0f / Sk[Triangle];
//                                           int[] Knots = Mesh.AreaElems[Triangle];
//                                           double x1 = X[Knots[0]]; double x2 = X[Knots[1]]; double x3 = X[Knots[2]];
//                                           double y1 = Y[Knots[0]]; double y2 = Y[Knots[1]]; double y3 = Y[Knots[2]];
//                                           double L1 = s05 * ((x2 * y3 - x3 * y2) + PointsNorm[j].X * (y2 - y3) + PointsNorm[j].Y * (x3 - x2));
//                                           double L2 = s05 * ((x3 * y1 - x1 * y3) + PointsNorm[j].X * (y3 - y1) + PointsNorm[j].Y * (x1 - x3));
//                                           double L3 = s05 * ((x1 * y2 - x2 * y1) + PointsNorm[j].X * (y1 - y2) + PointsNorm[j].Y * (x2 - x1));
//                                           //
//                                           U12[j] = L1 * U[Knots[0]] + L2 * U[Knots[1]] + L3 * U[Knots[2]];
//                                           V12[j] = L1 * V[Knots[0]] + L2 * V[Knots[1]] + L3 * V[Knots[2]];
//                                       }
//                                       //аппроксимация по 4 точкам
//                                       //double dPhids = (2 * PhiNormal[0] - 5 * PhiNormal[1] + 4 * PhiNormal[2] - PhiNormal[3]) / k / k;
//                                       //аппрроксимация по трем точкам
//                                       Ldu_dy = (-7 * U[cKnot] + 8 * U12[0] - U12[1]) / k / k / 2.0f;
//                                       Ldv_dy = (-7 * V[cKnot] + 8 * V12[0] - V12[1]) / k / k / 2.0f;
//                                       //
//                                       //точка на расстоянии k по обоим направлениям по касательной от точки cKnot
//                                       PointsTang[0] = new FPoint(X[cKnot] - lx * k, Y[cKnot] - ly * k);
//                                       PointsTang[1] = new FPoint(X[cKnot] + lx * k, Y[cKnot] + ly * k);
//                                       //
//                                       for (int j = 0; j < 2; j++)
//                                       {
//                                           int Triangle = Mesh.GetTriangle(PointsTang[j].X, PointsTang[j].Y);
//                                           //если область вогнутая, то хотя бы одна точка вдоль касательной бдует лежать вне области
//                                           // здесь в таком случае влияние производных U и V  вдоль касательной не учитываем
//                                           if (Triangle == -1)
//                                           {
//                                               U34[0] = 0; U34[1] = 0;
//                                               V34[0] = 0; V34[1] = 0;
//                                               break;
//                                           }
//                                           //
//                                           double s05 = 1.0f / 2.0f / Sk[Triangle];
//                                           int[] Knots = Mesh.AreaElems[Triangle];
//                                           double x1 = X[Knots[0]]; double x2 = X[Knots[1]]; double x3 = X[Knots[2]];
//                                           double y1 = Y[Knots[0]]; double y2 = Y[Knots[1]]; double y3 = Y[Knots[2]];
//                                           double L1 = s05 * ((x2 * y3 - x3 * y2) + PointsNorm[j].X * (y2 - y3) + PointsNorm[j].Y * (x3 - x2));
//                                           double L2 = s05 * ((x3 * y1 - x1 * y3) + PointsNorm[j].X * (y3 - y1) + PointsNorm[j].Y * (x1 - x3));
//                                           double L3 = s05 * ((x1 * y2 - x2 * y1) + PointsNorm[j].X * (y1 - y2) + PointsNorm[j].Y * (x2 - x1));
//                                           //
//                                           U34[j] = L1 * U[Knots[0]] + L2 * U[Knots[1]] + L3 * U[Knots[2]];
//                                           V34[j] = L1 * V[Knots[0]] + L2 * V[Knots[1]] + L3 * V[Knots[2]];

//                                       }
//                                       Ldu_dx = (U34[1] - U34[0]) / k / 2.0f;
//                                       Ldv_dx = (V34[1] - V34[0]) / k / 2.0f;

//                                   }
//                                   //
//                                   // давление в узле
//                                   P_c = P[cKnot];
//                                   // составляющие тензора напряжений
//                                   double Tx1 = -P_c + 2.0f * mu * Ldu_dx;
//                                   double Tx2 = mu * (Ldu_dy + Ldv_dx);
//                                   double Ty1 = mu * (Ldu_dy + Ldv_dx);
//                                   double Ty2 = -P_c + 2.0f * mu * Ldv_dy;
//                                   // компоненты вектора придонного напряжения
//                                   double LsigX = Tx1 * nx + Tx2 * ny;
//                                   double LsigY = Ty1 * nx + Ty2 * ny;
//                                   // проекция вектора придонного напряжения на касательный вектор
//                                   BTau[i] = (LsigX * lx + LsigY * ly);
//                                   arg[i] = X[cKnot];

//                                   //1/(x0-x1)*y0+1/(x0-x2)*y0+1/(x1-x0)*(x0-x2)/(x1-x2)*y1+1/(x2-x0)*(x0-x1)/(x2-x1)*y2

//                               }
//                           });
//                    //
//                }
//            }
//            catch (Exception e)
//            {
//                err = e.Message + "ShearStressesCalculation";
//            }

//        }
//        void ShearStress(int[] BBottomKnots, int[] CBottom, int[] BTriangles, out double[] BTau, out double[] BTauC, out double[] arg)
//        {
//            //
//            BTauC = new double[BBottomKnots.Length];
//            BTau = new double[BBottomKnots.Length];
//            arg = new double[BBottomKnots.Length - 1];
//            int count = BBottomKnots.Length;
//            //
//            double[] Tx1 = new double[BTriangles.Length];
//            double[] Tx2 = new double[BTriangles.Length];
//            double[] Ty1 = new double[BTriangles.Length];
//            double[] Ty2 = new double[BTriangles.Length];
//            //
//            double[] tau_mid = new double[BTriangles.Length];
//            //double e1x = 1, e1y = 0, e2x = 0, e2y = 1;//проекции
//            //
//            OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, BTriangles.Length);
//            Parallel.ForEach(rangePartitioner,
//                    (range, loopState) =>
//                    {
//                        for (int i = range.Item1; i < range.Item2; i++)
//                        //for (int i = 0; i < BTriangles.Length; i++)
//                        {

//                            double[] xL = new double[3];
//                            double[] yL = new double[3];
//                            //
//                            int LcurV = BTriangles[i];
//                            int[] Knots = Mesh.AreaElems[LcurV];
//                            //
//                            int Lnum1 = Knots[0];
//                            int Lnum2 = Knots[1];
//                            int Lnum3 = Knots[2];
//                            // получаем координаты узлов элемента
//                            xL[0] = X[Lnum1]; xL[1] = X[Lnum2]; xL[2] = X[Lnum3];
//                            yL[0] = Y[Lnum1]; yL[1] = Y[Lnum2]; yL[2] = Y[Lnum3];
//                            // нахождение площади треугольника
//                            double LS = Sk[LcurV];
//                            // скорости в вершинах треугольника
//                            double LU1 = U[Lnum1];
//                            double LU2 = U[Lnum2];
//                            double LU3 = U[Lnum3];
//                            //
//                            double LV1 = V[Lnum1];
//                            double LV2 = V[Lnum2];
//                            double LV3 = V[Lnum3];
//                            // производные в центре треугольника
//                            double Ldu_dx = 1.0f / 2.0f / LS * (LU1 * (yL[1] - yL[2]) + LU2 * (yL[2] - yL[0]) + LU3 * (yL[0] - yL[1]));
//                            double Ldu_dy = 1.0f / 2.0f / LS * (LU1 * (xL[2] - xL[1]) + LU2 * (xL[0] - xL[2]) + LU3 * (xL[1] - xL[0]));
//                            double Ldv_dx = 1.0f / 2.0f / LS * (LV1 * (yL[1] - yL[2]) + LV2 * (yL[2] - yL[0]) + LV3 * (yL[0] - yL[1]));
//                            double Ldv_dy = 1.0f / 2.0f / LS * (LV1 * (xL[2] - xL[1]) + LV2 * (xL[0] - xL[2]) + LV3 * (xL[1] - xL[0]));
//                            // давление в центре треугольника
//                            double LP_mid = (P[Lnum1] + P[Lnum2] + P[Lnum3]) / 3.0f;
//                            // составляющие тензора напряжений
//                            Tx1[i] = -LP_mid + 2.0f * mu * Ldu_dx;
//                            Tx2[i] = mu * (Ldu_dy + Ldv_dx);
//                            Ty1[i] = mu * (Ldu_dy + Ldv_dx);
//                            Ty2[i] = -LP_mid + 2.0f * mu * Ldv_dy;
//                        }
//                    });
//            // Вычисление tau в узлах сетки по сглаженной методике вычисления 
//            //double[] Tau_all = Aproximate(tau_mid, CBottom, BTriangles);

//            //вычисление тензора напряжений по сглаженной методике
//            double[] Tx1_all = Aproximate(Tx1, CBottom, BTriangles);
//            double[] Tx2_all = Aproximate(Tx2, CBottom, BTriangles);
//            double[] Ty1_all = Aproximate(Ty1, CBottom, BTriangles);
//            double[] Ty2_all = Aproximate(Ty2, CBottom, BTriangles);
//            //подготовка приграничных значений tau между граничными точками и координат для сплайна

//            int cKnot = BBottomKnots[0];
//            double prevTx1 = 0, prevTx2 = 0, prevTy1 = 0, prevTy2 = 0;
//            //
//            for (int i = 0; i < BBottomKnots.Length; i++)
//            {
//                cKnot = BBottomKnots[i];
//                for (int j = 0; j < CBottom.Length; j++)
//                {
//                    if (cKnot == CBottom[j])
//                    {
//                        if (i != 0)
//                        {
//                            int prevKnot = BBottomKnots[i - 1];
//                            double delx = (X[cKnot] - X[prevKnot]);
//                            double dely = (Y[cKnot] - Y[prevKnot]);
//                            double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
//                            // компоненты касательной между граничными точками
//                            double lx = 1 / ss * delx;
//                            double ly = 1 / ss * dely;
//                            double nx = -ly;
//                            double ny = lx;
//                            //
//                            double LsigX = (prevTx1 + Tx1_all[j]) / 2.0f * nx + (prevTx2 + Tx2_all[j]) / 2.0f * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
//                            double LsigY = (prevTy1 + Ty1_all[j]) / 2.0f * nx + (prevTy2 + Ty2_all[j]) / 2.0f * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
//                            //в полуцелых узлах
//                            BTau[i - 1] = (LsigX * lx + LsigY * ly);
//                            arg[i - 1] = X[prevKnot] + delx / 2.0f;
//                            //
//                            LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
//                            LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
//                            BTauС[i] = (LsigX * lx + LsigY * ly);

//                        }
//                        else
//                        {
//                            int nextKnot = BBottomKnots[i + 1];
//                            double delx = (X[nextKnot] - X[cKnot]);
//                            double dely = (Y[nextKnot] - Y[cKnot]);
//                            double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
//                            // компоненты касательной между граничными точками
//                            double lx = 1 / ss * delx;
//                            double ly = 1 / ss * dely;
//                            double nx = -ly;
//                            double ny = lx;
//                            //
//                            double LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
//                            double LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
//                            BTauС[i] = (LsigX * lx + LsigY * ly);
//                        }
//                        //
//                        prevTx1 = Tx1_all[j];
//                        prevTx2 = Tx2_all[j];
//                        prevTy1 = Ty1_all[j];
//                        prevTy2 = Ty2_all[j];
//                        break;
//                    }
//                }
//            }
//            BTau[count - 1] = BTau[count - 2];
//        }
//        double[] Aproximate(double[] MiddleFunction, int[] GLKnots, int[] GTriangs)
//        {
//            int Count = GLKnots.Length;
//            //
//            double[] ExactFunc = new double[Count];
//            //
//            double[][] Matrix = new double[3][];
//            for (int i = 0; i < 3; i++)
//                Matrix[i] = new double[3];
//            //
//            try
//            {
//                SBand AlgB = new SBand();
//                AlgB.SetSystem(Count, BWidth);
//                // Вычисляем локальные матрицы жесткости и производим сборку глобальной матрицы жесткости
//                int tr = 0;
//                int[] GKnots, LKnots = new int[3];
//                double S = 0; ;
//                for (int k = 0; k < GTriangs.Length; k++)
//                {
//                    tr = GTriangs[k];
//                    S = Sk[tr];
//                    //S = Mesh.GetSquare(tr);
//                    //переходим к локальной нумерации для СЛАУ
//                    GKnots = Mesh.AreaElems[tr];
//                    for (int i = 0; i < 3; i++)
//                    {
//                        for (int j = 0; j < Count; j++)
//                        {
//                            if (GKnots[i] == GLKnots[j])
//                            {
//                                LKnots[i] = j;
//                                break;
//                            }
//                        }
//                    }
//                    //
//                    // Вычисляем локальную матрицу жесткости 
//                    // Расчет локальной матрицы жесткости для диффузионного члена
//                    Matrix[0][0] = 1.0 / 6.0 * S;
//                    Matrix[0][1] = 1.0 / 12.0 * S;
//                    Matrix[0][2] = 1.0 / 12.0 * S;

//                    Matrix[1][0] = 1.0 / 12.0 * S;
//                    Matrix[1][1] = 1.0 / 6.0 * S;
//                    Matrix[1][2] = 1.0 / 12.0 * S;

//                    Matrix[2][0] = 1.0 / 12.0 * S;
//                    Matrix[2][1] = 1.0 / 12.0 * S;
//                    Matrix[2][2] = 1.0 / 6.0 * S;
//                    // Формирование глобальной матрицы жесткости
//                    AlgB.BuildMatrix(Matrix, LKnots);
//                    //Mesh.SaveMesh("nn");
//                    //
//                    double[] tmpU = { MiddleFunction[k] * S / 3.0f, MiddleFunction[k] * S / 3.0f, MiddleFunction[k] * S / 3.0f };
//                    //
//                    AlgB.BuildRight(tmpU, LKnots);
//                }
//                // Решение системы алгебраических уравнений
//                AlgGauss.Solve(AlgB);
//                ExactFunc = AlgB.GetX;
//            }
//            catch (Exception e)
//            {
//                err = e.Message + "Aproximate fell down";
//            }
//            return ExactFunc;
//        }
//        /// <summary>
//        /// метод расчета L2 погрешности (используя метод трапеций)
//        /// </summary>
//        /// <param name="Exact">Точное решение</param>
//        /// <param name="Calc">Расчетное решение</param>
//        /// <param name="dx"></param>
//        /// <returns></returns>
//        public double[] L2_discrepancy(double[] Exact, double[] Calc, double dx)
//        {
//            int N = Exact.Length;
//            double[] L2 = new double[N];
//            //
//            double intE = 0, intC = 0;
//            for (int i = 0; i < N - 1; i++)
//            {
//                intE = (Exact[i] + Exact[i + 1]) / 2.0 * dx;
//                intC = (Calc[i] + Calc[i + 1]) / 2.0 * dx;
//                L2[i] = Math.Sqrt((intE - intC) * (intE - intC)) * 100;
//            }
//            // фронтальная нумерация между верхей и нижней границей интеграл не высчитывается
//            for (int i = 0; i < NTop; i++)
//                L2[Mesh.TopKnots[i]] = 0;
//            //
//            return L2;
//        }
//    }
//    public class FPoint
//    {
//        public double X;
//        public double Y;
//        public FPoint(double x, double y)
//        {
//            X = x; Y = y;
//        }
//    }
//}
