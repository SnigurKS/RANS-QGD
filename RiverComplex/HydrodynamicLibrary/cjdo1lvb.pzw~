using AlgebraLibrary;
using MeshLibrary;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Cloo;
using System.IO;

namespace HydrodynamicLibrary
{
    [Serializable]
    public class WaterTaskEliz
    {
        #region Искомые величины и объекты для работы
        public bool SerializeNow = false;
        public string status = "Running";
        public string err = "ok";
        public int Iter = 0;
        int beginIter = 0;
        //
        public double[] U = null;
        public double[] V = null;
        public double[] P = null;
        public double[] ErrP = null;
        public double[] S = null;
        public double[] K = null;
        public double[] E = null;
        public double[] nuT = null;
        public double[] rightK = null;
        public double[] rightE = null;
        public double[] ReT = null;
        double[] buffP = null;
        double[] buffU = null;
        double[] buffV = null;
        double[] buffS = null;
        double[] buffK = null;
        double[] buffE = null;
        double[] buffNu = null;
        /// <summary>
        /// напряжение на дне в полуцелый узлах
        /// </summary>
        public double[] BTau = null;
        /// <summary>
        /// напряжение на дне в целых узлах
        /// </summary>
        public double[] BTauC = null;
        public double[] arg = null;//аргумент к BTau для сплайна
        /// <summary>
        /// напряжение на верхней стенке в полуцелых узлах
        /// </summary>
        public double[] TTau = null;
        /// <summary>
        ///  напряжение на верхней стенке в целых узлах
        /// </summary>
        public double[] TTauC = null;
        public double[] argT = null;
        //
        /// <summary>
        /// максимальная горизонтальная скорость
        /// </summary>
        double U_max = 0;
        /// <summary>
        /// Рейнольдс x = U*H/nu
        /// </summary>
        double Re = 1;
        //
        double rho_w = 1000;
        /// <summary>
        /// штраф неразрывности в давлении
        /// </summary>
        double alpha_n = 0.5f;
        /// <summary>
        /// штраф регуляризационной части в давлении
        /// </summary>
        double alpha_r = 0.5f;
        /// <summary>
        /// штраф фиктивного источника на правой границе
        /// </summary>
        double alpha_p = 0.5f;
        //
        //для контроля потери массы
        //перемнные для баланса массы на входе и выходе
        double Q_in = 0;
        double Q_out = 0;
        //
        public double Get_Q_in
        {
            get {
                if (Q_in == 0)
                {
                    if (U != null)
                    {
                        for (int k = 0; k < NLeft - 1; k++)
                        {
                            int a = BLeftKnots[k];
                            int b = BLeftKnots[k + 1];
                            Q_in += (U[a] + U[b]) * 0.5f * Math.Abs(Y[a] - Y[b]);
                        }
                    }
                }
                return Q_in;
                
            }
        }
        //
        public double Get_Q_out
        {
            get
            {
                if (Q_out == 0)
                {
                    if (U != null)
                    {
                        for (int k = 1; k < NRight - 1; k++)
                        {
                            int a = BRightKnots[k];
                            int b = BRightKnots[k + 1];
                            Q_out += (U[a] + U[b]) * 0.5f * Math.Abs(Y[a] - Y[b]);
                        }
                    }
                }
                return Q_out;
            }
        }
        /// <summary>
        /// ширина ленты
        /// </summary>
        public int BWidth = 0;
        // 
        /// <summary>
        /// лист связности центрального узла CV[i][0] и окружающих его элементов (треугольников) CV[i][1..7]
        /// </summary>
        int[][] CV = null;
        /// <summary>
        /// Лист связности внутренних КО, за исключением граничных узлов и узлов, где ставится WallFunc
        /// </summary>
        int[][] CV2 = null;
        /// <summary>
        /// Лист связности КО, где ставится WallFunc (ближайшие узлы к границе)
        /// </summary>
        int[][] CV_WallKnots = null;
        /// <summary>
        /// расстояние от пристеночного узла до дна по нормали
        /// </summary>
        double[] CV_WallKnotsDistance = null;
        /// <summary>
        /// Напряжение по пристеночной функции в пристеночных узлах
        /// </summary>
        double[] CV_WallTau = null;
        /// <summary>
        /// упрощеная версия хранения граничных треугольников у дна
        /// </summary>
        int[] BTriangles = null;
        /// <summary>
        /// массив связности окружающих дно точек в глобальной и локальной нумерации
        /// </summary>
        int[] CBottom = null;
        /// <summary>
        /// упрощеная версия хранения граничных треугольников у своб. пов.
        /// </summary>
        int[] TTriangles = null;
        /// <summary>
        /// массив связности окружающих своб пов. точек в глобальной и локальной нумерации
        /// </summary>
        int[] CTop = null;
        /// <summary>
        /// массив - [] граничная точка на правой стенке, [] вершины треугольников, создающих грань с этой точкой, но не лежащие на нранице
        /// </summary>
        int[][] RightKnotsList = null;
        int[][] TopKnotsList = null;
        //
        double[] BWallDistance = null, TWallDistance = null;
        /// <summary>
        /// генератор КЭ сетки для тестовой задачи
        /// </summary>
        public Mesh Mesh;
        /// <summary>
        /// решатель алгебраической задачи
        /// </summary>
        public SBand ABand = null;
        public SSystem Sys = null;
          /// <summary>
        /// секундомер
        /// </summary>
        [NonSerialized]
        Stopwatch stopCopy = null, stopCalc = null;
        [NonSerialized]
        public TimeSpan timeSpanCalc;
        [NonSerialized]
        public TimeSpan timeSpanArrays = new TimeSpan();
        [NonSerialized]
        public TimeSpan timeSpanCopy = new TimeSpan();
        //
        int remainTimeMin;
        //
        #endregion
        //
        double[] X = null, Y = null;
        int iter = 1;
        double dt = 0.0001f;
        double tau = 0.01f;
        double Q = 0;
        public double dPdx = 0;
        [NonSerialized]
        double delta = 0.05;
        double relaxP = 0.1f;

        [NonSerialized]
        double[] U_start, V_start, K_start, E_start, NuT_start, S_start = null;
        [NonSerialized]
        double dpdx_start;

        double mu = 0;
        double nu_mol = 0;
        public int CountKnots = 0, CountTriangles = 0;
        public double Ucp = 0;// значение средней скорости по суммированию профиля
        double errP = 0.001f; // пмаксимальная допустимая погршность по давлению
        //
        double W = 0.01;
        double rho_s = 2650;
        double g = 9.8;
        double d = 0.00016;
        double kappa = 0.4;//0.4327;
        double J = 0.00132;
        double SinJ = 0, CosJ = 0;
        double tmp = 0;
        double sigma_s = 1;
        double sigma_k = 1;
        double sigma_e = 1.3;
        double C_e1 = 1.44;
        double C_e2 = 1.92;
        public double C_m = 0.09;
        double cm14 = 0;
        double y_p_0 = 11.5;
        //
        AlgorythmGauss AlgGauss = new AlgorythmGauss();
        Algorythm Alg = null;
        //
        public int _Nx = 0, _Ny = 0;
        double dy = 0;
        //
        int NBottom = 0;
        int NLeft = 0;
        int NRight = 0;
        int NTop = 0;
        //
        int[] BLeftKnots = null;
        int[] BRightKnots = null;
        int[] BBottomKnots = null;
        int[] BTopKnots = null;
        //
        double[] RBC = null;
        double[] BV = null;
        bool surf_flag = false;
        bool flag = true;
        double[] R = null;
        //
        double[] Sk = null;
        double[] b1 = null, b2 = null, b3 = null;
        double[] c1 = null, c2 = null, c3 = null;
        double[][] Lx10 = null;
        double[][] Lx32 = null;
        double[][] Ly01 = null;
        double[][] Ly23 = null;
        double[][] Alpha = null;
        double[][] SS = null;
        double[] S0 = null;
        double[][] _Lk = null;
        int[][] P1 = null;
        double[][] Nx = null;
        double[][] Ny = null;
        double[] Sx, Sy;
        [NonSerialized]
        alglib.spline1dinterpolant bufF; 
        //
        //[NonSerialized]
        //public double[] ConvK, ConvE, DiffK, DiffE, RegK, RegE;
        [NonSerialized]
        public double[] Tau = null;

        [NonSerialized]
        public double[] Pk = null;
        //
        [NonSerialized]
        bool RecalcFlag = false;
        //
        [NonSerialized]
        public double[] y_plus;
        //
        [NonSerialized]
        bool flag_Cuda = true, flag_OpenCL = false;
        public bool ContinueToCalc
        {
            set { RecalcFlag = value; }
        }
        //
        [NonSerialized]
        OrderablePartitioner<Tuple<int, int>> OrdPart_CountKnots, OrdPart_CV, OrdPart_CV2, OrdPart_CV_Wall, OP_CountElems;
        public WaterTaskEliz(WElizParameter p, Mesh m, SSystem a, Algorythm Alg, bool Cuda=false, bool OpenCL = false, double[] U_start = null, double[] V_start = null, double[] K_start = null, double[] E_start = null, double[] NuT_start = null, double dpdx_start = 0)
        {
            CountKnots = m.CountKnots;
            CountTriangles = m.CountElems;
            this.Alg = Alg;
            //
            BWidth = m.BandWidth();
            //
            Sys = a;
            Sys.SetSystem(CountKnots, BWidth);
            //
            ABand = new SBand(CountKnots, BWidth);
            //
            NBottom = m.CountBottom;
            NTop = m.CountTop;
            InitMassives();
            //
            Re = p.Re;
            alpha_n = p.alpha_n;
            alpha_r = p.alpha_r;
            //alpha_p = p.alpha_p;
            Q = p.Q;
            dt = p.dt_local;
            tau = p.tau;
            relaxP = p.relaxP;
            mu = p.mu;
            nu_mol = mu / rho_w;
            errP = p.errP;
            surf_flag = p.surf_flag;
            iter = p.iter;
            //nu = p.nu_m;
            delta = p.delta;
            cm14 = Math.Pow(C_m, 0.25);
            //
            this.U_start = U_start;
            this.V_start = V_start;
            this.K_start = K_start;
            this.E_start = E_start;
            this.NuT_start = NuT_start;
            this.dpdx_start = dpdx_start;
            //
            flag_OpenCL = OpenCL;
            flag_Cuda = Cuda;

            //ChangeMesh(m);
            double[] F = new double[] { 2, 7.89, 17.183, 29.276, 43.97, 142.7, 401.79, 696.68 };
            double[] y_p = new double[] { 2, 4, 6, 8, 10, 20, 40, 60 };
            alglib.spline1dbuildcubic(F, y_p, out bufF);
            //
            SinJ = Math.Sin(J);
            CosJ = Math.Cos(J);
        }

        private void InitMassives()
        {
            U = new double[CountKnots];
            V = new double[CountKnots];
            P = new double[CountKnots];
            ErrP = new double[CountKnots];
            K = new double[CountKnots];
            E = new double[CountKnots];
            S = new double[CountKnots];
            nuT = new double[CountKnots];
            rightK = new double[CountKnots];
            rightE = new double[CountKnots];
            ReT = new double[CountKnots];
            BTauC = new double[NBottom];
            BTau = new double[NBottom];
            TTauC = new double[NTop];
            TTau = new double[NTop];
            //
            dudy = new double[NBottom];

        }
        public void ChangeMesh(Mesh m)
        {
            Mesh = m;
            //обновление геометрии
            Sk = Mesh.Sk;
            b1 = Mesh.b1;
            b2 = Mesh.b2;
            b3 = Mesh.b3;
            c1 = Mesh.c1;
            c2 = Mesh.c2;
            c3 = Mesh.c3;
            X = Mesh.X;
            Y = Mesh.Y;
            //
            Lx10 = Mesh.Lx10;
            Lx32 = Mesh.Lx32;
            Ly01 = Mesh.Ly01;
            Ly23 = Mesh.Ly23;
            Alpha = Mesh.Alpha;
            S0 = Mesh.S0;
            SS = Mesh.S;
            P1 = Mesh.P1;
            _Lk = Mesh.Lk;
            Nx = Mesh.Nx;
            Ny = Mesh.Ny;
            Sx = Mesh.Sx;
            Sy = Mesh.Sy;
            // если сетка нерегулярная или количество и порядок узлов поменялись (можно оптимизировать)
            BLeftKnots = Mesh.LeftKnots;
            BRightKnots = Mesh.RightKnots;
            BBottomKnots = Mesh.BottomKnots;
            BTopKnots = Mesh.TopKnots;
            NLeft = Mesh.CountLeft;
            NRight = Mesh.CountRight;
            NTop = Mesh.CountTop;
            NBottom = Mesh.CountBottom;
            _Ny = NLeft;
            _Nx = NBottom;
            RightKnotsList = Mesh.CPRight;
            TopKnotsList = Mesh.CPTop;
            BTriangles = Mesh.BTriangles;
            CBottom = Mesh.CBottom;
            TTriangles = Mesh.TTriangles;
            CTop = Mesh.CTop;
            CV = Mesh.CVolumes;
            CV2 = Mesh.CV2;
            CV_WallKnots = Mesh.CV_WallKnots;
            CV_WallKnotsDistance = Mesh.CV_WallKnotsDistance;
            BWallDistance = Mesh.BWallDistance;
            TWallDistance = Mesh.TWallDistance;
            CV_WallTau = new double[CV_WallKnots.Length];
            Tau = new double[CountKnots];
            //
            OrdPart_CountKnots = Partitioner.Create(0, CountKnots);
            OrdPart_CV = Partitioner.Create(0, CV.Length);
            OrdPart_CV2 = Partitioner.Create(0, CV2.Length);
            OrdPart_CV_Wall = Partitioner.Create(0, CV_WallKnots.Length);
            OP_CountElems = Partitioner.Create(0, Mesh.CountElems);
            //
            InitialConditions();

        }

        public void ChangeTimeStep(WElizParameter p)
        {
            dt = p.dt_local;
            iter = p.iter;
        }
        /// <summary>
        /// Метод изменяет коэффициенты расчета (не физические величины!)
        /// </summary>
        /// <param name="p">Объект параметров расчета </param>
        public void ChangeParameters(WElizParameter p)
        {
            alpha_n = p.alpha_n;
            alpha_r = p.alpha_r;
            dt = p.dt_local;
            tau = p.tau;
            relaxP = p.relaxP;
            errP = p.errP;
            iter = p.iter;
            delta = p.delta;
        }

        void InitialConditions()
        {
            bool parabola = false;
            //Начальное условие для скорости
            double[] u0 = new double[NLeft];
            double y;
            double Hn = Y[BLeftKnots[0]] - Y[BLeftKnots[NLeft - 1]];
            //
            if (!surf_flag)
            {
                //закрытый канал
                // расчет профиля
                if (U_start == null)
                {
                    // Профиль скорости на входе
                    U_max = 3.0 / 2.0 * Q / Hn;
                    double Uav = Q / Hn;
                    // --- по параболическому профилю
                    if (parabola)
                        dPdx = -8.0 * U_max * mu / Hn / Hn;
                    //-- по степенному профилю
                    //int N = -Convert.ToInt32((Hn / 2.0) * (Hn / 2.0) / mu / Uav * dPdx - 2);
                    int N = 20;
                    if (!parabola)
                        dPdx = -(2 + N) / (Hn / 2.0) / (Hn / 2.0) * mu * Uav;
                    for (int i = 0; i < NLeft; i++)
                    {
                        // U_left
                        int knot = BLeftKnots[i];
                        //-- параболический профиль скорости
                        if (parabola)
                        {
                            y = (Y[knot] - Y[0]);
                            U[knot] = (double)(1.0 / 2.0 / mu * dPdx * (y - Hn) * y);
                            // -- скорректированный параболический профиль
                            //y = (Y[knot] - Y[0]);
                            //U[knot] = (double)(1.0 / 2.0 / mu * dPdx * (y - Hn) * y);
                            //if (U[knot] > Uav)
                            //   U[knot] = Uav;
                        }
                        //-- степенной профиль
                        else
                        {
                            y = (Y[knot] - Y[0]) - Hn / 2.0;
                            U[knot] = (N + 2) / (N + 1) * Uav * (1 - Math.Pow(Math.Abs(y) / (Hn / 2.0), N + 1));
                        }
                        //
                        Ucp += U[knot];
                    }
                    for (int i = 0; i < NLeft; i++)
                    {
                        int knot = BLeftKnots[i];
                        y = (Y[knot] - Y[0]);
                        // k_left --> V
                        K[knot] = 0.005 * U[knot] * U[knot];
                        // e_left  --> V
                        E[knot] = 0.1 * K[knot] * K[knot];// Math.Pow(C_m,0.75)*Math.Pow(K[knot],1.5)/0.1/H;
                        // s_left --> V
                        double Sz = 0.2 * (Q / Hn) * (Q / Hn) * (Q / Hn) / Hn / W;
                        double Kk = 1.4 * Math.Sqrt((rho_s - rho_w) * g * d) / kappa / Math.Sqrt(rho_w * g * Hn * J);
                        if (y == 0)
                            S[knot] = Sz;
                        else
                            S[knot] = Sz * Math.Pow(2 * d / y, Kk);
                        // nu_left --> V
                        // nu[knot] = C_m * K[knot] * K[knot] / (E[knot] + 1.0e-15);
                        //Тест
                        //P[knot] = -dPdx * (L - X[knot]);
                        ////

                    }
                    Ucp /= NLeft;
                }
                else
                {
                    //установка введенного профиля
                    if (NLeft == U_start.Length)
                    {
                        dPdx = dpdx_start;
                        for (int i = 0; i < NLeft; i++)
                        {
                            int knot = BLeftKnots[i];
                            U[i] = U_start[i];
                            V[i] = V_start[i];
                            K[i] = K_start[i];
                            E[i] = E_start[i];
                            S[i] = S_start[i];
                            nuT[i] = NuT_start[i];
                        }
                    }
                    else
                    {
                        throw new Exception("Введенный профиль скорости не совпадает по количеству точек с размерами сетки");
                    }
                    for (int i = 0; i < NLeft; i++)
                    {
                        int knot = BLeftKnots[i];
                        y = (Y[knot] - Y[0]);
                        double Sz = 0.2 * (Q / Hn) * (Q / Hn) * (Q / Hn) / Hn / W;
                        double Kk = 1.4 * Math.Sqrt((rho_s - rho_w) * g * d) / kappa / Math.Sqrt(rho_w * g * Hn * J);
                        if (y == 0)
                            S[knot] = Sz;
                        else
                            S[knot] = Sz * Math.Pow(2 * d / y, Kk);
                    }
                }
                // Гу слева прописывается во всей области
                for (int i = NLeft; i < CountKnots; i++)
                {
                    // k_left --> V
                    U[i] = U[i % NLeft];
                    // k_left --> V
                    K[i] = K[i % NLeft];
                    // e_left  --> V
                    E[i] = E[i % NLeft];
                    // s_left --> V
                    S[i] = S[i % NLeft];
                    // e_left --> V
                    //nu[i] = nu[i % NLeft];
                }
                if (flag)
                {
                    buffP = new double[CountKnots];
                    buffU = new double[CountKnots];
                    buffV = new double[CountKnots];
                    buffS = new double[CountKnots];
                    buffK = new double[CountKnots];
                    buffE = new double[CountKnots];
                    buffNu = new double[CountKnots];
                    flag = false;
                }
                else
                {
                    // решение с предыдущего расчета
                    for (int i = 0; i < CountKnots; i++)
                    {
                        U[i] = buffU[i];
                        V[i] = buffV[i];
                        P[i] = buffP[i];
                        S[i] = buffS[i];
                        K[i] = buffK[i];
                        E[i] = buffE[i];
                        nuT[i] = buffNu[i];
                    }
                }
            }
            else
            {
                //--если считаем половинку канала
                //
                //for (int i = 0; i < NLeft; i++)
                //{
                //    int knot = BLeftKnots[i];
                //    y = Y[knot];
                //    U[knot] = (double)(1 / 2.0 / mu * dPdx * (-y) * y);
                //}
                // расчет профиля
                if ((U_start == null) && (RecalcFlag == false))
                {
                    // Профиль скорости на входе
                    U_max = 3.0 / 2.0 * Q / (2*Hn);
                    double Uav = Q / Hn;
                    // --- по параболическому профилю
                    if (parabola)
                        dPdx = -8.0 * U_max * mu / Hn / Hn;
                    //-- по степенному профилю
                    //int N = -Convert.ToInt32((Hn) * (Hn) / mu / Uav * dPdx - 2);
                    int N = 50;
                    //
                    for (int i = 0; i < NLeft; i++)
                    {
                        // U_left
                        int knot = BLeftKnots[i];
                        //-- параболический профиль скорости
                        if (parabola)
                        {
                            y = (Y[knot] - Y[0]);
                            U[knot] = (double)(1.0 / 2.0 / mu * dPdx * (y - Hn * 2) * y);
                            // -- скорректированный параболический профиль
                            //y = (Y[knot] - Y[0]);
                            //U[knot] = (double)(1.0 / 2.0 / mu * dPdx * (y - Hn * 2) * y);
                            //if (U[knot] > Uav)
                            //   U[knot] = Uav;
                        }
                        //-- степенной профиль
                        else
                        {
                            y = (Y[knot] - Y[0]) - Hn;
                            U[knot] = (N + 2) / (N + 1) * Uav * (1 - Math.Pow(Math.Abs(y) / (Hn), N + 1));
                            //if (knot!=0)
                            //{
                            //        U[knot] = Uav + 0.05;
                            //}
                        }
                        //
                        Ucp += U[knot];
                    }
                    //для вычисления профиля концентрации
                    double gamma = (rho_s - rho_w) / rho_w;
                    double W_Stocks = gamma * g * d * d / (18 * (nuT[NLeft / 4] + nu_mol));
                    double uz = 1.4 * Math.Sqrt(g * Hn * J);
                    double Ko = W / (kappa * uz);
                    double S0 = 2.17 * W * d / (Math.Exp(0.39 * gamma * d / Hn) - 1);
                    //
                    for (int i = 0; i < NLeft; i++)
                    {
                        int knot = BLeftKnots[i];
                        y = (Y[knot] - Y[0]);
                        // k_left --> V
                        K[knot] = 0.005 * U[knot] * U[knot];
                        // e_left  --> V
                        E[knot] = 0.1 * K[knot] * K[knot]; // Math.Pow(C_m,0.75)*Math.Pow(K[knot],1.5)/0.1/H;
                        // s_left --> V
                        //double Sz = 0.2 * (Q / Hn) * (Q / Hn) * (Q / Hn) / Hn / W;
                        //double Kk = 1.4 * Math.Sqrt((rho_s - rho_w) * g * d) / kappa / Math.Sqrt(rho_w * g * Hn * J);
                        //S[knot] = Sz * Math.Pow(2 * d / y, Kk);
                        if (y == 0)
                            S[knot] = S0;
                        else
                        //    
                            S[knot] = S0 * Math.Pow((Hn - y) * 2 * d / (y * (Hn - 2 * d)), Ko);

                        // тест
                        // nu_left --> V
                        // nu[knot] = C_m * K[knot] * K[knot] / (E[knot] + 1.0e-15);
                        //Тест
                        //P[knot] = -dPdx * (L - X[knot]);
                        ////
                        // По Роди
                        //double Uav = Q / Hn;
                        //K[knot] = 0.5e-4 * (U[knot] / Uav) * (U[knot] / Uav);
                        //double dudy = 0;
                        //int knot2 = 0;
                        //dy = Y[1] - Y[0];
                        //if (i != 0)
                        //{
                        //    knot2 = BLeftKnots[i - 1];
                        //    dudy = (U[knot] - U[knot2]) / dy;
                        //}
                        //else
                        //{
                        //    knot2 = BLeftKnots[i + 1];
                        //    dudy = (U[knot2] - U[knot]) / dy;
                        //}
                        //E[knot] = 0.1 * K[knot] * Math.Abs(dudy);

                    }
                    Ucp /= NLeft;
                    dPdx = -(2 + N) / Hn / Hn * mu * Uav;
                    if (!parabola)
                        dPdx = -(2 + N) / Hn / Hn * C_m * K[NLeft / 2] * K[NLeft / 2] / (E[NLeft / 2] + 1.0e-15)* rho_w * Uav;
                    //
                    // Гу слева прописывается во всей области
                    for (int i = NLeft; i < CountKnots; i++)
                    {
                        // k_left --> V
                        U[i] = U[i % NLeft];
                        // k_left --> V
                        K[i] = K[i % NLeft];
                        // e_left  --> V
                        E[i] = E[i % NLeft];
                        // s_left --> V
                        S[i] = S[i % NLeft];
                        // e_left --> V
                        //nu[i] = nu[i % NLeft];
                    }
                }
                else if (U_start!=null)
                {
                    //установка введенного профиля
                    if (NLeft == U_start.Length)
                    {
                        dPdx = dpdx_start;
                        for (int i = 0; i < NLeft; i++)
                        {
                            int knot = BLeftKnots[i];
                            U[i] = U_start[i];
                            V[i] = V_start[i];
                            K[i] = K_start[i];
                            //
                            E[i] = E_start[i];
                            nuT[i] = NuT_start[i];
                        }
                        if (S_start != null)
                            for (int i = 0; i < NLeft; i++)
                                S[i] = S_start[i];
                    }
                    else
                    {
                        throw new Exception("Введенный профиль скорости не совпадает по количеству точек с размерами сетки");
                    }
                    // Гу слева прописывается во всей области
                    for (int i = NLeft; i < CountKnots; i++)
                    {
                        // k_left --> V
                        U[i] = U[i % NLeft];
                        // k_left --> V
                        K[i] = K[i % NLeft];
                        // e_left  --> V
                        E[i] = E[i % NLeft];
                        // s_left --> V
                        S[i] = S[i % NLeft];
                        // e_left --> V
                        //nu[i] = nu[i % NLeft];
                    }

                }
                #region Тест на транспорт S по области
                //for (int i = 0; i < NRight; i++)
                //{
                //    int knot = BRightKnots[i];
                //    S[knot] = 2;
                //}
                //for (int i = 0; i < NBottom; i++)
                //{
                //    int knot = BBottomKnots[i];
                //    S[knot] = 1;
                //}
                //for (int i = 0; i < NTop; i++)
                //{
                //    int knot = BTopKnots[i];
                //    S[knot] = 2;
                //}
                #endregion
                
                if (flag)
                {
                    buffP = new double[CountKnots];
                    buffU = new double[CountKnots];
                    buffV = new double[CountKnots];
                    buffS = new double[CountKnots];
                    buffK = new double[CountKnots];
                    buffE = new double[CountKnots];
                    buffNu = new double[CountKnots];
                    flag = false;
                }
                else
                {
                    // решение с предыдущего расчета
                    for (int i = 0; i < CountKnots; i++)
                    {
                        U[i] = buffU[i];
                        V[i] = buffV[i];
                        P[i] = buffP[i];
                        S[i] = buffS[i];
                        K[i] = buffK[i];
                        E[i] = buffE[i];
                        nuT[i] = buffNu[i];
                    }
                }
            }
            //ГУ на левой стенке для КЭ
            // массивы для ГУ
            RBC = new double[NLeft];
            BV = new double[NLeft];
            //главные ГУ
            for (int i = 0; i < NLeft - 1; i++)
            {
                double y1 = Y[BLeftKnots[i]];
                double y2 = Y[BLeftKnots[i + 1]];
                //
                double r3 = (double)(-Math.Abs(y1 - y2) / 2.0 * (dPdx) * (-1));
                //
                BV[i] += r3;
                BV[i + 1] += r3;
            }
        }
        public void Run()
        {
            y_plus = new double[CountKnots];
            // --временно, потом убрать флаг no-serialized
            Pk = new double[CountKnots];
            double[] F = new double[] { 2, 7.89, 17.183, 29.276, 43.97, 142.7, 401.79, 696.68 };
            double[] y_p = new double[] { 2, 4, 6, 8, 10, 20, 40, 60 };
            alglib.spline1dbuildcubic(F, y_p, out bufF);
            // так как поменяла имя переменной, она не хочет десериализоваться из сохраненных решений. То же с nuT[]
            if (nu_mol == 0)
                nu_mol = mu / rho_w;
            // если продолжать досчет старых решений (затратные операции Sin Cos теперь делаются в конструкторе 1 раз)
            if (SinJ == 0)
            {
                SinJ = Math.Sin(J);
                CosJ = Math.Cos(J);
            }
            //Тест на перенос концентрации
            S = new double[CountKnots];
            for (int i = 0; i < NLeft; i++)
            {
                S[BLeftKnots[i]] = 1;
                S[BRightKnots[i]] = 2;
            }
            ReT = new double[CountKnots];
            //--
            double MaxError = 0; // максимальная порешность по давлению
            //pr(new Form1.ReportDelegate(Program.mm.Report), "Расчет гидродинамики");
            //////////
            int knot = 0;
            int count = 0;
            double sumBU = 0;
            //
            int knotUp = 0, knotRightU = 0, knotRightD = 0, knotDown = 0;
            //
            double[] Result = null;
            //
            double[] BV2 = new double[NRight];
            //
            stopCopy = new Stopwatch();
            stopCalc = new Stopwatch();
            double qf = 0;
            //WriteToData();
            try
            {
                bool Gauss = false;
                    string s = Alg.GetType().Name;
                    if (s == "AlgorythmGauss")
                        Gauss = true;
                //
                System.Object lockThis = new System.Object();
                //stopW.Start();
                for (int iteration = beginIter; iteration < iter; iteration++)
                {
                    // для просмотра компонентов ke уравнений
                    //ConvK = new double[CountKnots];
                    //ConvE = new double[CountKnots];
                    //DiffK = new double[CountKnots];
                    //DiffE = new double[CountKnots];
                    //RegK = new double[CountKnots];
                    //RegE = new double[CountKnots];
                    //
                    //System.Threading.Thread.Sleep(5000);
                    #region Расчет вязкости
                    // OrderablePartitioner<Tuple<int, int>> rangePartitioner3 = Partitioner.Create(0, CountKnots);
                    Parallel.ForEach(OrdPart_CountKnots,
                            (range, loopState) =>
                            {
                                for (int i = range.Item1; i < range.Item2; i++)
                                //for (int i = 0; i < CountKnots; i++)
                                {
                                    nuT[i] = C_m * K[i] * K[i] / (E[i] + 1e-9);
                                    if (nuT[i] < nu_mol)
                                        nuT[i] = nu_mol;

                                }
                            });
                    //ГУ справа - снос
                    for (int i = 0; i < NRight; i++)
                    {
                        knot = BRightKnots[i];
                        //
                        nuT[knot] = nuT[knot - NRight];
                    }
                  
                    //
                    #endregion
                    ///------Протестировано ОК
                    ////////////////// МКЭ давление /////////////////////
                    
                    
                    //
                    if (Gauss)
                    {
                        #region Расчет давления
                        // выделение памяти под результат решения задачи
                        Result = new double[Mesh.CountKnots];
                        //выделяем масивы для локальных правых частей
                        if (iteration == 0)
                        {
                            ABand.ClearSystem();
                            // основной цикл по конечным элементам
                            // вычисляем локальные матрицы жесткости и производим сборку глобальной матрицы жесткости
                            //OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, Mesh.CountElems);
                            Parallel.ForEach(OP_CountElems,
                                  (range, loopState) =>
                                  {
                                      for (int fe = range.Item1; fe < range.Item2; fe++)
                                      //for (int fe = 0; fe < Mesh.CountElems; fe++)
                                      {
                                          // выделяем массивы для локальных матриц жесткости
                                          double[][] M = new double[3][];
                                          for (int k = 0; k < 3; k++)
                                          {
                                              M[k] = new double[3];
                                          }
                                          //и номера его вершин
                                          int[] LKnots = Mesh.AreaElems[fe];
                                          // нахождение площади треугольника
                                          double LSk = Sk[fe];
                                          // расчитываем геометрию элемента 
                                          double Lb1 = b1[fe];
                                          double Lb2 = b2[fe];
                                          double Lb3 = b3[fe];
                                          double Lc1 = c1[fe];
                                          double Lc2 = c2[fe];
                                          double Lc3 = c3[fe];
                                          // расчет локальной матрицы жесткости для диффузионного члена
                                          M[0][0] = -LSk * (Lb1 * Lb1 + Lc1 * Lc1);
                                          M[0][1] = -LSk * (Lb1 * Lb2 + Lc1 * Lc2);
                                          M[0][2] = -LSk * (Lb1 * Lb3 + Lc1 * Lc3);

                                          M[1][0] = -LSk * (Lb2 * Lb1 + Lc2 * Lc1);
                                          M[1][1] = -LSk * (Lb2 * Lb2 + Lc2 * Lc2);
                                          M[1][2] = -LSk * (Lb2 * Lb3 + Lc2 * Lc3);

                                          M[2][0] = -LSk * (Lb3 * Lb1 + Lc3 * Lc1);
                                          M[2][1] = -LSk * (Lb3 * Lb2 + Lc3 * Lc2);
                                          M[2][2] = -LSk * (Lb3 * Lb3 + Lc3 * Lc3);
                                          lock (lockThis)
                                              ABand.BuildMatrix(M, LKnots);
                                      }

                                  });
                            //
                            //главные ГУ справа
                            ABand.SetBoundary(BV2, BRightKnots);
                            ABand.Accept(AlgGauss, null, 1);

                        }
                        ABand.ClearRight();
                        R = new double[CountKnots];
                        //сборка правой части
                        //OrderablePartitioner<Tuple<int, int>> rangePartitioner1 = Partitioner.Create(0, Mesh.CountElems);
                        Parallel.ForEach(OP_CountElems,
                              (range, loopState) =>
                              {
                                  for (int fe = range.Item1; fe < range.Item2; fe++)
                                  //for(int fe=0;fe<Mesh.CountElems;fe++)
                                  {

                                      //for (int fe = 0; fe < Mesh.CountElem; fe++)
                                      //{
                                      // получаем текущий конечный элемент
                                      int[] LKnots = Mesh.AreaElems[fe];
                                      int Lm1 = LKnots[0];
                                      int Lm2 = LKnots[1];
                                      int Lm3 = LKnots[2];
                                      // нахождение площади треугольника
                                      double LSk = Sk[fe];
                                      // расчитываем геометрию элемента 
                                      double Lb1 = b1[fe];
                                      double Lb2 = b2[fe];
                                      double Lb3 = b3[fe];
                                      double Lc1 = c1[fe];
                                      double Lc2 = c2[fe];
                                      double Lc3 = c3[fe];
                                      //
                                      double LU1 = U[Lm1]; double LU2 = U[Lm2]; double LU3 = U[Lm3];
                                      double LV1 = V[Lm1]; double LV2 = V[Lm2]; double LV3 = V[Lm3];
                                      //правая часть - неразрывность
                                      double LSR = rho_w * LSk / (3 * tau) * ((Lb1 * LU1 + Lb2 * LU2 + Lb3 * LU3) + (Lc1 * LV1 + Lc2 * LV2 + Lc3 * LV3));
                                      double R0 = alpha_n * LSR;
                                      double R1 = alpha_n * LSR;
                                      double R2 = alpha_n * LSR;
                                      //правая часть поправка КГД
                                      double LBUU = (Lb1 * LU1 + Lb2 * LU2 + Lb3 * LU3) * (LU1 + LU2 + LU3);
                                      double LCUV = (Lc1 * LU1 + Lc2 * LU2 + Lc3 * LU3) * (LV1 + LV2 + LV3);
                                      double LBVU = (Lb1 * LV1 + Lb2 * LV2 + Lb3 * LV3) * (LU1 + LU2 + LU3);
                                      double LCVV = (Lc1 * LV1 + Lc2 * LV2 + Lc3 * LV3) * (LV1 + LV2 + LV3);
                                      //
                                      R0 += (double)(alpha_r * rho_w * LSk / 3.0 * (Lb1 * (LBUU + LCUV) + Lc1 * (LBVU + LCVV)));
                                      R1 += (double)(alpha_r * rho_w * LSk / 3.0 * (Lb2 * (LBUU + LCUV) + Lc2 * (LBVU + LCVV)));
                                      R2 += (double)(alpha_r * rho_w * LSk / 3.0 * (Lb3 * (LBUU + LCUV) + Lc3 * (LBVU + LCVV)));
                                      //
                                      //для отображения невязки
                                      R[Lm1] += R0;
                                      R[Lm2] += R1;
                                      R[Lm3] += R2;
                                      //}
                                  }

                              });
                        //
                        ABand.BuildRight(R);
                        //ГУ слева
                        ABand.BuildRight(BV, BLeftKnots);
                        //главные ГУ справа 2
                        ABand.BoundConditionsRight(BV2, BRightKnots);
                        // решение системы алгебраических уравнений
                        ABand.Accept(AlgGauss, null, 2);
                        Result = ABand.GetX;
                        //для отладки
                        for (int i = 0; i < NLeft; i++)
                            R[BLeftKnots[i]] += BV[i];
                        for (int i = 0; i < NRight; i++)
                            R[BRightKnots[i]] = 0;

                        // релаксация решения, буферизация и вычисление погрешности
                        MaxError = 0;//масимальная ошибка в области
                        for (int i = 0; i < CountKnots; i++)
                        {
                            //релаксация
                            P[i] = (1 - relaxP) * P[i] + relaxP * Result[i];
                            //вычисление погрешности
                            double CurErr = Math.Abs((P[i] - buffP[i]) / P[i]);
                            if (MaxError < CurErr)
                                MaxError = CurErr;
                            ErrP[i] = CurErr;
                            //буферизация
                            buffP[i] = P[i];
                        }
                        #endregion
                    }
                    //
                    else
                    {
                        #region Расчет давления не по Гауссу или с применением ГУ Dong
                        Sys.ClearSystem();
                        if (iteration != 0)
                            Sys.SetX(Result);
                        // выделение памяти под результат решения задачи
                        Result = new double[Mesh.CountKnots];
                        //выделяем масивы для локальных правых частей
                        // основной цикл по конечным элементам
                        // вычисляем локальные матрицы жесткости и производим сборку глобальной матрицы жесткости
                        // OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, Mesh.CountElems);
                        Parallel.ForEach(OP_CountElems,
                              (range, loopState) =>
                              {
                                  for (int fe = range.Item1; fe < range.Item2; fe++)
                                  //for (int fe = 0; fe < Mesh.CountElems; fe++)
                                  {
                                      // выделяем массивы для локальных матриц жесткости
                                      double[][] M = new double[3][];
                                      for (int k = 0; k < 3; k++)
                                      {
                                          M[k] = new double[3];
                                      }
                                      //и номера его вершин
                                      int[] LKnots = Mesh.AreaElems[fe];
                                      // нахождение площади треугольника
                                      double LSk = Sk[fe];
                                      // расчитываем геометрию элемента 
                                      double Lb1 = b1[fe];
                                      double Lb2 = b2[fe];
                                      double Lb3 = b3[fe];
                                      double Lc1 = c1[fe];
                                      double Lc2 = c2[fe];
                                      double Lc3 = c3[fe];
                                      // расчет локальной матрицы жесткости для диффузионного члена
                                      M[0][0] = -LSk * (Lb1 * Lb1 + Lc1 * Lc1);
                                      M[0][1] = -LSk * (Lb1 * Lb2 + Lc1 * Lc2);
                                      M[0][2] = -LSk * (Lb1 * Lb3 + Lc1 * Lc3);

                                      M[1][0] = -LSk * (Lb2 * Lb1 + Lc2 * Lc1);
                                      M[1][1] = -LSk * (Lb2 * Lb2 + Lc2 * Lc2);
                                      M[1][2] = -LSk * (Lb2 * Lb3 + Lc2 * Lc3);

                                      M[2][0] = -LSk * (Lb3 * Lb1 + Lc3 * Lc1);
                                      M[2][1] = -LSk * (Lb3 * Lb2 + Lc3 * Lc2);
                                      M[2][2] = -LSk * (Lb3 * Lb3 + Lc3 * Lc3);
                                      lock (lockThis)
                                          Sys.BuildMatrix(M, LKnots);
                                  }

                              });
                        R = new double[CountKnots];
                        //сборка правой части
                        // OrderablePartitioner<Tuple<int, int>> rangePartitioner1 = Partitioner.Create(0, Mesh.CountElems);
                        Parallel.ForEach(OP_CountElems,
                                (range, loopState) =>
                                {
                                    for (int fe = range.Item1; fe < range.Item2; fe++)
                                    //for (int fe = 0; fe < Mesh.CountElems; fe++)
                                    {

                                        //for (int fe = 0; fe < Mesh.CountElem; fe++)
                                        //{
                                        // получаем текущий конечный элемент
                                        int[] LKnots = Mesh.AreaElems[fe];
                                        int Lm1 = LKnots[0];
                                        int Lm2 = LKnots[1];
                                        int Lm3 = LKnots[2];
                                        // нахождение площади треугольника
                                        double LSk = Sk[fe];
                                        // расчитываем геометрию элемента 
                                        double Lb1 = b1[fe];
                                        double Lb2 = b2[fe];
                                        double Lb3 = b3[fe];
                                        double Lc1 = c1[fe];
                                        double Lc2 = c2[fe];
                                        double Lc3 = c3[fe];
                                        //
                                        double LU1 = U[Lm1]; double LU2 = U[Lm2]; double LU3 = U[Lm3];
                                        double LV1 = V[Lm1]; double LV2 = V[Lm2]; double LV3 = V[Lm3];
                                        //правая часть - неразрывность
                                        double LSR = rho_w * LSk / (3 * tau) * ((Lb1 * LU1 + Lb2 * LU2 + Lb3 * LU3) + (Lc1 * LV1 + Lc2 * LV2 + Lc3 * LV3));
                                        double R0 = alpha_n * LSR;
                                        double R1 = alpha_n * LSR;
                                        double R2 = alpha_n * LSR;
                                        //правая часть поправка КГД
                                        double LBUU = (Lb1 * LU1 + Lb2 * LU2 + Lb3 * LU3) * (LU1 + LU2 + LU3);
                                        double LCUV = (Lc1 * LU1 + Lc2 * LU2 + Lc3 * LU3) * (LV1 + LV2 + LV3);
                                        double LBVU = (Lb1 * LV1 + Lb2 * LV2 + Lb3 * LV3) * (LU1 + LU2 + LU3);
                                        double LCVV = (Lc1 * LV1 + Lc2 * LV2 + Lc3 * LV3) * (LV1 + LV2 + LV3);
                                        //
                                        R0 += alpha_r * rho_w * LSk / 3.0 * (Lb1 * (LBUU + LCUV) + Lc1 * (LBVU + LCVV));
                                        R1 += alpha_r * rho_w * LSk / 3.0 * (Lb2 * (LBUU + LCUV) + Lc2 * (LBVU + LCVV));
                                        R2 += alpha_r * rho_w * LSk / 3.0 * (Lb3 * (LBUU + LCUV) + Lc3 * (LBVU + LCVV));
                                        //ГУ по Фомину
                                        //RR[0] += alpha_p * rho_w * LSk / 3.0 * (1 / dt * qf);
                                        //RR[1] += alpha_p * rho_w * LSk / 3.0 * (1 / dt * qf);
                                        //RR[2] += alpha_p * rho_w * LSk / 3.0 * (1 / dt * qf);
                                        //
                                        //для отображения невязки
                                        R[Lm1] += R0;
                                        R[Lm2] += R1;
                                        R[Lm3] += R2;
                                        //}
                                    }

                                });
                        //
                        Sys.BuildRight(R, null);
                        //ГУ слева
                        Sys.BuildRight(BV, BLeftKnots);
                        //главные ГУ справа 2
                        //if (iteration == iter - 1)
                        //    DongBC_PE();
                        //else
                        //    DongBC_P();
                        // ГУ P=0 справа    //
                        RBC = new double[NRight];
                        // для Dong убрать  //
                        Sys.SetBoundary(RBC, BRightKnots);
                        //Sys.SetBoundary(BV2, BRightKnots);
                        //Sys.SetBoundary(new double[] { 0 }, new int[] { BRightKnots[NRight - 1] }); // задаем ноль в правой верхней точке
                        // решение системы алгебраических уравнений
                        Sys.Accept(Alg);
                        Result = Sys.GetX;
                        //
                        //для отладки
                        for (int i = 0; i < NLeft; i++)
                            R[BLeftKnots[i]] += BV[i];
                        for (int i = 0; i < NRight; i++)
                            R[BRightKnots[i]] = 0;
                        // релаксация решения, буферизация и вычисление погрешности
                        MaxError = 0;// масимальная ошибка в области
                        for (int i = 0; i < CountKnots; i++)
                        {
                            //релаксация
                            P[i] = (1 - relaxP) * P[i] + relaxP * Result[i];
                            //вычисление погрешности
                            double CurErr = Math.Abs((P[i] - buffP[i]) / P[i]);
                            if (MaxError < CurErr)
                                MaxError = CurErr;
                            ErrP[i] = CurErr;
                            //буферизация
                            buffP[i] = P[i];
                        }
                    
                        #endregion
                    }
               

                    ///------Протестировано ОК
                    ////////////////// МКО скорость /////////////////////
                    #region Расчет скоростей
                    //
                    //цикл по внутренним КО
                    //if (CV_WallTau[0] == 0)
                    //    iteration = QHDUS(iteration);
                    //else
                        iteration = QHDUS2(iteration);
                    if (err != "ok")
                        return;
                    //

                    #endregion
                    // 
                    #region Расчет K, epsilon
                    iteration = QHDKE(iteration);
                    
                    #endregion
                    //
                    
                         
                    //выход из цикла если ошибка меньше или равно errP
                    if (MaxError <= errP)
                    {
                        Iter = iteration + 1;
                        break;
                    }
                    //
                    beginIter = iteration + 1;
                    if (SerializeNow)
                    {
                        status = "Stoped";
                        return;
                    }
                    Iter = iteration + 1;
                    //расход на входе и выходе из расчетной области
                    Q_in = 0; Q_out = 0;
                    for (int k = 0; k < NLeft - 1; k++)
                    {
                        int a = BLeftKnots[k];
                        int b = BLeftKnots[k + 1];
                        Q_in += (U[a] + U[b]) * 0.5f * Math.Abs(Y[a] - Y[b]);
                    }
                    //
                    for (int k = 1; k < NRight - 1; k++)
                    {
                        int a = BRightKnots[k];
                        int b = BRightKnots[k + 1];
                        Q_out += (U[a] + U[b]) * 0.5f * Math.Abs(Y[a] - Y[b]);
                    }

                    //if ((iteration % 500 == 0) && (iteration != 0))
                    //{
                    //    OutflowProfileInflow();
                    //}
                }
                //Iter = iter;
                for (int i = 0; i < CountKnots; i++)
                {
                    buffU[i] = U[i];
                    buffV[i] = V[i];
                    buffK[i] = K[i];
                    buffE[i] = E[i];
                    buffS[i] = S[i];
                    buffNu[i] = nuT[i];
                    #region Сохранение y_plus - отключено
                    // y+ по Гришанину
                    //double delta = 0.6 * d;
                    //if (i < CountKnots - 10)
                    //{
                    //    double y1 = Mesh.GetNormalDistanceBottom(i);
                    //    //double y1 = Y[i] - Y[(i / NLeft) * NLeft];
                    //    double f = U[i] * y1 / nu_mol;
                    //    double y_pl = 0;
                    //    if (f <= 782.4968) // ламинарный слой
                    //        y_pl = Math.Sqrt(2 * f);
                    //    else  // логарифмический слой
                    //    {
                    //        double y_i = 39.56;
                    //        double F_i = 0, u_i = 0, y_i1 = 0;
                    //        for (int h = 0; h < 7; h++)
                    //        {
                    //            F_i = 2.5 * y_i * (Math.Log(20.0855 * y_i / delta) - 1) - 683.559072;
                    //            u_i = 2.5 * Math.Log(20.0855 * y_i / delta);
                    //            y_i1 = y_i + (f - F_i) / u_i;
                    //            if (Math.Abs(y_i - y_i1) < 0.000001)
                    //            {
                    //                y_i = y_i1;
                    //                break;
                    //            }
                    //            y_i = y_i1;
                    //        }
                    //        y_pl = y_i1;
                    //    }
                    //    //
                    //    y_plus[i] = y_pl;
                    //}
                    //------------------------
                    // y+ по Волкову
                    //double kp = K[i];
                    //double Dy = Y[i] - Y[(i / NLeft) * NLeft];
                    //double Du = U[i];
                    //double Re = rho_w * cm14 * Math.Sqrt(Math.Abs(kp)) * Dy / mu;
                    //// tau
                    //double tauw = (rho_w * cm14 * Math.Sqrt(Math.Abs(kp)) * Du) / (1.0 / kappa * Math.Log(8.8 * Re));
                    //y_plus[i] = Dy * Math.Sqrt(tauw / rho_w) / nu_mol;
                    //-------------------------------------------------
                    // по Луцкому с буферным слоем
                    //if (i < CountKnots - 10)
                    //{
                    //    double y1 = Mesh.GetNormalDistanceBottom(i);
                    //    double f = U[i] * y1 / nu_mol;
                    //    double y_pl = 0;
                    //    if (f <= 2) // ламинарный слой
                    //        y_pl = Math.Sqrt(2 * f);
                    //    else if (f >= 696.68) // логарифмический слой
                    //    {
                    //        double y_i = 60;
                    //        double F_i = 0, u_i = 0, y_i1 = 0;
                    //        for (int h = 0; h < 7; h++)
                    //        {
                    //            F_i = 2.5 * y_i * (Math.Log(y_i / 0.13) - 1) - 73.50481;
                    //            u_i = 2.5 * Math.Log(y_i / 0.13);
                    //            y_i1 = y_i + (f - F_i) / u_i;
                    //            if (Math.Abs(y_i - y_i1) < 0.000001)
                    //            {
                    //                y_i = y_i1;
                    //                break;
                    //            }
                    //            y_i = y_i1;
                    //        }
                    //        y_pl = y_i1;
                    //    }
                    //    else // буферный слой
                    //        y_pl = alglib.spline1dcalc(bufF, f);
                    //    //
                    //    y_plus[i] = y_pl;
                    //}
                    // --------------------------------------
                    // по Снегиреву
                    //double dy = Y[i] - Y[(i / NLeft) * NLeft];
                    //if (dy > 0)
                    //{
                    //    double y_p_plus = cm14 * Math.Sqrt(K[i]) * dy / nu_mol;
                    //    double u2_tau = 0;
                    //    if (y_p_plus > y_p_0)
                    //        u2_tau = cm14 * cm14 * K[i];
                    //    else
                    //        u2_tau = nu_mol * U[i] / (dy + 0.00000001);
                    //    double tau_w = u2_tau * rho_w;
                    //    y_plus[i] = dy * Math.Sqrt(tau_w / rho_w) / nu_mol;
                    //}
                    #endregion
                }
                
                beginIter = 0;
                //Q_in = 0; Q_out = 0;
                //for (int k = 0; k < NLeft - 1; k++)
                //{
                //    int a = BLeftKnots[k];
                //    int b = BLeftKnots[k + 1];
                //    Q_in += (U[a] + U[b]) * 0.5f * Math.Abs(Y[a] - Y[b]);
                //}
                ////
                //for (int k = 1; k < NRight - 1; k++)
                //{
                //    int a = BRightKnots[k];
                //    int b = BRightKnots[k + 1];
                //    Q_out += (U[a] + U[b]) * 0.5f * Math.Abs(Y[a] - Y[b]);
                //}
            }
            catch (Exception ex)
            {
                err = err + "WaterTask.Run " + ex.Message;
            }
            //вычисление сдвиговых напряжений на дне через скорости по уравненям Рейнольдса
            ////ShearStresses();
            //ShearStress(BBottomKnots, CBottom, BTriangles, out BTau, out BTauC, out arg);
            //ShearStress(BTopKnots, CTop, TTriangles, out TTau, out TTauC, out argT);
            //
            // напряжения на дне находятся по функции стенки при вычислении k-e
        }
        /// <summary>
        /// Метод переносит профиль с выхода из расчетной области на вход для установления
        /// Справедливо только, когда количество узлов на входной и выходной стенках совпадают
        /// </summary>
        private void OutflowProfileInflow()
        {
            int lknot = BLeftKnots[0];
            int rknot = BRightKnots[NRight-1]; // берем профиль на выходной границе
            double dx = Mesh.X[BBottomKnots[1]];
            //int rknot = Convert.ToInt32(0.75 / dx - 1) * _Ny - 1;
            for (int i = 0; i < NLeft; i++)
            {
                //lknot = BLeftKnots[i];
                //rknot = BRightKnots[i];
                //
                U[lknot] = U[rknot];
                V[lknot] = V[rknot];
                //P[lknot] = P[rknot];
                //
                //S[lknot] = S[rknot];
                nuT[lknot] = nuT[rknot];
                K[lknot] = K[rknot];
                E[lknot] = E[rknot];
                lknot--;
                rknot--;
            }
            // меняем dPdx_in
            //dPdx = 0;
            //int Knot = 0;
            //// -- с середины области
            //double point = 0.45;
            //for (int j = 0; j < NBottom; j++)
            //{
            //    Knot = BBottomKnots[j];
            //    if ((point - X[Knot]) < 0.0001)
            //        break;
            //}
            //for (int i = 0; i < NLeft; i++)
            //{
            //    dPdx += (P[Knot] - P[Knot - _Ny]) / (X[Knot] - X[Knot - _Ny]);
            //    Knot++;

            //}
            //dPdx /= NRight;
            ////--
            // -- с выходной границы
            //for (int i = 0; i < NRight; i++)
            //{
            //    // с сечения на выходе
            //    Knot = BRightKnots[i];
            //    dPdx += (P[Knot] - P[Knot - _Ny]) / (X[Knot] - X[Knot - _Ny]);

            //}
            ////--
            //dPdx /= NRight;
            // -- с середины выходной границы
            //Knot = BRightKnots[_Ny/2];
            //dPdx = (P[Knot] - P[Knot - _Ny]) / (X[Knot] - X[Knot - _Ny]);
            ////
            //for (int i = 0; i < NLeft - 1; i++)
            //{
            //    double y1 = Y[BLeftKnots[i]];
            //    double y2 = Y[BLeftKnots[i + 1]];
            //    //
            //    double r3 = (double)(-Math.Abs(y1 - y2) / 2.0 * (dPdx) * (-1));
            //    //
            //    BV[i] += r3;
            //    BV[i + 1] += r3;
            //}
        }
        public int All_Calc_Parallel()
        {
            double MaxError = 0; // максимальная порешность по давлению
            int iteration = 0;
            //
            int knot = 0;
            double[] Result = null;
            double[] BV2 = new double[NRight];
            Pk = new double[CountKnots];
            //
            stopCopy = new Stopwatch();
            stopCalc = new Stopwatch();
            //
            System.Object lockThis = new System.Object();
            //
            bool Gauss = false;
            string ss = Alg.GetType().Name;
            if (ss == "AlgorythmGauss")
                Gauss = true;
            //
            if (flag_OpenCL)
            {
                stopCopy.Restart();
                //
                int width = 4;
                //
                int CVLength = CV2.Length + CV_WallKnots.Length;
                int[] Num = new int[CVLength + 1]; // хранит как плотной упаковке номера узлов КО и его соседних узлов
                int ch = 0;
                for (int i = 0; i < CV2.Length; i++)
                {
                    Num[i] = ch;
                    ch += CV2[i].Length;
                }
                //
                for (int i = 0; i < CV_WallKnots.Length; i++)
                {
                    Num[CV2.Length + i] = ch;
                    ch += CV_WallKnots[i].Length;
                }
                Num[CVLength] = ch;
                // перевод массивов во float и в одномерный вид
                int[] OCV = new int[ch];
                int[] OP1 = new int[ch];
                float[] OSS = new float[ch];
                float[] OLx10 = new float[ch];
                float[] OLx32 = new float[ch];
                float[] OLy01 = new float[ch];
                float[] OLy23 = new float[ch];
                float[] ONx = new float[ch];
                float[] ONy = new float[ch];
                float[] OAlpha = new float[ch];
                float[] OLk = new float[ch];
                float[] OS0 = new float[CountKnots];
                //
                ch = 0;
                for (int i = 0; i < CV2.Length; i++)
                {
                    int jj = CV2[i].Length;
                    int p0 = CV2[i][0];
                    //
                    for (int j = 0; j < jj; j++)
                    {
                        OCV[ch] = CV2[i][j];
                        OP1[ch] = P1[p0][j];
                        OSS[ch] = (float)SS[p0][j];
                        OLx10[ch] = (float)Lx10[p0][j];
                        OLx32[ch] = (float)Lx32[p0][j];
                        OLy01[ch] = (float)Ly01[p0][j];
                        OLy23[ch] = (float)Ly23[p0][j];
                        ONx[ch] = (float)Nx[p0][j];
                        ONy[ch] = (float)Ny[p0][j];
                        OAlpha[ch] = (float)Alpha[p0][j];
                        OLk[ch] = (float)_Lk[p0][j];
                        ch++;
                    }
                    //
                    OS0[p0] = (float)S0[p0];
                }
                //
                float[] OCV_Tau = new float[CV_WallKnots.Length];
                float[] OCV_WallKnotsDistance = new float[CV_WallKnots.Length];
                //
                for (int i = 0; i < CV_WallKnots.Length; i++)
                {
                    int jj = CV_WallKnots[i].Length;
                    int p0 = CV_WallKnots[i][0];
                    //
                    for (int j = 0; j < jj; j++)
                    {
                        OCV[ch] = CV_WallKnots[i][j];
                        OP1[ch] = P1[p0][j];
                        OSS[ch] = (float)SS[p0][j];
                        OLx10[ch] = (float)Lx10[p0][j];
                        OLx32[ch] = (float)Lx32[p0][j];
                        OLy01[ch] = (float)Ly01[p0][j];
                        OLy23[ch] = (float)Ly23[p0][j];
                        ONx[ch] = (float)Nx[p0][j];
                        ONy[ch] = (float)Ny[p0][j];
                        OAlpha[ch] = (float)Alpha[p0][j];
                        OLk[ch] = (float)_Lk[p0][j];
                        ch++;
                    }
                    //
                    OS0[p0] = (float)S0[p0];
                    //
                    OCV_Tau[i] = (float)CV_WallTau[i];
                    OCV_WallKnotsDistance[i] = (float)CV_WallKnotsDistance[i];
                }
                //
                ch = 0;
                int[] OAreaElems = new int[Mesh.CountElems * 3];
                for (int i = 0; i < Mesh.AreaElems.Length; i++)
                {
                    int[] Knots = Mesh.AreaElems[i];
                    OAreaElems[ch++] = Knots[0];
                    OAreaElems[ch++] = Knots[1];
                    OAreaElems[ch++] = Knots[2];
                }
                //
                float[] OU = new float[CountKnots];
                float[] OV = new float[CountKnots];
                float[] OP = new float[CountKnots];
                float[] OS = new float[CountKnots];
                //
                float[] OK = new float[CountKnots];
                float[] OE = new float[CountKnots];
                float[] OnuT = new float[CountKnots];
                float[] OPk = new float[CountKnots];
                //
                OrderablePartitioner<Tuple<int, int>> rangePartitioner3 = Partitioner.Create(0, CountKnots);
                Parallel.ForEach(rangePartitioner3,
                      (range, loopState) =>
                      {
                          for (int i = range.Item1; i < range.Item2; i++)
                          {
                              OU[i] = (float)U[i];
                              OV[i] = (float)V[i];
                              OP[i] = (float)P[i];
                              OS[i] = (float)S[i];
                              //
                              OK[i] = (float)K[i];
                              OE[i] = (float)E[i];
                              OnuT[i] = (float)nuT[i];
                          }
                      });
                //
                stopCopy.Stop();
                timeSpanArrays = stopCopy.Elapsed;
                #region Расчет на OpenCL
                if (CV.Length / width > 2147483647)
                    width *= 2;
                //
                //д.б. < 3 999 ГБайта
                double glSize = sizeof(int) * OCV.Length + sizeof(int) * Num.Length + sizeof(float) * OLx10.Length + sizeof(float) * OLx32.Length + sizeof(float) * OLy01.Length +
                    sizeof(float) * OLy23.Length + sizeof(float) * OSS.Length + sizeof(int) * OP1.Length + sizeof(int) * OAreaElems.Length + sizeof(float) * ONx.Length
                    + sizeof(float) * ONy.Length + sizeof(float) * OAlpha.Length + sizeof(float) * OLk.Length + sizeof(float) * OS0.Length + sizeof(float) * OP.Length +
                    sizeof(float) * OU.Length + sizeof(float) * OV.Length + sizeof(float) * OS.Length + sizeof(float) * OK.Length + sizeof(float) * OE.Length + sizeof(float) * OnuT.Length;
                glSize = glSize / 8.0 / 1024.0 / 1024.0 / 1024.0;
                //д.б. < 64 КБайта
                double constSize = 8 * sizeof(float) + 2 * sizeof(int);
                constSize = constSize / 8.0 / 1024.0;
                //Выбор платформы расчета, создание контекста
                ComputeContextPropertyList properties = new ComputeContextPropertyList(ComputePlatform.Platforms[0]);
                ComputeContext context = new ComputeContext(ComputeDeviceTypes.All, properties, null, IntPtr.Zero);
                //Инициализация OpenCl, выбор устройства
                ComputeCommandQueue commands = new ComputeCommandQueue(context, context.Devices[0], ComputeCommandQueueFlags.None);
                //Считывание текста программы из файла
                string s = AppDomain.CurrentDomain.BaseDirectory;
                StreamReader streamReader = new StreamReader("UVKE_OpenCL.cl");
                string clSource = streamReader.ReadToEnd();
                streamReader.Close();
                //Компиляция программы
                ComputeProgram program = new ComputeProgram(context, clSource);
                program.Build(context.Devices, "", null, IntPtr.Zero);
                //Создание ядра
                ComputeKernel kernelUV = program.CreateKernel("UV_CV2");
                ComputeKernel kernelKE = program.CreateKernel("KE_CV2");
                ////Создание буферов параметров
                //(const int CV2Length, const int CVWLength, const int width, const float dt, const float rho_w, const float nu_mol, const float tau, const float WSinJ, const float WCosJ,
                //global read_only int* OCV, global read_only int* Num, global read_only float* OLx10, global read_only float* OLx32, global read_only float* OLy01, global read_only float* OLy23, 
                //global read_only float* OSS, global read_only int* OP1, global read_only int* OAreaElems, global read_only float* ONx, global read_only float* ONy, global read_only float* OAlpha, 
                //global read_only float* OLk, global read_only float* OS0, global read_only float* CV_Tau, global read_only float* OP, global read_only float* OK, global read_only float* OE, 
                //global read_only float* OnuT, global float* OU, global float* OV, global float* OS)
                //---
                stopCopy.Restart();
                ////Выделение памяти на device(OpenCl) под переменные
                ComputeBuffer<int> Ocv = new ComputeBuffer<int>(context, ComputeMemoryFlags.ReadOnly | ComputeMemoryFlags.CopyHostPointer, OCV);
                ComputeBuffer<int> Onum = new ComputeBuffer<int>(context, ComputeMemoryFlags.ReadOnly | ComputeMemoryFlags.CopyHostPointer, Num);
                ComputeBuffer<float> Olx10 = new ComputeBuffer<float>(context, ComputeMemoryFlags.ReadOnly | ComputeMemoryFlags.CopyHostPointer, OLx10);
                ComputeBuffer<float> Olx32 = new ComputeBuffer<float>(context, ComputeMemoryFlags.ReadOnly | ComputeMemoryFlags.CopyHostPointer, OLx32);
                ComputeBuffer<float> Oly01 = new ComputeBuffer<float>(context, ComputeMemoryFlags.ReadOnly | ComputeMemoryFlags.CopyHostPointer, OLy01);
                ComputeBuffer<float> Oly23 = new ComputeBuffer<float>(context, ComputeMemoryFlags.ReadOnly | ComputeMemoryFlags.CopyHostPointer, OLy23);
                ComputeBuffer<float> Oss = new ComputeBuffer<float>(context, ComputeMemoryFlags.ReadOnly | ComputeMemoryFlags.CopyHostPointer, OSS);
                ComputeBuffer<int> Op1 = new ComputeBuffer<int>(context, ComputeMemoryFlags.ReadOnly | ComputeMemoryFlags.CopyHostPointer, OP1);
                ComputeBuffer<int> OareaElems = new ComputeBuffer<int>(context, ComputeMemoryFlags.ReadOnly | ComputeMemoryFlags.CopyHostPointer, OAreaElems);
                ComputeBuffer<float> Onx = new ComputeBuffer<float>(context, ComputeMemoryFlags.ReadOnly | ComputeMemoryFlags.CopyHostPointer, ONx);
                ComputeBuffer<float> Ony = new ComputeBuffer<float>(context, ComputeMemoryFlags.ReadOnly | ComputeMemoryFlags.CopyHostPointer, ONy);
                ComputeBuffer<float> Oalpha = new ComputeBuffer<float>(context, ComputeMemoryFlags.ReadOnly | ComputeMemoryFlags.CopyHostPointer, OAlpha);
                ComputeBuffer<float> Olk = new ComputeBuffer<float>(context, ComputeMemoryFlags.ReadOnly | ComputeMemoryFlags.CopyHostPointer, OLk);
                ComputeBuffer<float> Os0 = new ComputeBuffer<float>(context, ComputeMemoryFlags.ReadOnly | ComputeMemoryFlags.CopyHostPointer, OS0);
                ComputeBuffer<float> Ocv_tau = new ComputeBuffer<float>(context, ComputeMemoryFlags.ReadOnly | ComputeMemoryFlags.CopyHostPointer, OCV_Tau);
                ComputeBuffer<float> Ocv_WallKnotsDistance = new ComputeBuffer<float>(context, ComputeMemoryFlags.ReadOnly | ComputeMemoryFlags.CopyHostPointer, OCV_WallKnotsDistance);
                // с CopyHostPointer быстрее
                ComputeBuffer<float> Op = new ComputeBuffer<float>(context, ComputeMemoryFlags.ReadOnly | ComputeMemoryFlags.CopyHostPointer, OP);
                ComputeBuffer<float> Ok = new ComputeBuffer<float>(context, ComputeMemoryFlags.ReadWrite | ComputeMemoryFlags.CopyHostPointer, OK);
                ComputeBuffer<float> Oe = new ComputeBuffer<float>(context, ComputeMemoryFlags.ReadWrite | ComputeMemoryFlags.CopyHostPointer, OE);
                ComputeBuffer<float> Onut = new ComputeBuffer<float>(context, ComputeMemoryFlags.ReadWrite | ComputeMemoryFlags.CopyHostPointer, OnuT);
                ComputeBuffer<float> Ou = new ComputeBuffer<float>(context, ComputeMemoryFlags.ReadWrite | ComputeMemoryFlags.CopyHostPointer, OU);
                ComputeBuffer<float> Ov = new ComputeBuffer<float>(context, ComputeMemoryFlags.ReadWrite | ComputeMemoryFlags.CopyHostPointer, OV);
                ComputeBuffer<float> Os = new ComputeBuffer<float>(context, ComputeMemoryFlags.ReadWrite | ComputeMemoryFlags.CopyHostPointer, OS);
                ComputeBuffer<float> Opk = new ComputeBuffer<float>(context, ComputeMemoryFlags.ReadWrite | ComputeMemoryFlags.CopyHostPointer, OPk);
                // установка буферов в kernel
                kernelUV.SetValueArgument<int>(0, CV2.Length);
                kernelUV.SetValueArgument<int>(1, CV_WallKnots.Length);
                kernelUV.SetValueArgument<int>(2, width);
                kernelUV.SetValueArgument<float>(3, Convert.ToSingle(dt));
                kernelUV.SetValueArgument<float>(4, Convert.ToSingle(rho_w));
                kernelUV.SetValueArgument<float>(5, Convert.ToSingle(nu_mol));
                kernelUV.SetValueArgument<float>(6, Convert.ToSingle(tau));
                kernelUV.SetValueArgument<float>(7, Convert.ToSingle(W * SinJ));
                kernelUV.SetValueArgument<float>(8, Convert.ToSingle(W * CosJ));
                kernelUV.SetMemoryArgument(9, Ocv);
                kernelUV.SetMemoryArgument(10, Onum);
                kernelUV.SetMemoryArgument(11, Olx10);
                kernelUV.SetMemoryArgument(12, Olx32);
                kernelUV.SetMemoryArgument(13, Oly01);
                kernelUV.SetMemoryArgument(14, Oly23);
                kernelUV.SetMemoryArgument(15, Oss);
                kernelUV.SetMemoryArgument(16, Op1);
                kernelUV.SetMemoryArgument(17, OareaElems);
                kernelUV.SetMemoryArgument(18, Onx);
                kernelUV.SetMemoryArgument(19, Ony);
                kernelUV.SetMemoryArgument(20, Oalpha);
                kernelUV.SetMemoryArgument(21, Olk);
                kernelUV.SetMemoryArgument(22, Os0);
                kernelUV.SetMemoryArgument(23, Ocv_tau);
                kernelUV.SetMemoryArgument(24, Op);
                kernelUV.SetMemoryArgument(25, Ok);
                kernelUV.SetMemoryArgument(26, Oe);
                kernelUV.SetMemoryArgument(27, Onut);
                kernelUV.SetMemoryArgument(28, Ou);
                kernelUV.SetMemoryArgument(29, Ov);
                kernelUV.SetMemoryArgument(30, Os);
                //
                kernelKE.SetValueArgument<int>(0, CV2.Length);
                kernelKE.SetValueArgument<int>(1, CV_WallKnots.Length);
                kernelKE.SetValueArgument<int>(2, width);
                kernelKE.SetValueArgument<float>(3, Convert.ToSingle(dt));
                kernelKE.SetValueArgument<float>(4, Convert.ToSingle(rho_w));
                kernelKE.SetValueArgument<float>(5, Convert.ToSingle(nu_mol));
                kernelKE.SetValueArgument<float>(6, Convert.ToSingle(tau));
                kernelKE.SetValueArgument<float>(7, Convert.ToSingle(C_e1));
                kernelKE.SetValueArgument<float>(8, Convert.ToSingle(C_e2));
                kernelKE.SetValueArgument<float>(9, Convert.ToSingle(C_m));
                kernelKE.SetValueArgument<float>(10, Convert.ToSingle(sigma_e));
                kernelKE.SetValueArgument<float>(11, Convert.ToSingle(sigma_k));
                kernelKE.SetValueArgument<float>(12, Convert.ToSingle(kappa));
                kernelKE.SetValueArgument<float>(13, Convert.ToSingle(y_p_0));
                kernelKE.SetMemoryArgument(14, Ocv);
                kernelKE.SetMemoryArgument(15, Onum);
                kernelKE.SetMemoryArgument(16, Olx10);
                kernelKE.SetMemoryArgument(17, Olx32);
                kernelKE.SetMemoryArgument(18, Oly01);
                kernelKE.SetMemoryArgument(19, Oly23);
                kernelKE.SetMemoryArgument(20, Oss);
                kernelKE.SetMemoryArgument(21, Op1);
                kernelKE.SetMemoryArgument(22, OareaElems);
                kernelKE.SetMemoryArgument(23, Onx);
                kernelKE.SetMemoryArgument(24, Ony);
                kernelKE.SetMemoryArgument(25, Oalpha);
                kernelKE.SetMemoryArgument(26, Olk);
                kernelKE.SetMemoryArgument(27, Os0);
                kernelKE.SetMemoryArgument(28, Ocv_WallKnotsDistance);
                kernelKE.SetMemoryArgument(29, Op);
                kernelKE.SetMemoryArgument(30, Ou);
                kernelKE.SetMemoryArgument(31, Ov);
                kernelKE.SetMemoryArgument(32, Ok);
                kernelKE.SetMemoryArgument(33, Oe);
                kernelKE.SetMemoryArgument(34, Onut);
                kernelKE.SetMemoryArgument(35, Opk);
                //
                //массив, определяющий размерность расчета (количество потоков в определенном измерении)
                long[] globalSize = new long[1];
                if (CV.Length / width * width != CV.Length)
                    width = 2;
                globalSize[0] = (long)Math.Round((double)(CV2.Length / width), MidpointRounding.AwayFromZero);// тк в Diff.cl width=4
                //---
                stopCopy.Stop();
                stopCalc.Reset();
                //
                for (iteration = beginIter; iteration < iter; iteration++)
                {
                    //конвертация в double
                    for (int i = 0; i < U.Length; i++)
                    {
                        U[i] = Convert.ToDouble(OU[i]);
                        V[i] = Convert.ToDouble(OV[i]);
                    }
                    //------------------ Расчет давления
                    PressureCalc(ref MaxError, ref Result, BV2, lockThis, iteration, Gauss);
                    // перенос данных в буффер
                    for (int i = 0; i < U.Length; i++)
                    {
                        OP[i] = Convert.ToSingle(P[i]);
                    }
                    //
                    // вычисление напряжения по пристеночной функции
                    for (int i = 0; i < CV_WallKnots.Length; i++)
                    {
                        knot = CV_WallKnots[i][0];
                        //CV_WallTau[i] = WallFuncSharpPlus(knot, CV_WallKnotsDistance[i]);//шероховатая стенка по Луцкому, установка по Снегиреву
                        //CV_WallTau[i] = WallFuncSnegirev(knot, CV_WallKnotsDistance[i]);// гладкая стенка по Снегиреву
                        //CV_WallTau[i] = WallFuncPlus(knot, CV_WallKnotsDistance[i]);// гладкая стенка по Луцкому
                        OCV_Tau[i] = (float)WallFunc(knot, CV_WallKnotsDistance[i]);// гладкая стенка по Волкову упрощ
                        //CV_WallTau[i] = WallFuncNewton(knot, CV_WallKnotsDistance[i]);// гладкая стенка по Волкову Ньютон
                    }
                    stopCopy.Start();
                    commands.WriteToBuffer(OP, Op, true, null);
                    stopCopy.Stop();
                    //
                    if (true)
                    {
                        #region Код ядра на CPU
                        int CV2Length = CV2.Length;
                        int CVWLength = CV_WallKnots.Length;
                        int p0, jj, Lv1, Lv2, Lp1, Lt1, Lt2, Lt3, Lz1, Lz2, Lz3;
                        float lx10, lx32, ly01, ly23, LS, LUc1, LVc1, LPc1, LSc1, LKc1, LUc2, LVc2, LPc2, LSc2, LKc2, Ls2, Ldudx, Ldudy, Ldvdx, Ldvdy, Ldpdx, Ldpdy, Ldsdx, Ldsdy, Ldkdx, Ldkdy, Lnx, Lny, Lalpha,
                            LUcr, LVcr, LPcr, LScr, LLk, LNucr, LKcr, LEcr, LpressU, LconvU, LdiffU, LregU1, LregU2, LregU, LpressV, LconvV, LdiffV, LregV1, LregV2, LregV, LconvS, LdiffS, LregS, wx, wy, wk;
                        int k, j;
                        for (int gl = 0; gl < globalSize[0]; gl++)
                        {
                            int c = gl * width; // NX*NY / width
                            float LsummU = 0, LsummV = 0, LsummS = 0; //потоки U, V скорости, S
                            int i;
                            for (k = 0; k < width; k++)
                            {
                                i = c + k;
                                //
                                LsummU = 0;//потоки U скорости
                                LsummV = 0;//потоки V скорости
                                LsummS = 0;//потоки s концентрации
                                //
                                p0 = OCV[Num[i]];
                                jj = Num[i + 1] - Num[i] - 1; //количество КО, связанных с данным узлом
                                for (j = Num[i]; j < Num[i + 1] - 1; j++)
                                {
                                    lx10 = OLx10[j]; lx32 = OLx32[j];
                                    ly01 = OLy01[j]; ly23 = OLy23[j];
                                    //площадь
                                    LS = OSS[j];
                                    //сосоедние элементы
                                    Lv1 = OCV[(j - Num[i] + 1) % jj + Num[i] + 1];
                                    Lv2 = OCV[j + 1];
                                    //вторая точка общей грани
                                    Lp1 = OP1[j];
                                    //находим значения функций в центрах масс 1ого и 2ого треугольника как средние значения по элементу
                                    Lt1 = OAreaElems[Lv1 * 3]; Lt2 = OAreaElems[Lv1 * 3 + 1]; Lt3 = OAreaElems[Lv1 * 3 + 2];
                                    LUc1 = (OU[Lt1] + OU[Lt2] + OU[Lt3]) / 3.0f;
                                    LVc1 = (OV[Lt1] + OV[Lt2] + OV[Lt3]) / 3.0f;
                                    LPc1 = (OP[Lt1] + OP[Lt2] + OP[Lt3]) / 3.0f;
                                    LSc1 = (OS[Lt1] + OS[Lt2] + OS[Lt3]) / 3.0f;
                                    LKc1 = (OK[Lt1] + OK[Lt2] + OK[Lt3]) / 3.0f;
                                    //
                                    Lz1 = OAreaElems[Lv2 * 3]; Lz2 = OAreaElems[Lv2 * 3 + 1]; Lz3 = OAreaElems[Lv2 * 3 + 2];
                                    LUc2 = (OU[Lz1] + OU[Lz2] + OU[Lz3]) / 3.0f;
                                    LVc2 = (OV[Lz1] + OV[Lz2] + OV[Lz3]) / 3.0f;
                                    LPc2 = (OP[Lz1] + OP[Lz2] + OP[Lz3]) / 3.0f;
                                    LSc2 = (OS[Lz1] + OS[Lz2] + OS[Lz3]) / 3.0f;
                                    LKc2 = (OK[Lz1] + OK[Lz2] + OK[Lz3]) / 3.0f;
                                    //значения производных в точке пересечения граней
                                    Ls2 = 2 * LS;
                                    Ldudx = ((LUc1 - LUc2) * ly01 + (OU[Lp1] - OU[p0]) * ly23) / Ls2;
                                    Ldudy = ((LUc1 - LUc2) * lx10 + (OU[Lp1] - OU[p0]) * lx32) / Ls2;
                                    Ldvdx = ((LVc1 - LVc2) * ly01 + (OV[Lp1] - OV[p0]) * ly23) / Ls2;
                                    Ldvdy = ((LVc1 - LVc2) * lx10 + (OV[Lp1] - OV[p0]) * lx32) / Ls2;
                                    Ldpdx = ((LPc1 - LPc2) * ly01 + (OP[Lp1] - OP[p0]) * ly23) / Ls2;
                                    Ldpdy = ((LPc1 - LPc2) * lx10 + (OP[Lp1] - OP[p0]) * lx32) / Ls2;
                                    Ldsdx = ((LSc1 - LSc2) * ly01 + (OS[Lp1] - OS[p0]) * ly23) / Ls2;
                                    Ldsdy = ((LSc1 - LSc2) * lx10 + (OS[Lp1] - OS[p0]) * lx32) / Ls2;
                                    Ldkdx = ((LKc1 - LKc2) * ly01 + (OK[Lp1] - OK[p0]) * ly23) / Ls2;
                                    Ldkdy = ((LKc1 - LKc2) * lx10 + (OK[Lp1] - OK[p0]) * lx32) / Ls2;
                                    //внешняя нормаль к грани КО (контуру КО)
                                    Lnx = ONx[j]; Lny = ONy[j];
                                    ////значение функций в точке пересечения грани КО и основной грани
                                    Lalpha = OAlpha[j];
                                    LUcr = Lalpha * OU[p0] + (1 - Lalpha) * OU[Lp1];
                                    LVcr = Lalpha * OV[p0] + (1 - Lalpha) * OV[Lp1];
                                    LPcr = Lalpha * OP[p0] + (1 - Lalpha) * OP[Lp1];
                                    LScr = Lalpha * OS[p0] + (1 - Lalpha) * OS[Lp1];
                                    LNucr = Lalpha * OnuT[p0] + (1 - Lalpha) * OnuT[Lp1] + (float)nu_mol;
                                    LKcr = Lalpha * OK[p0] + (1 - Lalpha) * OK[Lp1];
                                    LEcr = Lalpha * OE[p0] + (1 - Lalpha) * OE[Lp1];
                                    //
                                    wx = (float)(tau * (LUcr * Ldudx + LVcr * Ldudy + 1.0f / rho_w * Ldpdx + 2.0f / 3.0f * Ldkdx));
                                    wy = (float)(tau * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0f / rho_w * Ldpdy + 2.0f / 3.0f * Ldkdy));
                                    wk = (float)tau * (LUcr * Ldkdx + LVcr * Ldkdy - (LNucr * (2.0f * Ldudx * Ldudx + (Ldvdx + Ldudy) * (Ldvdx + Ldudy) + 2.0f * Ldvdy * Ldvdy)) - LEcr);
                                    //длина текущего фрагмента внешнего контура КО
                                    LLk = OLk[j];
                                    //
                                    //расчет потоков
                                    LpressU = -(float)(1.0f / rho_w * LPcr * Lnx - 2.0f / 3.0f * LKcr * Lnx);
                                    LconvU = -LUcr * LUcr * Lnx - (LUcr * LVcr) * Lny;
                                    LdiffU = (float)(nu_mol + LNucr) * (2.0f * Ldudx * Lnx - 2.0f / 3.0f * (Ldudx + Ldvdy) * Lnx + Ldudy * Lny + Ldvdx * Lny);
                                    LregU1 = 2.0f * LUcr * wx * Lnx + 2.0f / 3.0f * wk * Lnx;
                                    LregU2 = (LVcr * wx + LUcr * wy) * Lny;
                                    LregU = LregU1 + LregU2;
                                    LsummU += (LconvU + LdiffU + LregU + LpressU) * LLk;
                                    //                  
                                    LpressV = (float)(-1.0f / rho_w * LPcr * Lny - 2.0f / 3.0f * LKcr * Lny);
                                    LconvV = -(LUcr * LVcr) * Lnx - LVcr * LVcr * Lny;
                                    LdiffV = (float)(nu_mol + LNucr) * (2.0f * Ldvdy * Lny - 2.0f / 3.0f * (Ldudx + Ldvdy) * Lny + Ldvdx * Lnx + Ldudy * Lnx);
                                    LregV1 = 2.0f * LVcr * wy * Lny + 2.0f / 3.0f * wk * Lny;
                                    LregV2 = (LVcr * wx + LUcr * wy) * Lnx;
                                    LregV = LregV1 + LregV2;
                                    LsummV += (LconvV + LdiffV + LregV + LpressV) * LLk;
                                    //
                                    LconvS = -(float)(LScr * (LUcr + W * SinJ) * Lnx - LScr * (LVcr - W * CosJ) * Lny);
                                    LdiffS = LNucr * (Ldsdx * Lnx + Ldsdy * Lny);
                                    LregS = LScr * (wx * Lnx + wy * Lny);
                                    LsummS += (LconvS + LdiffS + LregS) * LLk;
                                }
                                //
                                OU[p0] = OU[p0] + (float)dt / OS0[p0] * LsummU;
                                OV[p0] = OV[p0] + (float)dt / OS0[p0] * LsummV;
                                OS[p0] = OS[p0] + (float)dt / OS0[p0] * LsummS;

                            }
                            if (c + width == CV2Length)
                            {
                                for (k = 0; k < CVWLength; k++)
                                {
                                    i = c + width + k;
                                    LsummU = 0;//потоки U скорости
                                    LsummV = 0;//потоки V скорости
                                    LsummS = 0;//потоки s концентрации
                                    //
                                    p0 = OCV[Num[i]];
                                    jj = Num[i + 1] - Num[i] - 1; //количество КО, связанных с данным узлом
                                    for (j = Num[i]; j < Num[i + 1] - 1; j++)
                                    {
                                        lx10 = OLx10[j]; lx32 = OLx32[j];
                                        ly01 = OLy01[j]; ly23 = OLy23[j];
                                        //площадь
                                        LS = OSS[j];
                                        //сосоедние элементы
                                        Lv1 = OCV[(j - Num[i] + 1) % jj + Num[i] + 1];
                                        Lv2 = OCV[j + 1];
                                        //вторая точка общей грани
                                        Lp1 = OP1[j];
                                        //находим значения функций в центрах масс 1ого и 2ого треугольника как средние значения по элементу
                                        Lt1 = OAreaElems[Lv1 * 3]; Lt2 = OAreaElems[Lv1 * 3 + 1]; Lt3 = OAreaElems[Lv1 * 3 + 2];
                                        LUc1 = (OU[Lt1] + OU[Lt2] + OU[Lt3]) / 3.0f;
                                        LVc1 = (OV[Lt1] + OV[Lt2] + OV[Lt3]) / 3.0f;
                                        LPc1 = (OP[Lt1] + OP[Lt2] + OP[Lt3]) / 3.0f;
                                        LSc1 = (OS[Lt1] + OS[Lt2] + OS[Lt3]) / 3.0f;
                                        LKc1 = (OK[Lt1] + OK[Lt2] + OK[Lt3]) / 3.0f;
                                        //
                                        Lz1 = OAreaElems[Lv2 * 3]; Lz2 = OAreaElems[Lv2 * 3 + 1]; Lz3 = OAreaElems[Lv2 * 3 + 2];
                                        LUc2 = (OU[Lz1] + OU[Lz2] + OU[Lz3]) / 3.0f;
                                        LVc2 = (OV[Lz1] + OV[Lz2] + OV[Lz3]) / 3.0f;
                                        LPc2 = (OP[Lz1] + OP[Lz2] + OP[Lz3]) / 3.0f;
                                        LSc2 = (OS[Lz1] + OS[Lz2] + OS[Lz3]) / 3.0f;
                                        LKc2 = (OK[Lz1] + OK[Lz2] + OK[Lz3]) / 3.0f;
                                        //значения производных в точке пересечения граней
                                        Ls2 = 2 * LS;
                                        Ldudx = ((LUc1 - LUc2) * ly01 + (OU[Lp1] - OU[p0]) * ly23) / Ls2;
                                        Ldudy = ((LUc1 - LUc2) * lx10 + (OU[Lp1] - OU[p0]) * lx32) / Ls2;
                                        Ldvdx = ((LVc1 - LVc2) * ly01 + (OV[Lp1] - OV[p0]) * ly23) / Ls2;
                                        Ldvdy = ((LVc1 - LVc2) * lx10 + (OV[Lp1] - OV[p0]) * lx32) / Ls2;
                                        Ldpdx = ((LPc1 - LPc2) * ly01 + (OP[Lp1] - OP[p0]) * ly23) / Ls2;
                                        Ldpdy = ((LPc1 - LPc2) * lx10 + (OP[Lp1] - OP[p0]) * lx32) / Ls2;
                                        Ldsdx = ((LSc1 - LSc2) * ly01 + (OS[Lp1] - OS[p0]) * ly23) / Ls2;
                                        Ldsdy = ((LSc1 - LSc2) * lx10 + (OS[Lp1] - OS[p0]) * lx32) / Ls2;
                                        Ldkdx = ((LKc1 - LKc2) * ly01 + (OK[Lp1] - OK[p0]) * ly23) / Ls2;
                                        Ldkdy = ((LKc1 - LKc2) * lx10 + (OK[Lp1] - OK[p0]) * lx32) / Ls2;
                                        //внешняя нормаль к грани КО (контуру КО)
                                        Lnx = ONx[j]; Lny = ONy[j];
                                        ////значение функций в точке пересечения грани КО и основной грани
                                        Lalpha = OAlpha[j];
                                        LUcr = Lalpha * OU[p0] + (1 - Lalpha) * OU[Lp1];
                                        LVcr = Lalpha * OV[p0] + (1 - Lalpha) * OV[Lp1];
                                        LPcr = Lalpha * OP[p0] + (1 - Lalpha) * OP[Lp1];
                                        LScr = Lalpha * OS[p0] + (1 - Lalpha) * OS[Lp1];
                                        LNucr = Lalpha * OnuT[p0] + (1 - Lalpha) * OnuT[Lp1] + (float)nu_mol;
                                        LKcr = Lalpha * OK[p0] + (1 - Lalpha) * OK[Lp1];
                                        LEcr = Lalpha * OE[p0] + (1 - Lalpha) * OE[Lp1];
                                        //
                                        wx = (float)(tau * (LUcr * Ldudx + LVcr * Ldudy + 1.0f / rho_w * Ldpdx + 2.0f / 3.0f * Ldkdx));
                                        wy = (float)(tau * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0f / rho_w * Ldpdy + 2.0f / 3.0f * Ldkdy));
                                        wk = (float)tau * (LUcr * Ldkdx + LVcr * Ldkdy - (LNucr * (2.0f * Ldudx * Ldudx + (Ldvdx + Ldudy) * (Ldvdx + Ldudy) + 2.0f * Ldvdy * Ldvdy)) - LEcr);
                                        //длина текущего фрагмента внешнего контура КО
                                        LLk = OLk[j];
                                        //
                                        //расчет потоков
                                        LpressU = (float)(-1.0f / rho_w * LPcr * Lnx - 2.0f / 3.0f * LKcr * Lnx);
                                        LconvU = (float)(-LUcr * LUcr * Lnx - (LUcr * LVcr) * Lny);
                                        LdiffU = (float)(OCV_Tau[k] / rho_w * Lny - nu_mol * 2.0 / 3.0 * (Ldudx + Ldvdy) * Lnx);
                                        LregU1 = 2.0f * LUcr * wx * Lnx + 2.0f / 3.0f * wk * Lnx;
                                        LregU2 = (LVcr * wx + LUcr * wy) * Lny;
                                        LregU = LregU1 + LregU2;
                                        LsummU += (LconvU + LdiffU + LregU + LpressU) * LLk;
                                        //                  
                                        LpressV = (float)(-1.0 / rho_w * LPcr * Lny - 2.0 / 3.0 * LKcr * Lny);
                                        LconvV = -(LUcr * LVcr) * Lnx - LVcr * LVcr * Lny;
                                        LdiffV = (float)(OCV_Tau[k] / rho_w * Lnx - nu_mol * 2.0 / 3.0 * (Ldudx + Ldvdy) * Lny);
                                        LregV1 = (float)(2.0 * LVcr * wy * Lny + 2.0 / 3.0 * wk * Lny);
                                        LregV2 = (LVcr * wx + LUcr * wy) * Lnx;
                                        LregV = LregV1 + LregV2;
                                        LsummV += (LconvV + LdiffV + LregV + LpressV) * LLk;
                                        //
                                        LconvS = (float)(-LScr * (LUcr + W * SinJ) * Lnx - LScr * (LVcr - W * CosJ) * Lny);
                                        LdiffS = LNucr * (Ldsdx * Lnx + Ldsdy * Lny);
                                        LregS = LScr * (wx * Lnx + wy * Lny);
                                        LsummS += (LconvS + LdiffS + LregS) * LLk;
                                    }
                                    //
                                    OU[p0] = OU[p0] + (float)dt / OS0[p0] * LsummU;
                                    OV[p0] = OV[p0] + (float)dt / OS0[p0] * LsummV;
                                    OS[p0] = OS[p0] + (float)dt / OS0[p0] * LsummS;
                                }
                            }
                        }
                        //
                        //ГУ справа - снос
                        for (int i = 0; i < NRight - 2; i++)
                        {
                            knot = RightKnotsList[i][0];
                            //
                            OU[knot] = OU[knot - _Ny];
                            OV[knot] = OV[knot - _Ny];
                            OS[knot] = OS[knot - _Ny];
                        }
                        //если задача со свободной поверхностью
                        if (surf_flag)
                        {
                            //ГУ на верхней стенке 
                            for (int i = 1; i < NTop; i++)
                            {
                                knot = BTopKnots[i];
                                OU[knot] = OU[knot - 1];
                                OV[knot] = OV[knot - 1];
                                OS[knot] = OS[knot - 1];
                            }

                        }
                        //

                        float LsummK = 0, LsummE = 0, LrightK = 0, LrightE = 0; //потоки K, E и правые части
                        float LEc2, ldudx, ldudy, ldvdx, ldvdy, Ldedx, Ldedy, LconvK, LdiffK, LregK, LconvE, LdiffE, LEc1, LregE, we, y_p_plus;
                        for (int gl = 0; gl < globalSize[0]; gl++)
                        {
                            int i;
                            int c = gl * width; // NX*NY / width
                            for (k = 0; k < width; k++)
                            {
                                i = c + k;
                                //
                                LsummK = 0;//потоки K скорости
                                LsummE = 0;//потоки E скорости
                                ldudx = 0; ldudy = 0; ldvdx = 0; ldvdy = 0;
                                //
                                p0 = OCV[Num[i]];
                                jj = Num[i + 1] - Num[i] - 1; //количество КО, связанных с данным узлом
                                for (j = Num[i]; j < Num[i + 1] - 1; j++)
                                {
                                    lx10 = OLx10[j]; lx32 = OLx32[j];
                                    ly01 = OLy01[j]; ly23 = OLy23[j];
                                    //площадь
                                    LS = OSS[j];
                                    //сосоедние элементы
                                    Lv1 = OCV[(j - Num[i] + 1) % jj + Num[i] + 1];
                                    Lv2 = OCV[j + 1];
                                    //вторая точка общей грани
                                    Lp1 = OP1[j];
                                    //находим значения функций в центрах масс 1ого и 2ого треугольника как средние значения по элементу
                                    Lt1 = OAreaElems[Lv1 * 3]; Lt2 = OAreaElems[Lv1 * 3 + 1]; Lt3 = OAreaElems[Lv1 * 3 + 2];
                                    LUc1 = (OU[Lt1] + OU[Lt2] + OU[Lt3]) / 3.0f;
                                    LVc1 = (OV[Lt1] + OV[Lt2] + OV[Lt3]) / 3.0f;
                                    LPc1 = (OP[Lt1] + OP[Lt2] + OP[Lt3]) / 3.0f;
                                    LKc1 = (OK[Lt1] + OK[Lt2] + OK[Lt3]) / 3.0f;
                                    LEc1 = (OE[Lt1] + OE[Lt2] + OE[Lt3]) / 3.0f;
                                    //
                                    Lz1 = OAreaElems[Lv2 * 3]; Lz2 = OAreaElems[Lv2 * 3 + 1]; Lz3 = OAreaElems[Lv2 * 3 + 2];
                                    LUc2 = (OU[Lz1] + OU[Lz2] + OU[Lz3]) / 3.0f;
                                    LVc2 = (OV[Lz1] + OV[Lz2] + OV[Lz3]) / 3.0f;
                                    LPc2 = (OP[Lz1] + OP[Lz2] + OP[Lz3]) / 3.0f;
                                    LKc2 = (OK[Lz1] + OK[Lz2] + OK[Lz3]) / 3.0f;
                                    LEc2 = (OE[Lz1] + OE[Lz2] + OE[Lz3]) / 3.0f;
                                    //значения производных в точке пересечения граней
                                    Ls2 = 2 * LS;
                                    Ldudx = ((LUc1 - LUc2) * ly01 + (OU[Lp1] - OU[p0]) * ly23) / Ls2;
                                    Ldudy = ((LUc1 - LUc2) * lx10 + (OU[Lp1] - OU[p0]) * lx32) / Ls2;
                                    Ldvdx = ((LVc1 - LVc2) * ly01 + (OV[Lp1] - OV[p0]) * ly23) / Ls2;
                                    Ldvdy = ((LVc1 - LVc2) * lx10 + (OV[Lp1] - OV[p0]) * lx32) / Ls2;
                                    Ldpdx = ((LPc1 - LPc2) * ly01 + (OP[Lp1] - OP[p0]) * ly23) / Ls2;
                                    Ldpdy = ((LPc1 - LPc2) * lx10 + (OP[Lp1] - OP[p0]) * lx32) / Ls2;
                                    Ldkdx = ((LKc1 - LKc2) * ly01 + (OK[Lp1] - OK[p0]) * ly23) / Ls2;
                                    Ldkdy = ((LKc1 - LKc2) * lx10 + (OK[Lp1] - OK[p0]) * lx32) / Ls2;
                                    Ldedx = ((LEc1 - LEc2) * ly01 + (OE[Lp1] - OE[p0]) * ly23) / Ls2;
                                    Ldedy = ((LEc1 - LEc2) * lx10 + (OE[Lp1] - OE[p0]) * lx32) / Ls2;
                                    //внешняя нормаль к грани КО (контуру КО)
                                    Lnx = ONx[j]; Lny = ONy[j];
                                    ////значение функций в точке пересечения грани КО и основной грани
                                    Lalpha = OAlpha[j];
                                    LUcr = Lalpha * OU[p0] + (1 - Lalpha) * OU[Lp1];
                                    LVcr = Lalpha * OV[p0] + (1 - Lalpha) * OV[Lp1];
                                    LNucr = Lalpha * OnuT[p0] + (1 - Lalpha) * OnuT[Lp1] + (float)nu_mol;
                                    LKcr = Lalpha * OK[p0] + (1 - Lalpha) * OK[Lp1];
                                    LEcr = Lalpha * OE[p0] + (1 - Lalpha) * OE[Lp1];
                                    //
                                    wx = (float)(tau * (LUcr * Ldudx + LVcr * Ldudy + 1.0 / rho_w * Ldpdx + 2.0 / 3.0 * Ldkdx));
                                    wy = (float)(tau * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0 / rho_w * Ldpdy + 2.0 / 3.0 * Ldkdy));
                                    wk = (float)(tau * (LUcr * Ldkdx + LVcr * Ldkdy - (LNucr * (2 * Ldudx * Ldudx + (Ldvdx + Ldudy) * (Ldvdx + Ldudy) + 2 * Ldvdy * Ldvdy)) - LEcr));
                                    we = (float)(tau * (LUcr * Ldedx + LVcr * Ldedy - (LEcr / LKcr * (C_e1 * LNucr * (2 * Ldudx * Ldudx + (Ldvdx + Ldudy) * (Ldvdx + Ldudy) + 2 * Ldvdy * Ldvdy)) - C_e2 * LEcr)));
                                    //длина текущего фрагмента внешнего контура КО
                                    LLk = OLk[j];
                                    //
                                    //расчет потоков
                                    LconvK = -LUcr * LKcr * Lnx - LVcr * LKcr * Lny;
                                    LdiffK = (float)(LNucr / sigma_k + nu_mol) * (Ldkdx * Lnx + Ldkdy * Lny);
                                    LregK = LKcr * wx * Lnx + LKcr * wy * Lny + LUcr * wk * Lnx + LVcr * wk * Lny;
                                    //
                                    LsummK += (LconvK + LdiffK + LregK) * LLk;
                                    //                  
                                    LconvE = -LUcr * LEcr * Lnx - LVcr * LEcr * Lny;
                                    LdiffE = (float)(LNucr / sigma_e + nu_mol) * (Ldedx * Lnx + Ldedy * Lny);
                                    LregE = LEcr * wx * Lnx + LEcr * wy * Lny + LUcr * we * Lnx + LVcr * we * Lny;
                                    // 
                                    LsummE += (LconvE + LdiffE + LregE) * LLk;
                                    //
                                    // компоненты производных для Pk
                                    ldudx += LUcr * Lnx * LLk;
                                    ldudy += LUcr * Lny * LLk;
                                    ldvdx += LVcr * Lnx * LLk;
                                    ldvdy += LVcr * Lny * LLk;
                                }
                                //
                                ldudx /= OS0[p0];
                                ldudy /= OS0[p0];
                                ldvdx /= OS0[p0];
                                ldvdy /= OS0[p0];
                                //
                                OPk[p0] = OnuT[p0] * (2 * ldudx * ldudx + (ldvdx + ldudy) * (ldvdx + ldudy) + 2 * ldvdy * ldvdy);
                                LrightK = (OPk[p0] - OE[p0]);
                                LrightE = (float)(OE[p0] / OK[p0] * (C_e1 * OPk[p0] - C_e2 * OE[p0]));
                                //
                                OK[p0] = (float)(OK[p0] + dt / OS0[p0] * LsummK + dt * LrightK);
                                OE[p0] = (float)(OE[p0] + dt / OS0[p0] * LsummE + dt * LrightE);
                                OnuT[p0] = (float)(C_m * OK[p0] * OK[p0] / (OE[p0] + 1e-6));
                                if (OnuT[p0] < nu_mol)
                                    OnuT[p0] = (float)nu_mol;


                            }
                            if (c + width == CV2Length)
                            {
                                for (k = 0; k < CVWLength; k++)
                                {
                                    i = c + width + k;
                                    LsummK = 0;//потоки K скорости
                                    LsummE = 0;//потоки E скорости
                                    ldudx = 0; ldudy = 0; ldvdx = 0; ldvdy = 0;
                                    //
                                    p0 = OCV[Num[i]];
                                    jj = Num[i + 1] - Num[i] - 1; //количество КО, связанных с данным узлом
                                    for (j = Num[i]; j < Num[i + 1] - 1; j++)
                                    {
                                        lx10 = OLx10[j]; lx32 = OLx32[j];
                                        ly01 = OLy01[j]; ly23 = OLy23[j];
                                        //площадь
                                        LS = OSS[j];
                                        //сосоедние элементы
                                        Lv1 = OCV[(j - Num[i] + 1) % jj + Num[i] + 1];
                                        Lv2 = OCV[j + 1];
                                        //вторая точка общей грани
                                        Lp1 = OP1[j];
                                        //находим значения функций в центрах масс 1ого и 2ого треугольника как средние значения по элементу
                                        Lt1 = OAreaElems[Lv1 * 3]; Lt2 = OAreaElems[Lv1 * 3 + 1]; Lt3 = OAreaElems[Lv1 * 3 + 2];
                                        LUc1 = (OU[Lt1] + OU[Lt2] + OU[Lt3]) / 3.0f;
                                        LVc1 = (OV[Lt1] + OV[Lt2] + OV[Lt3]) / 3.0f;
                                        LPc1 = (OP[Lt1] + OP[Lt2] + OP[Lt3]) / 3.0f;
                                        LKc1 = (OK[Lt1] + OK[Lt2] + OK[Lt3]) / 3.0f;
                                        LEc1 = (OE[Lt1] + OE[Lt2] + OE[Lt3]) / 3.0f;
                                        //
                                        Lz1 = OAreaElems[Lv2 * 3]; Lz2 = OAreaElems[Lv2 * 3 + 1]; Lz3 = OAreaElems[Lv2 * 3 + 2];
                                        LUc2 = (OU[Lz1] + OU[Lz2] + OU[Lz3]) / 3.0f;
                                        LVc2 = (OV[Lz1] + OV[Lz2] + OV[Lz3]) / 3.0f;
                                        LPc2 = (OP[Lz1] + OP[Lz2] + OP[Lz3]) / 3.0f;
                                        LKc2 = (OK[Lz1] + OK[Lz2] + OK[Lz3]) / 3.0f;
                                        LEc2 = (OE[Lz1] + OE[Lz2] + OE[Lz3]) / 3.0f;
                                        //значения производных в точке пересечения граней
                                        Ls2 = 2 * LS;
                                        Ldudx = ((LUc1 - LUc2) * ly01 + (OU[Lp1] - OU[p0]) * ly23) / Ls2;
                                        Ldudy = ((LUc1 - LUc2) * lx10 + (OU[Lp1] - OU[p0]) * lx32) / Ls2;
                                        Ldvdx = ((LVc1 - LVc2) * ly01 + (OV[Lp1] - OV[p0]) * ly23) / Ls2;
                                        Ldvdy = ((LVc1 - LVc2) * lx10 + (OV[Lp1] - OV[p0]) * lx32) / Ls2;
                                        Ldpdx = ((LPc1 - LPc2) * ly01 + (OP[Lp1] - OP[p0]) * ly23) / Ls2;
                                        Ldpdy = ((LPc1 - LPc2) * lx10 + (OP[Lp1] - OP[p0]) * lx32) / Ls2;
                                        Ldkdx = ((LKc1 - LKc2) * ly01 + (OK[Lp1] - OK[p0]) * ly23) / Ls2;
                                        Ldkdy = ((LKc1 - LKc2) * lx10 + (OK[Lp1] - OK[p0]) * lx32) / Ls2;
                                        //внешняя нормаль к грани КО (контуру КО)
                                        Lnx = ONx[j]; Lny = ONy[j];
                                        ////значение функций в точке пересечения грани КО и основной грани
                                        Lalpha = OAlpha[j];
                                        LUcr = Lalpha * OU[p0] + (1 - Lalpha) * OU[Lp1];
                                        LVcr = Lalpha * OV[p0] + (1 - Lalpha) * OV[Lp1];
                                        LNucr = Lalpha * OnuT[p0] + (1 - Lalpha) * OnuT[Lp1] + (float)nu_mol;
                                        LKcr = Lalpha * OK[p0] + (1 - Lalpha) * OK[Lp1];
                                        LEcr = Lalpha * OE[p0] + (1 - Lalpha) * OE[Lp1];
                                        //
                                        wx = (float)(tau * (LUcr * Ldudx + LVcr * Ldudy + 1.0 / rho_w * Ldpdx + 2.0 / 3.0 * Ldkdx));
                                        wy = (float)(tau * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0 / rho_w * Ldpdy + 2.0 / 3.0 * Ldkdy));
                                        wk = (float)(tau * (LUcr * Ldkdx + LVcr * Ldkdy - (LNucr * (2 * Ldudx * Ldudx + (Ldvdx + Ldudy) * (Ldvdx + Ldudy) + 2 * Ldvdy * Ldvdy)) - LEcr));
                                        //длина текущего фрагмента внешнего контура КО
                                        LLk = OLk[j];
                                        //
                                        //расчет потоков
                                        LconvK = -LUcr * LKcr * Lnx - LVcr * LKcr * Lny;
                                        LdiffK = (float)(LNucr / sigma_k + nu_mol) * (Ldkdx * Lnx + Ldkdy * Lny);
                                        LregK = LKcr * wx * Lnx + LKcr * wy * Lny + LUcr * wk * Lnx + LVcr * wk * Lny;
                                        //
                                        LsummK += (LconvK + LdiffK + LregK) * LLk;
                                    }
                                    //
                                    y_p_plus = (float)(cm14 * Math.Sqrt(OK[p0]) * CV_WallKnotsDistance[k] / nu_mol);
                                    OPk[p0] = 0;
                                    if (y_p_plus > y_p_0)
                                    {
                                        OE[p0] = (float)(cm14 * cm14 * cm14 * OK[p0] * Math.Sqrt(OK[p0]) / kappa / CV_WallKnotsDistance[k]);
                                        OPk[p0] = OE[p0];
                                    }
                                    else
                                        OE[p0] = (float)(2.0 * OK[p0] / CV_WallKnotsDistance[k] / CV_WallKnotsDistance[k] * nu_mol);
                                    //
                                    LrightK = (OPk[p0] - OE[p0]);
                                    //
                                    OK[p0] = OK[p0] + (float)(dt / OS0[p0] * LsummK + dt * LrightK);
                                    OnuT[p0] = (float)(C_m * OK[p0] * OK[p0] / (OE[p0] + 1e-6));
                                    if (OnuT[p0] < nu_mol)
                                        OnuT[p0] = (float)nu_mol;


                                }
                            }
                        }
                        //
                        //ГУ справа снос
                        for (int i = 0; i < NRight; i++)
                        {
                            knot = BRightKnots[i];
                            //
                            OK[knot] = OK[knot - NRight];
                            OE[knot] = OE[knot - NRight];
                        }
                        //
                        if (surf_flag)
                        {
                            for (int i = 1; i < NTop; i++)
                            {
                                knot = BTopKnots[i];
                                OK[knot] = OK[knot - 1];
                                OE[knot] = OE[knot - 1];
                            }
                        }
                        //
                        for (int i = 0; i < U.Length; i++)
                        {
                            K[i] = Convert.ToDouble(OK[i]);
                            E[i] = Convert.ToDouble(OE[i]);
                            nuT[i] = Convert.ToDouble(OnuT[i]);
                        }
                        #endregion
                    }
                    else
                    {
                        #region OpenCL
                        //-------------------- Расчет UVS
                        stopCalc.Start();
                        //Вызов ядра
                        commands.Execute(kernelUV, null, globalSize, null, null);
                        //Ожидание окончания выполнения программы
                        commands.Finish();
                        stopCalc.Stop();
                        //// чтение искомой функции из буфера kernel-а
                        stopCopy.Start();
                        commands.ReadFromBuffer(Ou, ref OU, true, null);
                        commands.ReadFromBuffer(Ov, ref OV, true, null);
                        commands.ReadFromBuffer(Os, ref OS, true, null);
                        stopCopy.Stop();
                        //ГУ справа - снос
                        for (int i = 0; i < NRight - 2; i++)
                        {
                            knot = RightKnotsList[i][0];
                            //
                            OU[knot] = OU[knot - _Ny];
                            OV[knot] = OV[knot - _Ny];
                            OS[knot] = OS[knot - _Ny];
                        }
                        //если задача со свободной поверхностью
                        if (surf_flag)
                        {
                            //ГУ на верхней стенке 
                            for (int i = 1; i < NTop; i++)
                            {
                                knot = BTopKnots[i];
                                OU[knot] = OU[knot - 1];
                                OV[knot] = OV[knot - 1];
                                OS[knot] = OS[knot - 1];
                            }

                        }
                        stopCopy.Start();
                        commands.WriteToBuffer(OU, Ou, true, null);
                        commands.WriteToBuffer(OV, Ov, true, null);
                        commands.WriteToBuffer(OS, Ov, true, null);
                        stopCopy.Stop();
                        //--------------------- Расчет K-E
                        stopCalc.Start();
                        //Вызов ядра
                        commands.Execute(kernelKE, null, globalSize, null, null);
                        //Ожидание окончания выполнения программы
                        commands.Finish();
                        stopCalc.Stop();
                        //
                        stopCopy.Start();
                        commands.ReadFromBuffer(Ok, ref OK, true, null);
                        commands.ReadFromBuffer(Oe, ref OE, true, null);
                        stopCopy.Stop();
                        //
                        //ГУ справа снос
                        for (int i = 0; i < NRight; i++)
                        {
                            knot = BRightKnots[i];
                            //
                            OK[knot] = OK[knot - NRight];
                            OE[knot] = OE[knot - NRight];
                        }
                        //
                        if (surf_flag)
                        {
                            for (int i = 1; i < NTop; i++)
                            {
                                knot = BTopKnots[i];
                                OK[knot] = OK[knot - 1];
                                OE[knot] = OE[knot - 1];
                            }
                        }
                        // вычисление напряжения по пристеночной функции
                        for (int i = 0; i < CV_WallKnots.Length; i++)
                        {
                            knot = CV_WallKnots[i][0];
                            //CV_WallTau[i] = WallFuncSharpPlus(knot, CV_WallKnotsDistance[i]);//шероховатая стенка по Луцкому, установка по Снегиреву
                            //CV_WallTau[i] = WallFuncSnegirev(knot, CV_WallKnotsDistance[i]);// гладкая стенка по Снегиреву
                            //CV_WallTau[i] = WallFuncPlus(knot, CV_WallKnotsDistance[i]);// гладкая стенка по Луцкому
                            OCV_Tau[i] = (float)WallFunc(knot, CV_WallKnotsDistance[i]);// гладкая стенка по Волкову упрощ
                            //CV_WallTau[i] = WallFuncNewton(knot, CV_WallKnotsDistance[i]);// гладкая стенка по Волкову Ньютон
                        }
                        stopCopy.Start();
                        commands.WriteToBuffer(OK, Ok, true, null);
                        commands.WriteToBuffer(OE, Oe, true, null);
                        commands.WriteToBuffer(OCV_Tau, Ocv_tau, true, null);
                        stopCopy.Stop();
                        #endregion
                    }
                    //
                    //выход из цикла если ошибка меньше или равно errP
                    if (MaxError <= errP)
                    {
                        Iter = iteration + 1;
                        //break;
                    }
                    //
                    Iter = iteration + 1;
                }
                if (false)
                {
                    commands.ReadFromBuffer(Ou, ref OU, true, null);
                    commands.ReadFromBuffer(Ov, ref OV, true, null);
                    commands.ReadFromBuffer(Os, ref OS, true, null);
                    commands.ReadFromBuffer(Ok, ref OK, true, null);
                    commands.ReadFromBuffer(Oe, ref OE, true, null);
                    commands.ReadFromBuffer(Onut, ref OnuT, true, null);
                    commands.ReadFromBuffer(Opk, ref OPk, true, null);
                }
                //конвертация в double
                for (int i = 0; i < U.Length; i++)
                {
                    U[i] = Convert.ToDouble(OU[i]);
                    V[i] = Convert.ToDouble(OV[i]);
                    S[i] = Convert.ToDouble(OS[i]);
                    K[i] = Convert.ToDouble(OK[i]);
                    E[i] = Convert.ToDouble(OE[i]);
                    nuT[i] = Convert.ToDouble(OnuT[i]);
                    Pk[i] = Convert.ToDouble(OPk[i]);
                }

                ////очищение памяти в порядке, обратном созданию
                Os.Dispose();
                Ov.Dispose();
                Ou.Dispose();
                Onut.Dispose();
                Oe.Dispose();
                Ok.Dispose();
                Op.Dispose();
                Ocv_WallKnotsDistance.Dispose();
                Ocv_tau.Dispose();
                Os0.Dispose();
                Olk.Dispose();
                Oalpha.Dispose();
                Ony.Dispose();
                Onx.Dispose();
                OareaElems.Dispose();
                Op1.Dispose();
                Oss.Dispose();
                Oly23.Dispose();
                Oly01.Dispose();
                Olx32.Dispose();
                Olx10.Dispose();
                Onum.Dispose();
                Ocv.Dispose();
                //
                kernelKE.Dispose();
                kernelUV.Dispose();
                program.Dispose();
                commands.Dispose();
                context.Dispose();
                #endregion
                //
                timeSpanCalc = stopCalc.Elapsed;
                timeSpanCopy = stopCopy.Elapsed;

            }
            //
            for (int i = 0; i < CountKnots; i++)
            {
                buffU[i] = U[i];
                buffV[i] = V[i];
                buffK[i] = K[i];
                buffE[i] = E[i];
                buffS[i] = S[i];
                buffNu[i] = nuT[i];
                #region Сохранение y_plus - отключено
                // y+ по Гришанину
                //double delta = 0.6 * d;
                //if (i < CountKnots - 10)
                //{
                //    double y1 = Mesh.GetNormalDistanceBottom(i);
                //    //double y1 = Y[i] - Y[(i / NLeft) * NLeft];
                //    double f = U[i] * y1 / nu_mol;
                //    double y_pl = 0;
                //    if (f <= 782.4968) // ламинарный слой
                //        y_pl = Math.Sqrt(2 * f);
                //    else  // логарифмический слой
                //    {
                //        double y_i = 39.56;
                //        double F_i = 0, u_i = 0, y_i1 = 0;
                //        for (int h = 0; h < 7; h++)
                //        {
                //            F_i = 2.5 * y_i * (Math.Log(20.0855 * y_i / delta) - 1) - 683.559072;
                //            u_i = 2.5 * Math.Log(20.0855 * y_i / delta);
                //            y_i1 = y_i + (f - F_i) / u_i;
                //            if (Math.Abs(y_i - y_i1) < 0.000001)
                //            {
                //                y_i = y_i1;
                //                break;
                //            }
                //            y_i = y_i1;
                //        }
                //        y_pl = y_i1;
                //    }
                //    //
                //    y_plus[i] = y_pl;
                //}
                //------------------------
                // y+ по Волкову
                //double kp = K[i];
                //double Dy = Y[i] - Y[(i / NLeft) * NLeft];
                //double Du = U[i];
                //double Re = rho_w * cm14 * Math.Sqrt(Math.Abs(kp)) * Dy / mu;
                //// tau
                //double tauw = (rho_w * cm14 * Math.Sqrt(Math.Abs(kp)) * Du) / (1.0 / kappa * Math.Log(8.8 * Re));
                //y_plus[i] = Dy * Math.Sqrt(tauw / rho_w) / nu_mol;
                //-------------------------------------------------
                // по Луцкому с буферным слоем
                //if (i < CountKnots - 10)
                //{
                //    double y1 = Mesh.GetNormalDistanceBottom(i);
                //    double f = U[i] * y1 / nu_mol;
                //    double y_pl = 0;
                //    if (f <= 2) // ламинарный слой
                //        y_pl = Math.Sqrt(2 * f);
                //    else if (f >= 696.68) // логарифмический слой
                //    {
                //        double y_i = 60;
                //        double F_i = 0, u_i = 0, y_i1 = 0;
                //        for (int h = 0; h < 7; h++)
                //        {
                //            F_i = 2.5 * y_i * (Math.Log(y_i / 0.13) - 1) - 73.50481;
                //            u_i = 2.5 * Math.Log(y_i / 0.13);
                //            y_i1 = y_i + (f - F_i) / u_i;
                //            if (Math.Abs(y_i - y_i1) < 0.000001)
                //            {
                //                y_i = y_i1;
                //                break;
                //            }
                //            y_i = y_i1;
                //        }
                //        y_pl = y_i1;
                //    }
                //    else // буферный слой
                //        y_pl = alglib.spline1dcalc(bufF, f);
                //    //
                //    y_plus[i] = y_pl;
                //}
                // --------------------------------------
                // по Снегиреву
                //double dy = Y[i] - Y[(i / NLeft) * NLeft];
                //if (dy > 0)
                //{
                //    double y_p_plus = cm14 * Math.Sqrt(K[i]) * dy / nu_mol;
                //    double u2_tau = 0;
                //    if (y_p_plus > y_p_0)
                //        u2_tau = cm14 * cm14 * K[i];
                //    else
                //        u2_tau = nu_mol * U[i] / (dy + 0.00000001);
                //    double tau_w = u2_tau * rho_w;
                //    y_plus[i] = dy * Math.Sqrt(tau_w / rho_w) / nu_mol;
                //}
                #endregion
            }
            //Iter = iter;
            //расход на входе и выходе из расчетной области
            beginIter = 0;
            Q_in = 0; Q_out = 0;
            for (int k = 0; k < NLeft - 1; k++)
            {
                int a = BLeftKnots[k];
                int b = BLeftKnots[k + 1];
                Q_in += (U[a] + U[b]) * 0.5f * Math.Abs(Y[a] - Y[b]);
            }
            //
            for (int k = 1; k < NRight - 1; k++)
            {
                int a = BRightKnots[k];
                int b = BRightKnots[k + 1];
                Q_out += (U[a] + U[b]) * 0.5f * Math.Abs(Y[a] - Y[b]);
            }
            //
            return iteration;
        }
        //
        private void PressureCalc(ref double MaxError, ref double[] Result, double[] BV2, System.Object lockThis, int iteration, bool Gauss)
        {
            ///------Протестировано ОК
            ////////////////// МКЭ давление /////////////////////
            if (Gauss)
            {
                #region Расчет давления
                // выделение памяти под результат решения задачи
                Result = new double[Mesh.CountKnots];
                //выделяем масивы для локальных правых частей
                if (iteration == 0)
                {
                    ABand.ClearSystem();
                    // основной цикл по конечным элементам
                    // вычисляем локальные матрицы жесткости и производим сборку глобальной матрицы жесткости
                    OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, Mesh.CountElems);
                    Parallel.ForEach(rangePartitioner,
                          (range, loopState) =>
                          {
                              for (int fe = range.Item1; fe < range.Item2; fe++)
                              //for (int fe = 0; fe < Mesh.CountElems; fe++)
                              {
                                  // выделяем массивы для локальных матриц жесткости
                                  double[][] M = new double[3][];
                                  for (int k = 0; k < 3; k++)
                                  {
                                      M[k] = new double[3];
                                  }
                                  //и номера его вершин
                                  int[] LKnots = Mesh.AreaElems[fe];
                                  // нахождение площади треугольника
                                  double LSk = Sk[fe];
                                  // расчитываем геометрию элемента 
                                  double Lb1 = b1[fe];
                                  double Lb2 = b2[fe];
                                  double Lb3 = b3[fe];
                                  double Lc1 = c1[fe];
                                  double Lc2 = c2[fe];
                                  double Lc3 = c3[fe];
                                  // расчет локальной матрицы жесткости для диффузионного члена
                                  M[0][0] = -LSk * (Lb1 * Lb1 + Lc1 * Lc1);
                                  M[0][1] = -LSk * (Lb1 * Lb2 + Lc1 * Lc2);
                                  M[0][2] = -LSk * (Lb1 * Lb3 + Lc1 * Lc3);

                                  M[1][0] = -LSk * (Lb2 * Lb1 + Lc2 * Lc1);
                                  M[1][1] = -LSk * (Lb2 * Lb2 + Lc2 * Lc2);
                                  M[1][2] = -LSk * (Lb2 * Lb3 + Lc2 * Lc3);

                                  M[2][0] = -LSk * (Lb3 * Lb1 + Lc3 * Lc1);
                                  M[2][1] = -LSk * (Lb3 * Lb2 + Lc3 * Lc2);
                                  M[2][2] = -LSk * (Lb3 * Lb3 + Lc3 * Lc3);
                                  lock (lockThis)
                                      ABand.BuildMatrix(M, LKnots);
                              }

                          });
                    //
                    //главные ГУ справа
                    ABand.SetBoundary(BV2, BRightKnots);
                    ABand.Accept(AlgGauss, null, 1);

                }
                ABand.ClearRight();
                R = new double[CountKnots];
                //сборка правой части
                OrderablePartitioner<Tuple<int, int>> rangePartitioner1 = Partitioner.Create(0, Mesh.CountElems);
                Parallel.ForEach(rangePartitioner1,
                      (range, loopState) =>
                      {
                          for (int fe = range.Item1; fe < range.Item2; fe++)
                          //for(int fe=0;fe<Mesh.CountElems;fe++)
                          {

                              //for (int fe = 0; fe < Mesh.CountElem; fe++)
                              //{
                              double[] RR = new double[3];
                              // получаем текущий конечный элемент
                              int[] LKnots = Mesh.AreaElems[fe];
                              int Lm1 = LKnots[0];
                              int Lm2 = LKnots[1];
                              int Lm3 = LKnots[2];
                              // нахождение площади треугольника
                              double LSk = Sk[fe];
                              // расчитываем геометрию элемента 
                              double Lb1 = b1[fe];
                              double Lb2 = b2[fe];
                              double Lb3 = b3[fe];
                              double Lc1 = c1[fe];
                              double Lc2 = c2[fe];
                              double Lc3 = c3[fe];
                              //
                              double LU1 = U[Lm1]; double LU2 = U[Lm2]; double LU3 = U[Lm3];
                              double LV1 = V[Lm1]; double LV2 = V[Lm2]; double LV3 = V[Lm3];
                              //правая часть - неразрывность
                              double LSR = rho_w * LSk / (3 * tau) * ((Lb1 * LU1 + Lb2 * LU2 + Lb3 * LU3) + (Lc1 * LV1 + Lc2 * LV2 + Lc3 * LV3));
                              RR[0] = alpha_n * LSR;
                              RR[1] = alpha_n * LSR;
                              RR[2] = alpha_n * LSR;
                              //правая часть поправка КГД
                              double LBUU = (Lb1 * LU1 + Lb2 * LU2 + Lb3 * LU3) * (LU1 + LU2 + LU3);
                              double LCUV = (Lc1 * LU1 + Lc2 * LU2 + Lc3 * LU3) * (LV1 + LV2 + LV3);
                              double LBVU = (Lb1 * LV1 + Lb2 * LV2 + Lb3 * LV3) * (LU1 + LU2 + LU3);
                              double LCVV = (Lc1 * LV1 + Lc2 * LV2 + Lc3 * LV3) * (LV1 + LV2 + LV3);
                              //
                              RR[0] += (double)(alpha_r * rho_w * LSk / 3.0 * (Lb1 * (LBUU + LCUV) + Lc1 * (LBVU + LCVV)));
                              RR[1] += (double)(alpha_r * rho_w * LSk / 3.0 * (Lb2 * (LBUU + LCUV) + Lc2 * (LBVU + LCVV)));
                              RR[2] += (double)(alpha_r * rho_w * LSk / 3.0 * (Lb3 * (LBUU + LCUV) + Lc3 * (LBVU + LCVV)));
                              //
                              //для отображения невязки
                              R[Lm1] += RR[0];
                              R[Lm2] += RR[1];
                              R[Lm3] += RR[2];
                              //}
                          }

                      });
                //
                ABand.BuildRight(R);
                //ГУ слева
                ABand.BuildRight(BV, BLeftKnots);
                //главные ГУ справа 2
                ABand.BoundConditionsRight(BV2, BRightKnots);
                // решение системы алгебраических уравнений
                ABand.Accept(AlgGauss, null, 2);
                Result = ABand.GetX;
                //для отладки
                for (int i = 0; i < NLeft; i++)
                    R[BLeftKnots[i]] += BV[i];
                for (int i = 0; i < NRight; i++)
                    R[BRightKnots[i]] = 0;

                // релаксация решения, буферизация и вычисление погрешности
                MaxError = 0;//масимальная ошибка в области
                for (int i = 0; i < CountKnots; i++)
                {
                    //релаксация
                    P[i] = (1 - relaxP) * P[i] + relaxP * Result[i];
                    //вычисление погрешности
                    double CurErr = Math.Abs((P[i] - buffP[i]) / P[i]);
                    if (MaxError < CurErr)
                        MaxError = CurErr;
                    ErrP[i] = CurErr;
                    //буферизация
                    buffP[i] = P[i];
                }
                #endregion
            }
            else
            {
                #region Расчет давления
                Sys.ClearSystem();
                if (iteration != 0)
                    Sys.SetX(Result);
                // выделение памяти под результат решения задачи
                Result = new double[Mesh.CountKnots];
                //выделяем масивы для локальных правых частей
                // основной цикл по конечным элементам
                // вычисляем локальные матрицы жесткости и производим сборку глобальной матрицы жесткости
                //OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, Mesh.CountElems);
                //Parallel.ForEach(rangePartitioner,
                //      (range, loopState) =>
                //      {
                //          for (int fe = range.Item1; fe < range.Item2; fe++)
                for (int fe = 0; fe < Mesh.CountElems; fe++)
                {
                    // выделяем массивы для локальных матриц жесткости
                    double[][] M = new double[3][];
                    for (int k = 0; k < 3; k++)
                    {
                        M[k] = new double[3];
                    }
                    //и номера его вершин
                    int[] LKnots = Mesh.AreaElems[fe];
                    // нахождение площади треугольника
                    double LSk = Sk[fe];
                    // расчитываем геометрию элемента 
                    double Lb1 = b1[fe];
                    double Lb2 = b2[fe];
                    double Lb3 = b3[fe];
                    double Lc1 = c1[fe];
                    double Lc2 = c2[fe];
                    double Lc3 = c3[fe];
                    // расчет локальной матрицы жесткости для диффузионного члена
                    M[0][0] = -LSk * (Lb1 * Lb1 + Lc1 * Lc1);
                    M[0][1] = -LSk * (Lb1 * Lb2 + Lc1 * Lc2);
                    M[0][2] = -LSk * (Lb1 * Lb3 + Lc1 * Lc3);

                    M[1][0] = -LSk * (Lb2 * Lb1 + Lc2 * Lc1);
                    M[1][1] = -LSk * (Lb2 * Lb2 + Lc2 * Lc2);
                    M[1][2] = -LSk * (Lb2 * Lb3 + Lc2 * Lc3);

                    M[2][0] = -LSk * (Lb3 * Lb1 + Lc3 * Lc1);
                    M[2][1] = -LSk * (Lb3 * Lb2 + Lc3 * Lc2);
                    M[2][2] = -LSk * (Lb3 * Lb3 + Lc3 * Lc3);
                    lock (lockThis)
                        Sys.BuildMatrix(M, LKnots);
                }

                // });
                R = new double[CountKnots];
                //сборка правой части
                OrderablePartitioner<Tuple<int, int>> rangePartitioner1 = Partitioner.Create(0, Mesh.CountElems);
                Parallel.ForEach(rangePartitioner1,
                      (range, loopState) =>
                      {
                          for (int fe = range.Item1; fe < range.Item2; fe++)
                          //for(int fe=0;fe<Mesh.CountElem;fe++)
                          {

                              //for (int fe = 0; fe < Mesh.CountElem; fe++)
                              //{
                              double[] RR = new double[3];
                              // получаем текущий конечный элемент
                              int[] LKnots = Mesh.AreaElems[fe];
                              int Lm1 = LKnots[0];
                              int Lm2 = LKnots[1];
                              int Lm3 = LKnots[2];
                              // нахождение площади треугольника
                              double LSk = Sk[fe];
                              // расчитываем геометрию элемента 
                              double Lb1 = b1[fe];
                              double Lb2 = b2[fe];
                              double Lb3 = b3[fe];
                              double Lc1 = c1[fe];
                              double Lc2 = c2[fe];
                              double Lc3 = c3[fe];
                              //
                              double LU1 = U[Lm1]; double LU2 = U[Lm2]; double LU3 = U[Lm3];
                              double LV1 = V[Lm1]; double LV2 = V[Lm2]; double LV3 = V[Lm3];
                              //правая часть - неразрывность
                              double LSR = rho_w * LSk / (3 * tau) * ((Lb1 * LU1 + Lb2 * LU2 + Lb3 * LU3) + (Lc1 * LV1 + Lc2 * LV2 + Lc3 * LV3));
                              RR[0] = alpha_n * LSR;
                              RR[1] = alpha_n * LSR;
                              RR[2] = alpha_n * LSR;
                              //правая часть поправка КГД
                              double LBUU = (Lb1 * LU1 + Lb2 * LU2 + Lb3 * LU3) * (LU1 + LU2 + LU3);
                              double LCUV = (Lc1 * LU1 + Lc2 * LU2 + Lc3 * LU3) * (LV1 + LV2 + LV3);
                              double LBVU = (Lb1 * LV1 + Lb2 * LV2 + Lb3 * LV3) * (LU1 + LU2 + LU3);
                              double LCVV = (Lc1 * LV1 + Lc2 * LV2 + Lc3 * LV3) * (LV1 + LV2 + LV3);
                              //
                              RR[0] += (double)(alpha_r * rho_w * LSk / 3.0 * (Lb1 * (LBUU + LCUV) + Lc1 * (LBVU + LCVV)));
                              RR[1] += (double)(alpha_r * rho_w * LSk / 3.0 * (Lb2 * (LBUU + LCUV) + Lc2 * (LBVU + LCVV)));
                              RR[2] += (double)(alpha_r * rho_w * LSk / 3.0 * (Lb3 * (LBUU + LCUV) + Lc3 * (LBVU + LCVV)));
                              //
                              //для отображения невязки
                              R[Lm1] += RR[0];
                              R[Lm2] += RR[1];
                              R[Lm3] += RR[2];
                              //}
                          }

                      });
                //
                Sys.BuildRight(R, null);
                //ГУ слева
                Sys.BuildRight(BV, BLeftKnots);
                //главные ГУ справа 2
                Sys.SetBoundary(BV2, BRightKnots);
                // решение системы алгебраических уравнений
                Sys.Accept(Alg);
                Result = Sys.GetX;
                //для отладки
                for (int i = 0; i < NLeft; i++)
                    R[BLeftKnots[i]] += BV[i];
                for (int i = 0; i < NRight; i++)
                    R[BRightKnots[i]] = 0;

                // релаксация решения, буферизация и вычисление погрешности
                MaxError = 0;//масимальная ошибка в области
                for (int i = 0; i < CountKnots; i++)
                {
                    //релаксация
                    P[i] = (1 - relaxP) * P[i] + relaxP * Result[i];
                    //вычисление погрешности
                    double CurErr = Math.Abs((P[i] - buffP[i]) / P[i]);
                    if (MaxError < CurErr)
                        MaxError = CurErr;
                    ErrP[i] = CurErr;
                    //буферизация
                    buffP[i] = P[i];
                }
                #endregion
            }
        }
        //
        private int QHDUS2(int iteration)
        {
            if (CV_WallTau[0] == 0)
            {
                for (int i = 0; i < CV_WallKnots.Length; i++)
                {
                    int knot = CV_WallKnots[i][0];
                    //CV_WallTau[i] = WallFuncSharpPlus(knot, CV_WallKnotsDistance[i]);//шероховатая стенка по Луцкому, установка по Снегиреву
                    //CV_WallTau[i] = WallFuncSnegirev(knot, CV_WallKnotsDistance[i]);// гладкая стенка по Снегиреву
                    //CV_WallTau[i] = WallFuncPlus(knot, CV_WallKnotsDistance[i]);// гладкая стенка по Луцкому
                    CV_WallTau[i] = WallFunc(knot, CV_WallKnotsDistance[i]);// гладкая стенка по Волкову упрощ
                    //CV_WallTau[i] = WallFuncNewton(knot, CV_WallKnotsDistance[i]);// гладкая стенка по Волкову Ньютон
                }
            }
            #region Расчет u, v во внутренних узлах без узлов WallKnot
            //OrderablePartitioner<Tuple<int, int>> rangePartitioner3 = Partitioner.Create(0, CV2.Length);
            Parallel.ForEach(OrdPart_CV2,
                    (range, loopState) =>
                    {
                        for (int i = range.Item1; i < range.Item2; i++)
                    //for (int i = 0; i < CV2.Length; i++)
                    {
                        double LsummU = 0;//потоки U скорости
                        double LsummV = 0;//потоки V скорости
                        double LsummS = 0;//потоки s концентрации
                        //
                        int p0 = CV2[i][0];
                        int jj = CV2[i].Length - 1;//количество КО, связанных с данным узлом
                        for (int j = 0; j < jj; j++)
                        {
                            double _lx10 = Lx10[p0][j]; double _lx32 = Lx32[p0][j];
                            double _ly01 = Ly01[p0][j]; double _ly23 = Ly23[p0][j];
                            //площадь
                            double LS = SS[p0][j];
                            //сосоедние элементы
                            int Lv1 = CV2[i][(j + 1) % jj + 1];
                            int Lv2 = CV2[i][j + 1];
                            //вторая точка общей грани
                            int Lp1 = P1[p0][j];
                            //находим значения функций в центрах масс 1ого и 2ого треугольника как средние значения по элементу
                            int[] Knots1 = Mesh.AreaElems[Lv1];
                            int Lt1 = Knots1[0]; int Lt2 = Knots1[1]; int Lt3 = Knots1[2];
                            double LUc1 = (U[Lt1] + U[Lt2] + U[Lt3]) / 3.0;
                            double LVc1 = (V[Lt1] + V[Lt2] + V[Lt3]) / 3.0;
                            double LPc1 = (P[Lt1] + P[Lt2] + P[Lt3]) / 3.0;
                            double LSc1 = (S[Lt1] + S[Lt2] + S[Lt3]) / 3.0;
                            int[] Knots2 = Mesh.AreaElems[Lv2];
                            int Lz1 = Knots2[0]; int Lz2 = Knots2[1]; int Lz3 = Knots2[2];
                            double LUc2 = (U[Lz1] + U[Lz2] + U[Lz3]) / 3.0;
                            double LVc2 = (V[Lz1] + V[Lz2] + V[Lz3]) / 3.0;
                            double LPc2 = (P[Lz1] + P[Lz2] + P[Lz3]) / 3.0;
                            double LSc2 = (S[Lz1] + S[Lz2] + S[Lz3]) / 3.0;
                            //значения производных в точке пересечения граней
                            double Ls2 = 2 * LS;
                            double Ldudx = ((LUc1 - LUc2) * _ly01 + (U[Lp1] - U[p0]) * _ly23) / Ls2;
                            double Ldudy = ((LUc1 - LUc2) * _lx10 + (U[Lp1] - U[p0]) * _lx32) / Ls2;
                            double Ldvdx = ((LVc1 - LVc2) * _ly01 + (V[Lp1] - V[p0]) * _ly23) / Ls2;
                            double Ldvdy = ((LVc1 - LVc2) * _lx10 + (V[Lp1] - V[p0]) * _lx32) / Ls2;
                            double Ldpdx = ((LPc1 - LPc2) * _ly01 + (P[Lp1] - P[p0]) * _ly23) / Ls2;
                            double Ldpdy = ((LPc1 - LPc2) * _lx10 + (P[Lp1] - P[p0]) * _lx32) / Ls2;
                            double Ldsdx = ((LSc1 - LSc2) * _ly01 + (S[Lp1] - S[p0]) * _ly23) / Ls2;
                            double Ldsdy = ((LSc1 - LSc2) * _lx10 + (S[Lp1] - S[p0]) * _lx32) / Ls2;

                            //внешняя нормаль к грани КО (контуру КО)
                            double Lnx = Nx[p0][j]; double Lny = Ny[p0][j];
                            ////значение функций в точке пересечения грани КО и основной грани
                            double Lalpha = Alpha[p0][j];
                            double LUcr = Lalpha * U[p0] + (1 - Lalpha) * U[Lp1];
                            double LVcr = Lalpha * V[p0] + (1 - Lalpha) * V[Lp1];
                            double LPcr = Lalpha * P[p0] + (1 - Lalpha) * P[Lp1];
                            double LScr = Lalpha * S[p0] + (1 - Lalpha) * S[Lp1];
                            double LNucr = Lalpha * nuT[p0] + (1 - Lalpha) * nuT[Lp1] + nu_mol;
                            double LKcr = Lalpha * K[p0] + (1 - Lalpha) * K[Lp1];
                            double LEcr = Lalpha * E[p0] + (1 - Lalpha) * E[Lp1]; 
                            //длина текущего фрагмента внешнего контура КО
                            double LLk = _Lk[p0][j];
                            //
                            //
                            double LKc1 = (K[Lt1] + K[Lt2] + K[Lt3]) / 3.0;
                            double LKc2 = (K[Lz1] + K[Lz2] + K[Lz3]) / 3.0;
                            double Ldkdx = ((LKc1 - LKc2) * _ly01 + (K[Lp1] - K[p0]) * _ly23) / Ls2;
                            double Ldkdy = ((LKc1 - LKc2) * _lx10 + (K[Lp1] - K[p0]) * _lx32) / Ls2;
                            double wk = tau * (LUcr * Ldkdx + LVcr * Ldkdy - (LNucr * (2 * Ldudx * Ldudx + (Ldvdx + Ldudy) * (Ldvdx + Ldudy) + 2 * Ldvdy * Ldvdy)) - LEcr);
                            //
                            //
                            //расчет потоков
                            double LpressU = -1.0 / rho_w * LPcr * Lnx - 2.0 / 3.0 * LKcr * Lnx;
                            double LconvU = -LUcr * LUcr * Lnx - (LUcr * LVcr) * Lny;
                            double LdiffU = (nu_mol + LNucr) * (2.0 * Ldudx * Lnx - 2.0 / 3.0 * (Ldudx + Ldvdy) * Lnx + Ldudy * Lny + Ldvdx * Lny);
                            double wx = tau * (LUcr * Ldudx + LVcr * Ldudy + 1.0 / rho_w * Ldpdx + 2.0 / 3.0 * Ldkdx);
                            double wy = tau * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0 / rho_w * Ldpdy + 2.0 / 3.0 * Ldkdy);
                            double LregU1 = 2.0 * LUcr * wx * Lnx + 2.0 / 3.0 * wk * Lnx;
                            double LregU2 = (LVcr * wx + LUcr * wy) * Lny;
                            double LregU = LregU1 + LregU2;
                            LsummU += (LconvU + LdiffU + LregU + LpressU) * LLk;
                            //                  
                            double LpressV = -1.0 / rho_w * LPcr * Lny - 2.0 / 3.0 * LKcr * Lny;
                            double LconvV = -(LUcr * LVcr) * Lnx - LVcr * LVcr * Lny;
                            double LdiffV = (nu_mol + LNucr) * (2.0 * Ldvdy * Lny - 2.0 / 3.0 * (Ldudx + Ldvdy) * Lny + Ldvdx * Lnx + Ldudy * Lnx);
                            double LregV1 = 2.0 * LVcr * wy * Lny + 2.0 / 3.0 * wk * Lny;
                            double LregV2 = (LVcr * wx + LUcr * wy) * Lnx;
                            double LregV = LregV1 + LregV2;
                            LsummV += (LconvV + LdiffV + LregV + LpressV) * LLk;
                            //
                            double LconvS = -LScr * (LUcr + W * SinJ) * Lnx - LScr * (LVcr - W * CosJ) * Lny;
                            double LdiffS = LNucr / sigma_s * (Ldsdx * Lnx + Ldsdy * Lny);
                            double LregS = LScr * (wx * Lnx + wy * Lny);
                            LsummS += (LconvS + LdiffS + LregS) * LLk;
                        }
                        //
                        U[p0] = U[p0] + dt / S0[p0] * LsummU;
                        V[p0] = V[p0] + dt / S0[p0] * LsummV;
                        S[p0] = S[p0] + dt / S0[p0] * LsummS;
                        //
                        if (double.IsNaN(U[p0]))
                        {
                            err = " U в бесконечность";
                            //iteration = iter;
                            break;
                        }
                        //}

                    }

              });
            #endregion
            //
            #region Расчет u, v в узлах WallKnot
            //rangePartitioner3 = Partitioner.Create(0, CV_WallKnots.Length);
            Parallel.ForEach(OrdPart_CV_Wall,
                    (range, loopState) =>
                    {
                        for (int i = range.Item1; i < range.Item2; i++)
                        //for (int i = 0; i < CV_WallKnots.Length; i++)
                        {
                            double LsummU = 0;//потоки U скорости
                            double LsummV = 0;//потоки V скорости
                            double LsummS = 0;//потоки s концентрации
                            //
                            int p0 = CV_WallKnots[i][0];
                            int jj = CV_WallKnots[i].Length - 1; // количество КО, связанных с данным узлом
                            for (int j = 0; j < jj; j++)
                            {
                                double _lx10 = Lx10[p0][j]; double _lx32 = Lx32[p0][j];
                                double _ly01 = Ly01[p0][j]; double _ly23 = Ly23[p0][j];
                                //площадь
                                double LS = SS[p0][j];
                                //сосоедние элементы
                                int Lv1 = CV_WallKnots[i][(j + 1) % jj + 1];
                                int Lv2 = CV_WallKnots[i][j + 1];
                                //вторая точка общей грани
                                int Lp1 = P1[p0][j];
                                //находим значения функций в центрах масс 1ого и 2ого треугольника как средние значения по элементу
                                int[] Knots1 = Mesh.AreaElems[Lv1];
                                int Lt1 = Knots1[0]; int Lt2 = Knots1[1]; int Lt3 = Knots1[2];
                                double LUc1 = (U[Lt1] + U[Lt2] + U[Lt3]) / 3.0;
                                double LVc1 = (V[Lt1] + V[Lt2] + V[Lt3]) / 3.0;
                                double LPc1 = (P[Lt1] + P[Lt2] + P[Lt3]) / 3.0;
                                double LSc1 = (S[Lt1] + S[Lt2] + S[Lt3]) / 3.0;
                                int[] Knots2 = Mesh.AreaElems[Lv2];
                                int Lz1 = Knots2[0]; int Lz2 = Knots2[1]; int Lz3 = Knots2[2];
                                double LUc2 = (U[Lz1] + U[Lz2] + U[Lz3]) / 3.0;
                                double LVc2 = (V[Lz1] + V[Lz2] + V[Lz3]) / 3.0;
                                double LPc2 = (P[Lz1] + P[Lz2] + P[Lz3]) / 3.0;
                                double LSc2 = (S[Lz1] + S[Lz2] + S[Lz3]) / 3.0;
                                //значения производных в точке пересечения граней
                                double Ls2 = 2 * LS;
                                double Ldudx = ((LUc1 - LUc2) * _ly01 + (U[Lp1] - U[p0]) * _ly23) / Ls2;
                                double Ldudy = ((LUc1 - LUc2) * _lx10 + (U[Lp1] - U[p0]) * _lx32) / Ls2;
                                double Ldvdx = ((LVc1 - LVc2) * _ly01 + (V[Lp1] - V[p0]) * _ly23) / Ls2;
                                double Ldvdy = ((LVc1 - LVc2) * _lx10 + (V[Lp1] - V[p0]) * _lx32) / Ls2;
                                double Ldpdx = ((LPc1 - LPc2) * _ly01 + (P[Lp1] - P[p0]) * _ly23) / Ls2;
                                double Ldpdy = ((LPc1 - LPc2) * _lx10 + (P[Lp1] - P[p0]) * _lx32) / Ls2;
                                double Ldsdx = ((LSc1 - LSc2) * _ly01 + (S[Lp1] - S[p0]) * _ly23) / Ls2;
                                double Ldsdy = ((LSc1 - LSc2) * _lx10 + (S[Lp1] - S[p0]) * _lx32) / Ls2;
                                //внешняя нормаль к грани КО (контуру КО)
                                double Lnx = Nx[p0][j]; double Lny = Ny[p0][j];
                                ////значение функций в точке пересечения грани КО и основной грани
                                double Lalpha = Alpha[p0][j];
                                double LUcr = Lalpha * U[p0] + (1 - Lalpha) * U[Lp1];
                                double LVcr = Lalpha * V[p0] + (1 - Lalpha) * V[Lp1];
                                double LPcr = Lalpha * P[p0] + (1 - Lalpha) * P[Lp1];
                                double LScr = Lalpha * S[p0] + (1 - Lalpha) * S[Lp1];
                                double LNucr = Lalpha * nuT[p0] + (1 - Lalpha) * nuT[Lp1] + nu_mol;
                                double LKcr = Lalpha * K[p0] + (1 - Lalpha) * K[Lp1];
                                double LEcr = Lalpha * E[p0] + (1 - Lalpha) * E[Lp1];
                                //
                                //
                                double LKc1 = (K[Lt1] + K[Lt2] + K[Lt3]) / 3.0;
                                double LKc2 = (K[Lz1] + K[Lz2] + K[Lz3]) / 3.0;
                                double Ldkdx = ((LKc1 - LKc2) * _ly01 + (K[Lp1] - K[p0]) * _ly23) / Ls2;
                                double Ldkdy = ((LKc1 - LKc2) * _lx10 + (K[Lp1] - K[p0]) * _lx32) / Ls2;
                                double wk = tau * (LUcr * Ldkdx + LVcr * Ldkdy - (LNucr * (2 * Ldudx * Ldudx + (Ldvdx + Ldudy) * (Ldvdx + Ldudy) + 2 * Ldvdy * Ldvdy)) - LEcr);
                                //
                                //
                                //длина текущего фрагмента внешнего контура КО
                                double LLk = _Lk[p0][j];
                                //расчет потоков
                                double LpressU = -1.0 / rho_w * LPcr * Lnx;
                                double LconvU = -LUcr * LUcr * Lnx - (LUcr * LVcr) * Lny;
                                double LdiffU = 0;
                                //if ((Lp1 % NLeft == 0) || ((Lp1 + 1) % NLeft == 0 && surf_flag)) //только для нижней границы
                                //{
                                    double Tau = CV_WallTau[i];
                                    LdiffU = Tau / rho_w * Lny - nu_mol * 2.0 / 3.0 * (Ldudx + Ldvdy) * Lnx;
                                //}
                                //else
                                //    LdiffU = (nu_mol + LNucr) * (2.0 * Ldudx * Lnx - 2.0 / 3.0 * (Ldudx + Ldvdy) * Lnx + Ldudy * Lny + Ldvdx * Lny) - 2.0 / 3.0 * LKcr * Lnx;
                                double wx = tau * (LUcr * Ldudx + LVcr * Ldudy + 1.0 / rho_w * Ldpdx + 2.0 / 3.0 * Ldkdx);
                                double wy = tau * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0 / rho_w * Ldpdy + 2.0 / 3.0 * Ldkdy);
                                double LregU1 = 2.0 * LUcr * wx * Lnx + 2.0 / 3.0 * wk * Lnx;
                                double LregU2 = (LVcr * wx + LUcr * wy) * Lny;
                                double LregU = LregU1 + LregU2;
                                LsummU += (LconvU + LdiffU + LregU + LpressU) * LLk;
                                //                  
                                double LpressV = -1.0 / rho_w * LPcr * Lny;
                                double LconvV = -(LUcr * LVcr) * Lnx - LVcr * LVcr * Lny;
                                double LdiffV = 0;
                                //if ((Lp1 % NLeft == 0) || ((Lp1 + 1) % NLeft == 0 && surf_flag)) //только для нижней границы
                                //{
                                    //double Tau = CV_WallTau[i];
                                    LdiffV = Tau / rho_w * Lnx - nu_mol * 2.0 / 3.0 * (Ldudx + Ldvdy) * Lny;
                                //}
                                //else
                                //    LdiffV = (nu_mol + LNucr) * (2.0 * Ldvdy * Lny - 2.0 / 3.0 * (Ldudx + Ldvdy) * Lny + Ldvdx * Lnx + Ldudy * Lnx) - 2.0 / 3.0 * LKcr * Lny;
                                double LregV1 = 2.0 * LVcr * wy * Lny + 2.0 / 3.0 * wk * Lny;
                                double LregV2 = (LVcr * wx + LUcr * wy) * Lnx;
                                double LregV = LregV1 + LregV2;
                                LsummV += (LconvV + LdiffV + LregV + LpressV) * LLk;
                                //
                                double LconvS = -LScr * (LUcr + W * Math.Sin(J)) * Lnx - LScr * (LVcr - W * Math.Cos(J)) * Lny;
                                double LdiffS = LNucr / sigma_s * (Ldsdx * Lnx + Ldsdy * Lny);
                                double LregS = LScr * (wx * Lnx + wy * Lny);
                                LsummS += (LconvS + LdiffS + LregS) * LLk;
                            }
                            //
                            U[p0] = U[p0] + dt / S0[p0] * LsummU;
                            V[p0] = V[p0] + dt / S0[p0] * LsummV;
                            S[p0] = S[p0] + dt / S0[p0] * LsummS;
                            //
                            if (double.IsNaN(U[p0]))
                            {
                                err = " U в бесконечность";
                                //iteration = iter;
                                break;
                            }
                            //}

                        }

                    });
            #endregion
            //если задача со свободной поверхностью
            //if (surf_flag)
            //    U[BLeftKnots[0]] = U[BTopKnots[BTopKnots.Length - 2]];
            //ГУ Dong
            //if (iteration == iter - 1)
            //    DongBC_UE();
            //else
            //    DongBC_U();
            //ГУ справа - снос
            for (int i = 0; i < NRight; i++)
            {
                int knot = BRightKnots[i];
                //
                U[knot] = U[knot - NRight];
                V[knot] = V[knot - NRight];
                S[knot] = S[knot - NRight];
            }
            for (int i = 0; i < NTop; i++)
            {
                int knot = BTopKnots[i];
                S[knot] = S[knot - 1];
                knot = BBottomKnots[i];
                S[knot] = S[knot + 1];
            }
            //
            ////----------------
            //если задача со свободной поверхностью
            if (surf_flag)
            {
                for (int i = 1; i < NTop; i++)
                {
                    int knot = BTopKnots[i];
                    U[knot] = U[knot - 1];
                    V[knot] = V[knot - 1];// или =0
                }
            }
            //
            return iteration;
        }
        //
        private int QHDKE(int iteration)
        {
            #region Расчет k и e во внутренних узлах без узлов WallKnots
            //OrderablePartitioner<Tuple<int, int>> rangePartitioner3 = Partitioner.Create(0, CV2.Length);
            Parallel.ForEach(OrdPart_CV2,
                    (range, loopState) =>
                    {
                        for (int i = range.Item1; i < range.Item2; i++)
                        //for (int i = 0; i < CV2.Length; i++)
                        {
                            double LsummK = 0;//потоки k 
                            double LsummE = 0;//потоки e 
                            double LLrightK = 0;//потоки k 
                            double LLrightE = 0;//потоки e 
                            //
                            double ldudx = 0, ldudy = 0, ldvdx = 0, ldvdy = 0;
                            //
                            int p0 = CV2[i][0];
                            // убираем из расчета узлы, в которых устанавливается WallFunc

                            int jj = CV2[i].Length - 1;//количество КО, связанных с данным узлом
                            for (int j = 0; j < jj; j++)
                            {
                                double _lx10 = Lx10[p0][j]; double _lx32 = Lx32[p0][j];
                                double _ly01 = Ly01[p0][j]; double _ly23 = Ly23[p0][j];
                                //площадь
                                double LS = SS[p0][j];
                                //сосоедние элементы
                                int Lv1 = CV2[i][(j + 1) % jj + 1];
                                int Lv2 = CV2[i][j + 1];
                                //вторая точка общей грани
                                int Lp1 = P1[p0][j];
                                //находим значения функций в центрах масс 1ого и 2ого треугольника как средние значения по элементу
                                int[] Knots1 = Mesh.AreaElems[Lv1];
                                int Lt1 = Knots1[0]; int Lt2 = Knots1[1]; int Lt3 = Knots1[2];
                                double LUc1 = (U[Lt1] + U[Lt2] + U[Lt3]) / 3.0;
                                double LVc1 = (V[Lt1] + V[Lt2] + V[Lt3]) / 3.0;
                                double LPc1 = (P[Lt1] + P[Lt2] + P[Lt3]) / 3.0;
                                double LKc1 = (K[Lt1] + K[Lt2] + K[Lt3]) / 3.0;
                                double LEc1 = (E[Lt1] + E[Lt2] + E[Lt3]) / 3.0;
                                int[] Knots2 = Mesh.AreaElems[Lv2];
                                int Lz1 = Knots2[0]; int Lz2 = Knots2[1]; int Lz3 = Knots2[2];
                                double LUc2 = (U[Lz1] + U[Lz2] + U[Lz3]) / 3.0;
                                double LVc2 = (V[Lz1] + V[Lz2] + V[Lz3]) / 3.0;
                                double LPc2 = (P[Lz1] + P[Lz2] + P[Lz3]) / 3.0;
                                double LKc2 = (K[Lz1] + K[Lz2] + K[Lz3]) / 3.0;
                                double LEc2 = (E[Lz1] + E[Lz2] + E[Lz3]) / 3.0;
                                //значения производных в точке пересечения граней
                                double Ls2 = 2 * LS;
                                double Ldudx = ((LUc1 - LUc2) * _ly01 + (U[Lp1] - U[p0]) * _ly23) / Ls2;
                                double Ldudy = ((LUc1 - LUc2) * _lx10 + (U[Lp1] - U[p0]) * _lx32) / Ls2;
                                double Ldvdx = ((LVc1 - LVc2) * _ly01 + (V[Lp1] - V[p0]) * _ly23) / Ls2;
                                double Ldvdy = ((LVc1 - LVc2) * _lx10 + (V[Lp1] - V[p0]) * _lx32) / Ls2;
                                double Ldpdx = ((LPc1 - LPc2) * _ly01 + (P[Lp1] - P[p0]) * _ly23) / Ls2;
                                double Ldpdy = ((LPc1 - LPc2) * _lx10 + (P[Lp1] - P[p0]) * _lx32) / Ls2;
                                //
                                double Ldkdx = ((LKc1 - LKc2) * _ly01 + (K[Lp1] - K[p0]) * _ly23) / Ls2;
                                double Ldkdy = ((LKc1 - LKc2) * _lx10 + (K[Lp1] - K[p0]) * _lx32) / Ls2;
                                double Ldedx = ((LEc1 - LEc2) * _ly01 + (E[Lp1] - E[p0]) * _ly23) / Ls2;
                                double Ldedy = ((LEc1 - LEc2) * _lx10 + (E[Lp1] - E[p0]) * _lx32) / Ls2;
                                //внешняя нормаль к грани КО (контуру КО)
                                double Lnx = Nx[p0][j]; double Lny = Ny[p0][j];
                                ////значение функций в точке пересечения грани КО и основной грани
                                double Lalpha = Alpha[p0][j];
                                double LUcr = Lalpha * U[p0] + (1 - Lalpha) * U[Lp1];
                                double LVcr = Lalpha * V[p0] + (1 - Lalpha) * V[Lp1];
                                double LKcr = Lalpha * K[p0] + (1 - Lalpha) * K[Lp1];
                                double LEcr = Lalpha * E[p0] + (1 - Lalpha) * E[Lp1];
                                double LNucrT = Lalpha * nuT[p0] + (1 - Lalpha) * nuT[Lp1];
                                //длина текущего фрагмента внешнего контура КО
                                double LLk = _Lk[p0][j];
                                //расчет потоков
                                double wx = tau * (LUcr * Ldudx + LVcr * Ldudy + 1.0 / rho_w * Ldpdx);
                                double wy = tau * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0 / rho_w * Ldpdy);
                                double wk = tau * (LUcr * Ldkdx + LVcr * Ldkdy - (LNucrT * (2 * Ldudx * Ldudx + (Ldvdx + Ldudy) * (Ldvdx + Ldudy) + 2 * Ldvdy * Ldvdy)) - LEcr);
                                double we = tau * (LUcr * Ldedx + LVcr * Ldedy - (LEcr / LKcr * (C_e1 * LNucrT * (2 * Ldudx * Ldudx + (Ldvdx + Ldudy) * (Ldvdx + Ldudy) + 2 * Ldvdy * Ldvdy)) - C_e2 * LEcr));
                                //
                                double LconvK = -LUcr * LKcr * Lnx - LVcr * LKcr * Lny;
                                double LdiffK = (LNucrT / sigma_k + nu_mol) * (Ldkdx * Lnx + Ldkdy * Lny);
                                double LregK = LKcr * wx * Lnx + LKcr * wy * Lny + LUcr * wk * Lnx + LVcr * wk * Lny;
                                //
                                LsummK += (LconvK + LdiffK + LregK) * LLk;
                                //                  
                                double LconvE = -LUcr * LEcr * Lnx - LVcr * LEcr * Lny;
                                double LdiffE = (LNucrT / sigma_e + nu_mol) * (Ldedx * Lnx + Ldedy * Lny);
                                double LregE = LEcr * wx * Lnx + LEcr * wy * Lny + LUcr * we * Lnx + LVcr * we * Lny;
                                // 
                                LsummE += (LconvE + LdiffE + LregE) * LLk;
                                //
                                // компоненты производных для Pk
                                ldudx += LUcr * Lnx * LLk;
                                ldudy += LUcr * Lny * LLk;
                                ldvdx += LVcr * Lnx * LLk;
                                ldvdy += LVcr * Lny * LLk;
                                //запись в массивы
                                //ConvK[p0] += LconvK * LLk;
                                //ConvE[p0] += LconvE * LLk;
                                //DiffK[p0] += LdiffK * LLk;
                                //DiffE[p0] += LdiffE * LLk;
                                //RegK[p0] += (LUcr * wk * Lnx + LVcr * wk * Lny) * LLk;
                                //RegE[p0] += (LUcr * we * Lnx + LVcr * we * Lny) * LLk;
                                //RegK[p0] += LregK * LLk;
                                //RegE[p0] += LregE * LLk;
                            }
                            //
                            ldudx /= S0[p0];
                            ldudy /= S0[p0];
                            ldvdx /= S0[p0];
                            ldvdy /= S0[p0];
                            //double tPk = 1.4142135623730950488016887242097 * nuT[p0] * (ldudx * ldudx + (ldvdx + ldudy) * (ldvdx + ldudy) + ldvdy * ldvdy); //- 2.0 / 3.0 * K[p0];
                            double tPk = nuT[p0] * (2 * ldudx * ldudx + (ldvdx + ldudy) * (ldvdx + ldudy) + 2 * ldvdy * ldvdy);
                            Pk[p0] = tPk;//Math.Min(tPk, 10 * E[p0]);
                            LLrightK = (Pk[p0] - E[p0]);
                            LLrightE = E[p0] / K[p0] * (C_e1 * Pk[p0] - C_e2 * E[p0]);
                            //
                            K[p0] = K[p0] + dt / S0[p0] * LsummK + dt * LLrightK;
                            E[p0] = E[p0] + dt / S0[p0] * LsummE + dt * LLrightE;
                            ////
                            //ConvK[p0] /= S0[p0];
                            //ConvE[p0] /= S0[p0];
                            //DiffK[p0] /= S0[p0];
                            //DiffE[p0] /= S0[p0];
                            //RegK[p0] /= S0[p0];
                            //RegE[p0] /= S0[p0];
                            //
                            rightK[p0] = LLrightK;
                            rightE[p0] = LLrightE;
                            ReT[p0] = K[p0] * K[p0] / E[p0] / nu_mol;
                            //
                            if (double.IsNaN(E[p0]))
                            {
                                err = " KE в бесконечность";
                                iteration = iter;
                                break;
                                //return iteration;
                            }
                            //}
                        }
                    });
            #endregion
            //
            #region Расчет k и e в узлах WallKnots
            //rangePartitioner3 = Partitioner.Create(0, CV_WallKnots.Length);
            Parallel.ForEach(OrdPart_CV_Wall,
                    (range, loopState) =>
                    {
                        for (int i = range.Item1; i < range.Item2; i++)
                        //for (int i = 0; i < CV_WallKnots.Length; i++)
                        {
                            double LsummK = 0;//потоки k 
                            double LLrightK = 0;//потоки k  
                            //
                            int p0 = CV_WallKnots[i][0];
                            int jj = CV_WallKnots[i].Length - 1;//количество КО, связанных с данным узлом
                            //
                            
                            for (int j = 0; j < jj; j++)
                            {
                                double _lx10 = Lx10[p0][j]; double _lx32 = Lx32[p0][j];
                                double _ly01 = Ly01[p0][j]; double _ly23 = Ly23[p0][j];
                                //площадь
                                double LS = SS[p0][j];
                                //сосоедние элементы
                                int Lv1 = CV_WallKnots[i][(j + 1) % jj + 1];
                                int Lv2 = CV_WallKnots[i][j + 1];
                                //вторая точка общей грани
                                int Lp1 = P1[p0][j];
                                //находим значения функций в центрах масс 1ого и 2ого треугольника как средние значения по элементу
                                int[] Knots1 = Mesh.AreaElems[Lv1];
                                int Lt1 = Knots1[0]; int Lt2 = Knots1[1]; int Lt3 = Knots1[2];
                                double LUc1 = (U[Lt1] + U[Lt2] + U[Lt3]) / 3.0;
                                double LVc1 = (V[Lt1] + V[Lt2] + V[Lt3]) / 3.0;
                                double LPc1 = (P[Lt1] + P[Lt2] + P[Lt3]) / 3.0;
                                double LKc1 = (K[Lt1] + K[Lt2] + K[Lt3]) / 3.0;
                                double LEc1 = (E[Lt1] + E[Lt2] + E[Lt3]) / 3.0;
                                int[] Knots2 = Mesh.AreaElems[Lv2];
                                int Lz1 = Knots2[0]; int Lz2 = Knots2[1]; int Lz3 = Knots2[2];
                                double LUc2 = (U[Lz1] + U[Lz2] + U[Lz3]) / 3.0;
                                double LVc2 = (V[Lz1] + V[Lz2] + V[Lz3]) / 3.0;
                                double LPc2 = (P[Lz1] + P[Lz2] + P[Lz3]) / 3.0;
                                double LKc2 = (K[Lz1] + K[Lz2] + K[Lz3]) / 3.0;
                                double LEc2 = (E[Lz1] + E[Lz2] + E[Lz3]) / 3.0;
                                //значения производных в точке пересечения граней
                                double Ls2 = 2 * LS;
                                double Ldudx = ((LUc1 - LUc2) * _ly01 + (U[Lp1] - U[p0]) * _ly23) / Ls2;
                                double Ldudy = ((LUc1 - LUc2) * _lx10 + (U[Lp1] - U[p0]) * _lx32) / Ls2;
                                double Ldvdx = ((LVc1 - LVc2) * _ly01 + (V[Lp1] - V[p0]) * _ly23) / Ls2;
                                double Ldvdy = ((LVc1 - LVc2) * _lx10 + (V[Lp1] - V[p0]) * _lx32) / Ls2;
                                double Ldpdx = ((LPc1 - LPc2) * _ly01 + (P[Lp1] - P[p0]) * _ly23) / Ls2;
                                double Ldpdy = ((LPc1 - LPc2) * _lx10 + (P[Lp1] - P[p0]) * _lx32) / Ls2;
                                //
                                double Ldkdx = ((LKc1 - LKc2) * _ly01 + (K[Lp1] - K[p0]) * _ly23) / Ls2;
                                double Ldkdy = ((LKc1 - LKc2) * _lx10 + (K[Lp1] - K[p0]) * _lx32) / Ls2;
                                //внешняя нормаль к грани КО (контуру КО)
                                double Lnx = Nx[p0][j]; double Lny = Ny[p0][j];
                                ////значение функций в точке пересечения грани КО и основной грани
                                double Lalpha = Alpha[p0][j];
                                double LUcr = Lalpha * U[p0] + (1 - Lalpha) * U[Lp1];
                                double LVcr = Lalpha * V[p0] + (1 - Lalpha) * V[Lp1];
                                double LKcr = Lalpha * K[p0] + (1 - Lalpha) * K[Lp1];
                                double LEcr = Lalpha * E[p0] + (1 - Lalpha) * E[Lp1];
                                double LNucrT = Lalpha * nuT[p0] + (1 - Lalpha) * nuT[Lp1];
                                //длина текущего фрагмента внешнего контура КО
                                double LLk = _Lk[p0][j];
                                //расчет потоков
                                double wx = tau * (LUcr * Ldudx + LVcr * Ldudy + 1.0 / rho_w * Ldpdx);
                                double wy = tau * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0 / rho_w * Ldpdy);
                                double wk = tau * (LUcr * Ldkdx + LVcr * Ldkdy);
                                //
                                double LconvK = -LUcr * LKcr * Lnx - LVcr * LKcr * Lny;
                                double LdiffK = (LNucrT / sigma_k + nu_mol) * (Ldkdx * Lnx + Ldkdy * Lny);
                                double LregK = LKcr * wx * Lnx + LKcr * wy * Lny + LUcr * wk * Lnx + LVcr * wk * Lny;
                                //
                                LsummK += (LconvK + LdiffK + LregK) * LLk;
                                //
                                //запись в массивы
                                //ConvK[p0] += LconvK * LLk;
                                //DiffK[p0] += LdiffK * LLk;
                                //RegK[p0] += (LUcr * wk * Lnx + LVcr * wk * Lny) * LLk;
                                //RegK[p0] += LregK * LLk;
                            }
                            //
                            double y_p_plus = cm14 * Math.Sqrt(K[p0]) * CV_WallKnotsDistance[i] / nu_mol;
                            Pk[p0] = 0;
                            if (y_p_plus > y_p_0)
                            {
                                E[p0] = cm14 * cm14 * cm14 * Math.Pow(K[p0], 1.5) / kappa / CV_WallKnotsDistance[i];
                                Pk[p0] = E[p0];
                            }
                            else
                                E[p0] = 2.0 * K[p0] / CV_WallKnotsDistance[i] / CV_WallKnotsDistance[i] * nu_mol;
                            //
                            LLrightK = (Pk[p0] - E[p0]);
                            //
                            K[p0] = K[p0] + dt / S0[p0] * LsummK + dt * LLrightK;
                            //
                            //ConvK[p0] /= S0[p0];
                            //ConvE[p0] /= S0[p0];
                            //DiffK[p0] /= S0[p0];
                            //
                            rightK[p0] = LLrightK;
                            ReT[p0] = K[p0] * K[p0] / E[p0] / nu_mol;
                            //
                            if (double.IsNaN(K[p0]))
                            {
                                err = " KE WallKnots в бесконечность";
                                iteration = iter;
                                break;
                                //return iteration;
                            }
                            //}

                        }

                    });
            #endregion

            //ГУ справа снос
            int Bknot=0;
            for (int i = 0; i < NRight; i++)
            {
                Bknot = BRightKnots[i];
                //
                K[Bknot] = K[Bknot - NRight];
                E[Bknot] = E[Bknot - NRight];
            }
            //
            if (surf_flag)
            {
                int knot;
                for (int i = 1; i < NTop; i++)
                {
                    knot = BTopKnots[i];
                    K[knot] = K[knot - 1];
                    E[knot] = E[knot - 1];
                }
            }
            // вычисление напряжения по пристеночной функции
            for (int i = 0; i < CV_WallKnots.Length; i++)
            {
                int knot = CV_WallKnots[i][0];
                //CV_WallTau[i] = WallFuncSharpPlus(knot, CV_WallKnotsDistance[i]);//шероховатая стенка по Луцкому, установка по Снегиреву
                //CV_WallTau[i] = WallFuncSnegirev(knot, CV_WallKnotsDistance[i]);// гладкая стенка по Снегиреву
                //CV_WallTau[i] = WallFuncPlus(knot, CV_WallKnotsDistance[i]);// гладкая стенка по Луцкому
                CV_WallTau[i] = WallFunc(knot, CV_WallKnotsDistance[i]);// гладкая стенка по Волкову упрощ
                //CV_WallTau[i] = WallFuncNewton(knot, CV_WallKnotsDistance[i]);// гладкая стенка по Волкову Ньютон
            }
            // вычисление напряжения по пристеночной функции для отрисовки
            for (int i = 0; i < NBottom; i++)
            {
                int knot = BBottomKnots[i] + 1;
                //
                //BTauC[i] = WallFuncSharpPlus(knot, BWallDistance[i]);//шероховатая стенка по Луцкому, установка по Снегиреву
                //BTauC[i] = WallFuncSnegirev(knot, BWallDistance[i]);// гладкая стенка по Снегиреву
                //BTauC[i] = WallFuncPlus(knot, BWallDistance[i]);// гладкая стенка по Луцкому
                BTauC[i] = WallFunc(knot, BWallDistance[i]);// гладкая стенка по Волкову упрощ
                //BTauC[i] = WallFuncNewton(knot, BWallDistance[i]);// гладкая стенка по Волкову Ньютон
            }
            for (int i = 0; i < NBottom - 1; i++)
            {
                BTau[i] = 2 * BTauC[i] * BTauC[i + 1] / (BTauC[i] + BTauC[i + 1]);
            }
            BTau[NBottom - 1] = BTau[NBottom - 2];
            //
            // поправка по пристеночной функции для верхней границы
            if (!surf_flag)
            {
                for (int i = 0; i < NTop; i++)
                {
                    int knot = BTopKnots[i]-1;
                    //
                    //TTauC[i] = WallFuncSnegirev(knot, TWallDistance[i]);
                    TTauC[i] = WallFunc(knot, TWallDistance[i]);// гладкая стенка по Волкову упрощ
                    //TTauC[i] = WallFuncSharpPlus(knot, TWallDistance[i]);//шероховатая стенка по Луцкому, установка по Снегиреву
                }
                for (int i = 0; i < NTop - 1; i++)
                {
                    TTau[i] = 2 * TTauC[i] * TTauC[i + 1] / (TTauC[i] + TTauC[i + 1]);
                }
                TTau[NTop - 1] = TTau[NTop - 2];
            }
            //
            return iteration;
        }
        private double WallFuncSnegirev(int knot_p, double dy)
        {
            double y_p_plus = cm14 * Math.Sqrt(K[knot_p]) * dy / nu_mol;
            double u2_tau = 0;
            if (y_p_plus > y_p_0)
                u2_tau = cm14 * cm14 * K[knot_p];
            else
                u2_tau = nu_mol * U[knot_p] / dy;
            double tau_w = u2_tau * rho_w;
            return tau_w;
        }
        /// <summary>
        /// Функция стенки по Волкову упрощенная
        /// </summary>
        /// <param name="knot_p">узел не на границе, но ближайший к ней</param>
        /// <param name="dy">расстояние от knot_p до дна </param>
        /// <returns></returns>
        private double WallFunc(int knot_p, double dy)
        {
            double kp = K[knot_p];
            double Dy = dy;
            double Du = U[knot_p];
            double Re = rho_w * cm14 * Math.Sqrt(Math.Abs(kp)) * Dy / mu;
            // tau
            double tauw = (rho_w * cm14 * Math.Sqrt(Math.Abs(kp)) * Du) / (1.0 / kappa * Math.Log(8.8 * Re));
            // квадрат u_tau
            //double ut2 = tauw / rho_w;
            //double k = ut2 / Math.Sqrt(C_m);
            //K[knot_p] = k;
            //double eps = ut2 * Math.Sqrt(ut2) / kappa / Dy;
            //E[knot_p] = eps;
            //nuT[knot_p] = C_m * k * k / eps + nu_mol;
            return tauw;
        }
        /// <summary>
        /// Функция стенки по Луцкому с буферным слоем
        /// </summary>
        /// <param name="knot_p">узел не на границе, но ближайший к ней</param>
        /// <param name="dy">расстояние от knot_p до дна </param>
        /// <returns></returns>
        private double WallFuncPlus(int knot_p, double dy)
        {
            double y1 = dy;
            double F = U[knot_p] * y1 / nu_mol;
            double y_plus = 0;
            if (F <= 2) // ламинарный слой
                y_plus = Math.Sqrt(2 * F);
            else if (F >= 696.68) // логарифмический слой
            {
                double y_i = 60;
                double F_i = 0, u_i = 0, y_i1 = 0;
                for (int i = 0; i < 7; i++)
                {
                    F_i = 2.5 * y_i * (Math.Log(y_i / 0.13) - 1) - 73.50481;
                    u_i = 2.5 * Math.Log(y_i / 0.13);
                    y_i1 = y_i + (F - F_i) / u_i;
                    if (Math.Abs(y_i - y_i1) < 0.000001)
                    {
                        y_i = y_i1;
                        break;
                    }
                    y_i = y_i1;
                }
                y_plus = y_i1;
            }
            else // буферный слой
                y_plus = alglib.spline1dcalc(bufF, F);
            // tau
            double utau = y_plus / y1 * nu_mol;
            double k = utau * utau / Math.Sqrt(C_m);
            //K[knot_p] = k;
            double eps = utau * utau * utau / kappa / y1;
            //E[knot_p] = eps;
            //nuT[knot_p] = C_m * k * k / eps + nu_mol;
            double tauw = utau * utau * rho_w;
            return tauw;
        }
        /// <summary>
        /// Функция стенки для шероховатой функции по алгоритму Луцкого без буферного слоя
        /// </summary>
        /// <param name="knot_p">узел не на границе, но ближайший к ней</param>
        /// <param name="dy">расстояние от knot_p до дна </param>
        /// <returns></returns>
        private double WallFuncSharpPlus(int knot_p, double dy)
        {
            //double y1 = Math.Abs(Y[knot_p] - Y[knot]);
            double delta = 0.6 * d;
            double y1 = dy;
            double F = U[knot_p] * y1 / nu_mol;
            double y_plus = 0;
            if (F <= 782.4968) // ламинарный слой
                y_plus = Math.Sqrt(2 * F);
            else  // логарифмический слой
            {
                double y_i = 39.56;
                double F_i = 0, u_i = 0, y_i1 = 0;
                for (int i = 0; i < 7; i++)
                {
                    F_i = 2.5 * y_i * (Math.Log(20.0855 * y_i / delta) - 1) - 683.559072;
                    u_i = 2.5 * Math.Log(20.0855 * y_i / delta);
                    y_i1 = y_i + (F - F_i) / u_i;
                    if (Math.Abs(y_i - y_i1) < 0.000001)
                    {
                        y_i = y_i1;
                        break;
                    }
                    y_i = y_i1;
                }
                y_plus = y_i1;
            }
            // буферный слой отсутствует
            // tau
            double utau = y_plus / y1 * nu_mol;
            double k = utau * utau / Math.Sqrt(C_m);
            //K[knot_p] = k;
            double eps = utau * utau * utau / kappa / y1;
            //E[knot_p] = eps;
            //nuT[knot_p] = C_m * k * k / eps + nu_mol;
            double tauw = utau * utau * rho_w;
            return tauw;
        }
        //
        /// <summary>
        /// Функция стенки по Волкову через метод Ньютона
        /// </summary>
        /// <param name="knot_p">узел не на границе, но ближайший к ней</param>
        /// <param name="dy">расстояние от knot_p до дна </param>
        /// <returns></returns>
        private double WallFuncVolkov(int knot_p, double dy)
        {
            double kp = K[knot_p];
            double Dy = dy;
            double Du = U[knot_p];
            double Re = rho_w * cm14 * Math.Sqrt(Math.Abs(kp)) * Dy / mu;
            double B = 5.3; // и у Волкова и есть
            //
            double u_plus = 0;
            double u_c = Math.Sqrt(Re);
            double f = 0, df = 0;
            if (Re <= 140)
            {
                u_c = Math.Sqrt(Re);
                //
                for (int i = 0; i < 5; i++)
                {
                    f = u_c + (Math.Exp(kappa * u_c) - 1 - kappa * u_c - 0.5 * kappa * u_c * kappa * u_c - 1.0 / 6.0 * kappa * u_c * kappa * u_c * kappa * u_c) * Math.Exp(-kappa * B) - Re / u_c;
                    df = 1 + (kappa * Math.Exp(kappa * u_c) - kappa - kappa * kappa * u_c - 0.5 * kappa * kappa * kappa * u_c * u_c) * Math.Exp(-kappa * B) + Re / u_c / u_c;
                    u_plus = u_c - f / df;
                    u_c = u_plus;
                }
            }
            else
            {
                u_c = 1.0 / kappa * Math.Log(Re) + B;
                //
                for (int i = 0; i < 5; i++)
                {
                    f = u_c - B - 1.0 / kappa * Math.Log(Math.Exp(-kappa * B) * (1 + kappa * u_c + 1.0 / 2.0 * kappa * kappa * u_c * u_c + 1.0 / 6.0 * kappa * kappa * kappa * u_c * u_c * u_c) + Re / u_c - u_c);
                    df = 1 - (Math.Exp(-kappa * B) * (kappa + kappa * kappa * u_c + 1.0 / 2.0 * kappa * kappa * kappa * u_c * u_c) - Re / u_c / u_c - 1) / (Math.Exp(-kappa * B) * (1 + kappa * u_c + 1.0 / 2.0 * kappa * kappa * u_c * u_c + 1.0 / 6.0 * kappa * kappa * kappa * u_c * u_c * u_c) + Re / u_c - u_c) / kappa;
                    u_plus = u_c - f/df;
                    u_c = u_plus;
                }
            }



            // tau
            double tauw1 = (rho_w * cm14 * Math.Sqrt(Math.Abs(kp)) * Du) / (1.0 / kappa * Math.Log(8.8 * Re));
            //
            double tauw = rho_w * Du * Du / u_plus / u_plus;
            // квадрат u_tau
            //double ut2 = tauw / rho_w;
            //double k = ut2 / Math.Sqrt(C_m);
            //K[knot_p] = k;
            //double eps = ut2 * Math.Sqrt(ut2) / kappa / Dy;
            //E[knot_p] = eps;
            //nuT[knot_p] = C_m * k * k / eps + nu_mol;
            return tauw;
        }
        //
        public double[] CalcTauEverywhere()
        {
            double[] tau = new double[CountKnots];
            if (OrdPart_CV == null)
                OrdPart_CV = Partitioner.Create(0, CV.Length);
            //
            if (surf_flag)
            {  
                #region Расчет Tau во всех узлах по КО
                // По МКО находим касательное напряжение во внутренних узлах
                int knot = 0;
                //OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, CV.Length);
                Parallel.ForEach(OrdPart_CV,
                        (range, loopState) =>
                        {
                            for (int i = range.Item1; i < range.Item2; i++)
                            //for (int i = 0; i < CV.Length; i++)
                            {
                                double LsummTau = 0;//потоки касательного напряжения
                                //
                                int p0 = CV[i][0];
                                int jj = CV[i].Length - 1;//количество КО, связанных с данным узлом
                                for (int j = 0; j < jj; j++)
                                {
                                    //вторая точка общей грани
                                    int Lp1 = P1[p0][j];
                                    //внешняя нормаль к грани КО (контуру КО)
                                    double Lnx = Nx[p0][j]; double Lny = Ny[p0][j];
                                    ////значение функций в точке пересечения грани КО и основной грани
                                    double Lalpha = Alpha[p0][j];
                                    double LUcr = Lalpha * U[p0] + (1 - Lalpha) * U[Lp1];
                                    double LVcr = Lalpha * V[p0] + (1 - Lalpha) * V[Lp1];
                                    //длина текущего фрагмента внешнего контура КО
                                    double LLk = _Lk[p0][j];
                                    //расчет потоков
                                    double LTau = LUcr * Lny + LVcr * Lnx;
                                    //
                                    LsummTau += LTau * LLk;
                                }
                                //
                                tau[p0] =  nuT[p0] * rho_w / S0[p0] * LsummTau; // * 2
                                //
                                if (double.IsNaN(tau[p0]))
                                {
                                    err = " tau в бесконечность";
                                    //iteration = iter;
                                    break;
                                }
                                //}

                            }

                        });
                #endregion
                #region Нахождение tau на границах
                for (int i = 0; i < NBottom; i++)
                {
                    knot = BBottomKnots[i];
                    tau[knot] = BTauC[i];
                    knot = BBottomKnots[i] + 1;
                    //tau[knot] = WallFuncSharpPlus(knot, Mesh.GetNormalDistanceBottom(knot));
                    //tau[knot] = WallFunc(knot, Mesh.GetNormalDistanceBottom(knot));
                    //tau[knot] = WallFuncVolkov(knot, Mesh.GetNormalDistanceBottom(knot));
                }
                  // 
                for (int i = 0; i < NLeft; i++)
                {
                    knot = BLeftKnots[i];
                    tau[knot] = tau[knot + NLeft];
                }
                //
                for (int i = 0; i < NRight; i++)
                {
                    knot = BRightKnots[i];
                    tau[knot] = tau[knot - NLeft];
                }
                //
                for (int i = 0; i < NTop; i++)
                {
                    knot = BTopKnots[i];
                    tau[knot] = tau[knot - 1];
                }

            }
                #endregion
            //
            return tau;
        }
        //
        /// <summary>
        /// Расчет k-e вместе с пристеночной функцией по Жлуткову 2015 Пристеночные функции для высокорейнольдсовых расчетов в программном комплексеFlowVision
        /// Сначала ставится значение при стенке, потом идет расчет k-e равновесный (в прилегающей к границе ко не считает)
        /// очень осциллирует решение -- можно поправить по Снегиреву по технике установки ГУ
        /// </summary>
        /// <param name="iteration"></param>
        /// <returns></returns>
        private int QHDKE2(int iteration)
        {
            //
            for (int i = 0; i < NBottom; i++)
            {
                int knot = BBottomKnots[i] + 1;
                double y = Y[knot] - Y[knot - 1];
                double dpdx = 0;
                if (i != NBottom - 1)
                    dpdx = (P[knot + _Ny] - P[knot]) / (X[_Ny] - X[0]);
                else
                    dpdx = (P[knot] - P[knot - _Ny]) / (X[_Ny] - X[0]);
                if (dudy[i] == 0)
                    dudy[i] = (U[knot] - U[knot - 1]) / (Y[knot] - Y[knot - 1]);
                double tauw = (nu_mol + nuT[knot]) * dudy[i];
                //
                double utau = (tauw / rho_w);
                double y1_plus = rho_w * utau * y / mu;
                double l1 = 0.41 * y * (1 - Math.Exp(-y1_plus / 25.0));
                //
                double up = Math.Pow(mu / rho_w / rho_w * Math.Abs(dpdx), 1.0 / 3.0);
                double y2_plus = rho_w * up * y / mu;
                double l2 = 0.2 * y * Math.Sqrt(y2_plus) * (1 - Math.Exp(-y2_plus / 13.6));
                double ll2 = Math.Max(Math.Sign(tauw) * l1 * l1 + Math.Sign(dpdx) * l2 * l2, 0);
                //
                double mut = 1.0 / 2.0 * (-mu + mu * (Math.Sqrt(1 + 4 * rho_w * ll2 / mu / mu * (tauw + dpdx * y))));
                dudy[i] = mut / rho_w / ll2 / 2.0;

                //
                double a = 0, b = y;
                double ab = (a + b) / 2.0;
                double l1_plusa = kappa * a * (1 - Math.Exp(-a / 25.0));
                double l1_plusb = kappa * b * (1 - Math.Exp(-b / 25.0));
                double l1_plusab = kappa * ab * (1 - Math.Exp(-ab / 25.0));
                //
                double l2_plusa = kappa * a * Math.Sqrt(a) * (1 - Math.Exp(-a / 13.6));
                double l2_plusb = kappa * b * Math.Sqrt(b) * (1 - Math.Exp(-b / 13.6));
                double l2_plusab = kappa * ab * Math.Sqrt(ab) * (1 - Math.Exp(-ab / 13.6));
                //
                double ua = (-1 + Math.Sqrt(1 + 4 * l1_plusa * l1_plusa)) / 2.0 / (l1_plusa * l1_plusa + 0.000000001);
                double ub = (-1 + Math.Sqrt(1 + 4 * l1_plusb * l1_plusb)) / 2.0 / l1_plusb / l1_plusb;
                double uab = (-1 + Math.Sqrt(1 + 4 * l1_plusab * l1_plusab)) / 2.0 / l1_plusab / l1_plusab;
                double u1_plus = (b - a) / 6.0 * (ua + 4 * uab + ub);
                //
                ua = (-1 + Math.Sqrt(1 + 4 * l2_plusa * l2_plusa * a)) / 2.0 / (l2_plusa * l2_plusa + 0.000000001);
                ub = (-1 + Math.Sqrt(1 + 4 * l2_plusb * l2_plusb * b)) / 2.0 / l2_plusb / l2_plusb;
                uab = (-1 + Math.Sqrt(1 + 4 * l2_plusab * l2_plusab * ab)) / 2.0 / l2_plusab / l2_plusab;
                double u2_plus = (b - a) / 6.0 * (ua + 4 * uab + ub);
                //
                double u_plus = Math.Sign(tauw) * u1_plus + Math.Sign(dpdx) * u2_plus;
                double ux = 0;
                if (U[knot]>= 0)
                    ux = u_plus * utau;
                else
                    ux = u_plus * up;
                //
                double utaup = Math.Sqrt(Math.Max(Math.Sign(tauw) * utau * utau + Math.Sign(dpdx) * up * up * up / nu_mol * y, 0));
                double ytaup_plus = rho_w * utaup * y / mu;
                double kc = utaup * utaup / (0.3 + 1.0 / (0.003 * Math.Pow(ytaup_plus, 3.5)));
                double kc2 = utau * utau / 0.3;
                //
                double uk = cm14 * Math.Sqrt(kc);
                double yk = rho_w * uk * y / mu;
                double le = 0.41 * y * (1 - Math.Exp(-yk / 15.0));
                double ec = uk * uk * uk / le;
                //
                nuT[knot] = mut / rho_w;
                //U[knot] = ux;
                K[knot] = kc;
                E[knot] = ec;
                BTau[i] = tauw;
            }
            if (!surf_flag)
            {
                for (int i = 0; i < NTop; i++)
                {
                    int knot = BTopKnots[i] - 1;
                    double y = Y[knot+1] - Y[knot];
                    double dpdx = 0;
                    if (i != NBottom - 1)
                        dpdx = (P[knot + _Ny] - P[knot]) / (X[_Ny] - X[0]);
                    else
                        dpdx = (P[knot] - P[knot - _Ny]) / (X[_Ny] - X[0]);
                    if (dudy[i] == 0)
                        dudy[i] = (U[knot+1] - U[knot]) / (Y[knot+1] - Y[knot]);
                    double tauw = (nu_mol + nuT[knot]) * dudy[i];
                    //
                    double utau = (tauw / rho_w);
                    double y1_plus = rho_w * utau * y / mu;
                    double l1 = 0.41 * y * (1 - Math.Exp(-y1_plus / 25.0));
                    //
                    double up = Math.Pow(mu / rho_w / rho_w * Math.Abs(dpdx), 1.0 / 3.0);
                    double y2_plus = rho_w * up * y / mu;
                    double l2 = 0.2 * y * Math.Sqrt(y2_plus) * (1 - Math.Exp(-y2_plus / 13.6));
                    double ll2 = Math.Max(Math.Sign(tauw) * l1 * l1 + Math.Sign(dpdx) * l2 * l2, 0);
                    //
                    double mut = 1.0 / 2.0 * (-mu + mu * (Math.Sqrt(1 + 4 * rho_w * ll2 / mu / mu * (tauw + dpdx * y))));
                    dudy[i] = mut / rho_w / ll2 / 2.0;

                    //
                    double a = 0, b = y;
                    double ab = (a + b) / 2.0;
                    double l1_plusa = kappa * a * (1 - Math.Exp(-a / 25.0));
                    double l1_plusb = kappa * b * (1 - Math.Exp(-b / 25.0));
                    double l1_plusab = kappa * ab * (1 - Math.Exp(-ab / 25.0));
                    //
                    double l2_plusa = kappa * a * Math.Sqrt(a) * (1 - Math.Exp(-a / 13.6));
                    double l2_plusb = kappa * b * Math.Sqrt(b) * (1 - Math.Exp(-b / 13.6));
                    double l2_plusab = kappa * ab * Math.Sqrt(ab) * (1 - Math.Exp(-ab / 13.6));
                    //
                    double ua = (-1 + Math.Sqrt(1 + 4 * l1_plusa * l1_plusa)) / 2.0 / (l1_plusa * l1_plusa + 0.000000001);
                    double ub = (-1 + Math.Sqrt(1 + 4 * l1_plusb * l1_plusb)) / 2.0 / l1_plusb / l1_plusb;
                    double uab = (-1 + Math.Sqrt(1 + 4 * l1_plusab * l1_plusab)) / 2.0 / l1_plusab / l1_plusab;
                    double u1_plus = (b - a) / 6.0 * (ua + 4 * uab + ub);
                    //
                    ua = (-1 + Math.Sqrt(1 + 4 * l2_plusa * l2_plusa * a)) / 2.0 / (l2_plusa * l2_plusa + 0.000000001);
                    ub = (-1 + Math.Sqrt(1 + 4 * l2_plusb * l2_plusb * b)) / 2.0 / l2_plusb / l2_plusb;
                    uab = (-1 + Math.Sqrt(1 + 4 * l2_plusab * l2_plusab * ab)) / 2.0 / l2_plusab / l2_plusab;
                    double u2_plus = (b - a) / 6.0 * (ua + 4 * uab + ub);
                    //
                    double u_plus = Math.Sign(tauw) * u1_plus + Math.Sign(dpdx) * u2_plus;
                    double ux = 0;
                    if (U[knot] >= 0)
                        ux = u_plus * utau;
                    else
                        ux = u_plus * up;
                    //
                    double utaup = Math.Sqrt(Math.Max(Math.Sign(tauw) * utau * utau + Math.Sign(dpdx) * up * up * up / nu_mol * y, 0));
                    double ytaup_plus = rho_w * utaup * y / mu;
                    double kc = utaup * utaup / (0.3 + 1.0 / (0.003 * Math.Pow(ytaup_plus, 3.5)));
                    double kc2 = utau * utau / 0.3;
                    //
                    double uk = cm14 * Math.Sqrt(kc);
                    double yk = rho_w * uk * y / mu;
                    double le = 0.41 * y * (1 - Math.Exp(-yk / 15.0));
                    double ec = uk * uk * uk / le;
                    //
                    nuT[knot] = mut / rho_w;
                    //U[knot] = ux;
                    K[knot] = kc;
                    E[knot] = ec;
                    BTau[i] = tauw;
                }
            }
            //
            for (int i = 0; i < NBottom - 1; i++)
            {
                BTau[i] = 2 * BTauC[i] * BTauC[i + 1] / (BTauC[i] + BTauC[i + 1]);
            }
            BTau[NBottom - 1] = BTau[NBottom - 2];
            //
            #region расчет k-e в области без пристенки
            Parallel.ForEach(OrdPart_CV2,
                    (range, loopState) =>
                    {
                        for (int i = range.Item1; i < range.Item2; i++)
                        //for (int i = 0; i < CV2.Length; i++)
                        {
                            double LsummK = 0;//потоки k 
                            double LsummE = 0;//потоки e 
                            double LLrightK = 0;//потоки k 
                            double LLrightE = 0;//потоки e 
                            //
                            double ldudx = 0, ldudy = 0, ldvdx = 0, ldvdy = 0;
                            //
                            int p0 = CV2[i][0];
                            // убираем из расчета узлы, в которых устанавливается WallFunc

                            int jj = CV2[i].Length - 1;//количество КО, связанных с данным узлом
                            for (int j = 0; j < jj; j++)
                            {
                                double _lx10 = Lx10[p0][j]; double _lx32 = Lx32[p0][j];
                                double _ly01 = Ly01[p0][j]; double _ly23 = Ly23[p0][j];
                                //площадь
                                double LS = SS[p0][j];
                                //сосоедние элементы
                                int Lv1 = CV2[i][(j + 1) % jj + 1];
                                int Lv2 = CV2[i][j + 1];
                                //вторая точка общей грани
                                int Lp1 = P1[p0][j];
                                //находим значения функций в центрах масс 1ого и 2ого треугольника как средние значения по элементу
                                int[] Knots1 = Mesh.AreaElems[Lv1];
                                int Lt1 = Knots1[0]; int Lt2 = Knots1[1]; int Lt3 = Knots1[2];
                                double LUc1 = (U[Lt1] + U[Lt2] + U[Lt3]) / 3.0;
                                double LVc1 = (V[Lt1] + V[Lt2] + V[Lt3]) / 3.0;
                                double LPc1 = (P[Lt1] + P[Lt2] + P[Lt3]) / 3.0;
                                double LKc1 = (K[Lt1] + K[Lt2] + K[Lt3]) / 3.0;
                                double LEc1 = (E[Lt1] + E[Lt2] + E[Lt3]) / 3.0;
                                int[] Knots2 = Mesh.AreaElems[Lv2];
                                int Lz1 = Knots2[0]; int Lz2 = Knots2[1]; int Lz3 = Knots2[2];
                                double LUc2 = (U[Lz1] + U[Lz2] + U[Lz3]) / 3.0;
                                double LVc2 = (V[Lz1] + V[Lz2] + V[Lz3]) / 3.0;
                                double LPc2 = (P[Lz1] + P[Lz2] + P[Lz3]) / 3.0;
                                double LKc2 = (K[Lz1] + K[Lz2] + K[Lz3]) / 3.0;
                                double LEc2 = (E[Lz1] + E[Lz2] + E[Lz3]) / 3.0;
                                //значения производных в точке пересечения граней
                                double Ls2 = 2 * LS;
                                double Ldudx = ((LUc1 - LUc2) * _ly01 + (U[Lp1] - U[p0]) * _ly23) / Ls2;
                                double Ldudy = ((LUc1 - LUc2) * _lx10 + (U[Lp1] - U[p0]) * _lx32) / Ls2;
                                double Ldvdx = ((LVc1 - LVc2) * _ly01 + (V[Lp1] - V[p0]) * _ly23) / Ls2;
                                double Ldvdy = ((LVc1 - LVc2) * _lx10 + (V[Lp1] - V[p0]) * _lx32) / Ls2;
                                double Ldpdx = ((LPc1 - LPc2) * _ly01 + (P[Lp1] - P[p0]) * _ly23) / Ls2;
                                double Ldpdy = ((LPc1 - LPc2) * _lx10 + (P[Lp1] - P[p0]) * _lx32) / Ls2;
                                //
                                double Ldkdx = ((LKc1 - LKc2) * _ly01 + (K[Lp1] - K[p0]) * _ly23) / Ls2;
                                double Ldkdy = ((LKc1 - LKc2) * _lx10 + (K[Lp1] - K[p0]) * _lx32) / Ls2;
                                double Ldedx = ((LEc1 - LEc2) * _ly01 + (E[Lp1] - E[p0]) * _ly23) / Ls2;
                                double Ldedy = ((LEc1 - LEc2) * _lx10 + (E[Lp1] - E[p0]) * _lx32) / Ls2;
                                //внешняя нормаль к грани КО (контуру КО)
                                double Lnx = Nx[p0][j]; double Lny = Ny[p0][j];
                                ////значение функций в точке пересечения грани КО и основной грани
                                double Lalpha = Alpha[p0][j];
                                double LUcr = Lalpha * U[p0] + (1 - Lalpha) * U[Lp1];
                                double LVcr = Lalpha * V[p0] + (1 - Lalpha) * V[Lp1];
                                double LKcr = Lalpha * K[p0] + (1 - Lalpha) * K[Lp1];
                                double LEcr = Lalpha * E[p0] + (1 - Lalpha) * E[Lp1];
                                double LNucrT = Lalpha * nuT[p0] + (1 - Lalpha) * nuT[Lp1];
                                //длина текущего фрагмента внешнего контура КО
                                double LLk = _Lk[p0][j];
                                //расчет потоков
                                double wx = tau * (LUcr * Ldudx + LVcr * Ldudy + 1.0 / rho_w * Ldpdx);
                                double wy = tau * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0 / rho_w * Ldpdy);
                                double wk = tau * (LUcr * Ldkdx + LVcr * Ldkdy - (LNucrT * (2 * Ldudx * Ldudx + (Ldvdx + Ldudy) * (Ldvdx + Ldudy) + 2 * Ldvdy * Ldvdy)) - LEcr);
                                double we = tau * (LUcr * Ldedx + LVcr * Ldedy - (LEcr / LKcr * (C_e1 * LNucrT * (2 * Ldudx * Ldudx + (Ldvdx + Ldudy) * (Ldvdx + Ldudy) + 2 * Ldvdy * Ldvdy)) - C_e2 * LEcr));
                                //
                                double LconvK = -LUcr * LKcr * Lnx - LVcr * LKcr * Lny;
                                double LdiffK = (LNucrT / sigma_k + nu_mol) * (Ldkdx * Lnx + Ldkdy * Lny);
                                double LregK = LKcr * wx * Lnx + LKcr * wy * Lny + LUcr * wk * Lnx + LVcr * wk * Lny;
                                //
                                LsummK += (LconvK + LdiffK + LregK) * LLk;
                                //                  
                                double LconvE = -LUcr * LEcr * Lnx - LVcr * LEcr * Lny;
                                double LdiffE = (LNucrT / sigma_e + nu_mol) * (Ldedx * Lnx + Ldedy * Lny);
                                double LregE = LEcr * wx * Lnx + LEcr * wy * Lny + LUcr * we * Lnx + LVcr * we * Lny;
                                // 
                                LsummE += (LconvE + LdiffE + LregE) * LLk;
                                //
                                // компоненты производных для Pk
                                ldudx += LUcr * Lnx * LLk;
                                ldudy += LUcr * Lny * LLk;
                                ldvdx += LVcr * Lnx * LLk;
                                ldvdy += LVcr * Lny * LLk;
                                //запись в массивы
                                //ConvK[p0] += LconvK * LLk;
                                //ConvE[p0] += LconvE * LLk;
                                //DiffK[p0] += LdiffK * LLk;
                                //DiffE[p0] += LdiffE * LLk;
                                //RegK[p0] += (LUcr * wk * Lnx + LVcr * wk * Lny) * LLk;
                                //RegE[p0] += (LUcr * we * Lnx + LVcr * we * Lny) * LLk;
                                //RegK[p0] += LregK * LLk;
                                //RegE[p0] += LregE * LLk;
                            }
                            //
                            ldudx /= S0[p0];
                            ldudy /= S0[p0];
                            ldvdx /= S0[p0];
                            ldvdy /= S0[p0];
                            //double tPk = 1.4142135623730950488016887242097 * nuT[p0] * (ldudx * ldudx + (ldvdx + ldudy) * (ldvdx + ldudy) + ldvdy * ldvdy); //- 2.0 / 3.0 * K[p0];
                            double tPk = nuT[p0] * (2 * ldudx * ldudx + (ldvdx + ldudy) * (ldvdx + ldudy) + 2 * ldvdy * ldvdy);
                            double Pk = tPk;//Math.Min(tPk, 10 * E[p0]);
                            LLrightK = (Pk - E[p0]);
                            LLrightE = E[p0] / K[p0] * (C_e1 * Pk - C_e2 * E[p0]);
                            //
                            K[p0] = K[p0] + dt / S0[p0] * LsummK + dt * LLrightK;
                            E[p0] = E[p0] + dt / S0[p0] * LsummE + dt * LLrightE;
                            ////
                            //ConvK[p0] /= S0[p0];
                            //ConvE[p0] /= S0[p0];
                            //DiffK[p0] /= S0[p0];
                            //DiffE[p0] /= S0[p0];
                            //RegK[p0] /= S0[p0];
                            //RegE[p0] /= S0[p0];
                            //
                            rightK[p0] = LLrightK;
                            rightE[p0] = LLrightE;
                            ReT[p0] = K[p0] * K[p0] / E[p0] / nu_mol;
                            //
                            if (double.IsNaN(E[p0]))
                            {
                                err = " KE в бесконечность";
                                iteration = iter;
                                break;
                                //return iteration;
                            }
                            //}
                        }
                    });
            #endregion


            //ГУ справа снос
            int Bknot = 0;
            for (int i = 0; i < NRight; i++)
            {
                Bknot = BRightKnots[i];
                //
                K[Bknot] = K[Bknot - NRight];
                E[Bknot] = E[Bknot - NRight];
            }
            //
            if (surf_flag)
            {
                int knot;
                for (int i = 0; i < NTop; i++)
                {
                    knot = BTopKnots[i];
                    K[knot] = K[knot - 1];
                    E[knot] = E[knot - 1];
                }
            }
           
            //
            return iteration;
        }
        double[] dudy;

        //----Тест        ///
        public double[] p_conv, p_kinet;
        public double[] u_press, u_kinet, u_cont;
        private void DongBC_UE(double delta = 0.05)
        {
            u_cont = new double[NRight];
            u_kinet = new double[NRight];
            u_press = new double[NRight];
            //
            int knot = BRightKnots[0];
            double du = 0, dv = 0;
            double dx = (X[knot] - X[knot - NRight]);
            double dy = (Y[knot + 2] - Y[knot + 1]);
            for (int i = 1; i < NRight - 1; i++)
            {
                knot = BRightKnots[i];
                du = (U[knot] - U[knot - NRight]) / dx;
                if (V[knot] < 0)
                    dv = (V[knot] - V[knot - 1]) / dy;
                else
                    dv = (V[knot + 1] - V[knot]) / dy;
                u_press[i] = 1.0 / mu * P[knot];
                u_kinet[i] = rho_w / 4.0 / mu * (U[knot] * U[knot] + V[knot] * V[knot]) * (1 - Math.Tanh(+U[knot] / Ucp / delta));
                u_cont[i] = du + dv;
                U[knot] = U[knot - NRight] + dx * (u_press[i] + u_kinet[i] - u_cont[i]);
                V[knot] = V[knot - NRight];
            }
        }

        private void DongBC_PE(double delta = 0.05)
        {
            p_conv = new double[NRight];
            p_kinet = new double[NRight];
            //
            int knot = 0;
            for (int i = 0; i < NRight; i++)
            {
                RBC[i] = 0;
                knot = BRightKnots[i];
                p_kinet[i] = 0.25 * rho_w * (U[knot] * U[knot] + V[knot] * V[knot]) * (1 - Math.Tanh(U[knot] / Ucp / delta));
                p_conv[i] = mu * (U[knot] - U[knot - NRight]) / (X[knot] - X[knot - NRight]);
                //
                RBC[i] = p_conv[i] - p_kinet[i];
            }
            RBC[0] = RBC[1];
            RBC[NRight - 1] = RBC[NRight - 2];
            //
            p_kinet[0] = p_kinet[1];
            p_conv[0] = p_conv[1];
            p_kinet[NRight - 1] = p_kinet[NRight - 2];
            p_conv[NRight - 1] = p_conv[NRight - 2];
        }
        //
        //----  ///
        private void DongBC_U(double delta = 0.05)
        {
            int knot = BRightKnots[0];
            double du = 0, dv = 0;
            double dx = (X[knot] - X[knot - NRight]);
            double dy = (Y[knot + 2] - Y[knot + 1]);
            for (int i = 1; i < NRight - 1; i++)
            {
                knot = BRightKnots[i];
                du = (U[knot] - U[knot - NRight]) / dx;
                if (V[knot] < 0)
                    dv = (V[knot] - V[knot - 1]) / dy;
                else
                    dv = (V[knot + 1] - V[knot]) / dy;
                U[knot] = U[knot - NRight] + dx / mu * (P[knot] + rho_w / 4.0 * (U[knot] * U[knot] + V[knot] * V[knot]) * (1 - Math.Tanh(+U[knot] / Ucp / delta))) - dx * (du + dv);
                V[knot] = V[knot - NRight];
            }
        }

        private void DongBC_P(double delta = 0.05)
        {
            int knot = 0;
            for (int i = 0; i < NRight; i++)
            {
                RBC[i] = 0;
                knot = BRightKnots[i];
                RBC[i] = mu * (U[knot] - U[knot - NRight]) / (X[knot] - X[knot - NRight]) - 0.25 * rho_w * (U[knot] * U[knot] + V[knot] * V[knot]) * (1 - Math.Tanh(U[knot] / Ucp / delta));
            }
            RBC[0] = RBC[1];
            RBC[NRight - 1] = RBC[NRight - 2];
        }
        //
        public double[] GetKBed()
        {
            double[] kBed = new double[NBottom];
            int knot = 0;
            for (int i = 0; i < NBottom; i++)
            {
                knot = BBottomKnots[i]+1;
                kBed[i] = K[knot];
            }
            return kBed;
        }
        //
        //
        /// <summary>
        /// нахождение размерного касательного напряжения на дне
        /// </summary>
        void ShearStresses()
        {
            System.Object lockThis = new System.Object();
            //
            int IndexMethod = 0;// через ленту tau_l
            IndexMethod = 2;// через ленту тензор TT
            //IndexMethod = 1;// через конечные разности -  для сильновырожденной области не годится
            try
            {
                if (IndexMethod == 2)
                {
                    //компоненты тензора напряжений
                    double[] Tx1 = new double[BTriangles.Length];
                    double[] Tx2 = new double[BTriangles.Length];
                    double[] Ty1 = new double[BTriangles.Length];
                    double[] Ty2 = new double[BTriangles.Length];
                    //
                    double[] tau_mid = new double[BTriangles.Length];
                    //double e1x = 1, e1y = 0, e2x = 0, e2y = 1;//проекции
                    //
                    OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, BTriangles.Length);
                    Parallel.ForEach(rangePartitioner,
                           (range, loopState) =>
                           {
                               for (int i = range.Item1; i < range.Item2; i++)
                               //for (int i = 0; i < BTriangles.Length; i++)
                               {

                                   double[] xL = new double[3];
                                   double[] yL = new double[3];
                                   //
                                   int LcurV = BTriangles[i];
                                   int[] Knots = Mesh.AreaElems[LcurV];
                                   //
                                   int Lnum1 = Knots[0];
                                   int Lnum2 = Knots[1];
                                   int Lnum3 = Knots[2];
                                   // получаем координаты узлов элемента
                                   xL[0] = X[Lnum1]; xL[1] = X[Lnum2]; xL[2] = X[Lnum3];
                                   yL[0] = Y[Lnum1]; yL[1] = Y[Lnum2]; yL[2] = Y[Lnum3];
                                   // нахождение площади треугольника
                                   double LS = Sk[LcurV];
                                   // скорости в вершинах треугольника
                                   double LU1 = U[Lnum1];
                                   double LU2 = U[Lnum2];
                                   double LU3 = U[Lnum3];
                                   //
                                   double LV1 = V[Lnum1];
                                   double LV2 = V[Lnum2];
                                   double LV3 = V[Lnum3];
                                   // производные в центре треугольника
                                   double Ldu_dx = 1.0f / 2.0f / LS * (LU1 * (yL[1] - yL[2]) + LU2 * (yL[2] - yL[0]) + LU3 * (yL[0] - yL[1]));
                                   double Ldu_dy = 1.0f / 2.0f / LS * (LU1 * (xL[2] - xL[1]) + LU2 * (xL[0] - xL[2]) + LU3 * (xL[1] - xL[0]));
                                   double Ldv_dx = 1.0f / 2.0f / LS * (LV1 * (yL[1] - yL[2]) + LV2 * (yL[2] - yL[0]) + LV3 * (yL[0] - yL[1]));
                                   double Ldv_dy = 1.0f / 2.0f / LS * (LV1 * (xL[2] - xL[1]) + LV2 * (xL[0] - xL[2]) + LV3 * (xL[1] - xL[0]));
                                   // давление в центре треугольника
                                   double LP_mid = (P[Lnum1] + P[Lnum2] + P[Lnum3]) / 3.0f;
                                   double Mu_mid = (nuT[Lnum1] + nuT[Lnum2] + nuT[Lnum3]) / 3.0f * rho_w;
                                   // составляющие тензора напряжений
                                   Tx1[i] = -LP_mid + 2.0f * Mu_mid * Ldu_dx;
                                   Tx2[i] = Mu_mid * (Ldu_dy + Ldv_dx);
                                   Ty1[i] = Mu_mid * (Ldu_dy + Ldv_dx);
                                   Ty2[i] = -LP_mid + 2.0f * Mu_mid * Ldv_dy;
                               }
                           });
                    // Вычисление tau в узлах сетки по сглаженной методике вычисления 
                    //double[] Tau_all = Aproximate(tau_mid, CBottom, BTriangles);

                    //вычисление тензора напряжений по сглаженной методике
                    double[] Tx1_all = Aproximate(Tx1, CBottom, BTriangles);
                    double[] Tx2_all = Aproximate(Tx2, CBottom, BTriangles);
                    double[] Ty1_all = Aproximate(Ty1, CBottom, BTriangles);
                    double[] Ty2_all = Aproximate(Ty2, CBottom, BTriangles);
                    //подготовка приграничных значений tau между граничными точками и координат для сплайна
                    int count = BBottomKnots.Length;
                    BTau = new double[count];
                    BTauC = new double[count];
                    arg = new double[count - 1];
                    int cKnot = BBottomKnots[0];
                    double prevTx1 = 0, prevTx2 = 0, prevTy1 = 0, prevTy2 = 0;
                    //
                    for (int i = 0; i < BBottomKnots.Length; i++)
                    {
                        cKnot = BBottomKnots[i];
                        for (int j = 0; j < CBottom.Length; j++)
                        {
                            if (cKnot == CBottom[j])
                            {
                                if (i != 0)
                                {
                                    int prevKnot = BBottomKnots[i - 1];
                                    double delx = (X[cKnot] - X[prevKnot]);
                                    double dely = (Y[cKnot] - Y[prevKnot]);
                                    double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
                                    // компоненты касательной между граничными точками
                                    double lx = 1 / ss * delx;
                                    double ly = 1 / ss * dely;
                                    double nx = -ly;
                                    double ny = lx;
                                    //
                                    double LsigX = (prevTx1 + Tx1_all[j]) / 2.0f * nx + (prevTx2 + Tx2_all[j]) / 2.0f * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
                                    double LsigY = (prevTy1 + Ty1_all[j]) / 2.0f * nx + (prevTy2 + Ty2_all[j]) / 2.0f * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
                                    //double LsigX = 2 * prevTx1 * Tx1_all[j] / (prevTx1 + Tx1_all[j]) * nx + 2 * prevTx2 * Tx2_all[j] / (prevTx2 + Tx2_all[j]) * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
                                    //double LsigY = 2 * prevTy1 * Ty1_all[j] / (prevTy1 + Ty1_all[j]) * nx + 2 * prevTy2 * Ty2_all[j] / (prevTy2 + Ty2_all[j]) * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
                                    //в полуцелых узлах
                                    BTau[i - 1] = (LsigX * lx + LsigY * ly);
                                    arg[i - 1] = X[prevKnot] + delx / 2.0f;
                                    //
                                    LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
                                    LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
                                    BTauC[i] = (LsigX * lx + LsigY * ly);

                                }
                                else
                                {
                                    int nextKnot = BBottomKnots[i + 1];
                                    double delx = (X[nextKnot] - X[cKnot]);
                                    double dely = (Y[nextKnot] - Y[cKnot]);
                                    double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
                                    // компоненты касательной между граничными точками
                                    double lx = 1 / ss * delx;
                                    double ly = 1 / ss * dely;
                                    double nx = -ly;
                                    double ny = lx;
                                    //
                                    double LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
                                    double LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
                                    BTauC[i] = (LsigX * lx + LsigY * ly);
                                }
                                //
                                prevTx1 = Tx1_all[j];
                                prevTx2 = Tx2_all[j];
                                prevTy1 = Ty1_all[j];
                                prevTy2 = Ty2_all[j];
                                break;
                            }
                        }
                    }
                    BTau[count - 1] = BTau[count - 2];
                    /////
                    Tx1 = new double[TTriangles.Length];
                    Tx2 = new double[TTriangles.Length];
                    Ty1 = new double[TTriangles.Length];
                    Ty2 = new double[TTriangles.Length];
                    //
                    tau_mid = new double[TTriangles.Length];
                    //double e1x = 1, e1y = 0, e2x = 0, e2y = 1;//проекции
                    //
                    rangePartitioner = Partitioner.Create(0, TTriangles.Length);
                    Parallel.ForEach(rangePartitioner,
                           (range, loopState) =>
                           {
                               for (int i = range.Item1; i < range.Item2; i++)
                               //for (int i = 0; i < BTriangles.Length; i++)
                               {

                                   double[] xL = new double[3];
                                   double[] yL = new double[3];
                                   //
                                   int LcurV = TTriangles[i];
                                   int[] Knots = Mesh.AreaElems[LcurV];
                                   //
                                   int Lnum1 = Knots[0];
                                   int Lnum2 = Knots[1];
                                   int Lnum3 = Knots[2];
                                   // получаем координаты узлов элемента
                                   xL[0] = X[Lnum1]; xL[1] = X[Lnum2]; xL[2] = X[Lnum3];
                                   yL[0] = Y[Lnum1]; yL[1] = Y[Lnum2]; yL[2] = Y[Lnum3];
                                   // нахождение площади треугольника
                                   double LS = Sk[LcurV];
                                   // скорости в вершинах треугольника
                                   double LU1 = U[Lnum1];
                                   double LU2 = U[Lnum2];
                                   double LU3 = U[Lnum3];
                                   //
                                   double LV1 = V[Lnum1];
                                   double LV2 = V[Lnum2];
                                   double LV3 = V[Lnum3];
                                   // производные в центре треугольника
                                   double Ldu_dx = 1.0f / 2.0f / LS * (LU1 * (yL[1] - yL[2]) + LU2 * (yL[2] - yL[0]) + LU3 * (yL[0] - yL[1]));
                                   double Ldu_dy = 1.0f / 2.0f / LS * (LU1 * (xL[2] - xL[1]) + LU2 * (xL[0] - xL[2]) + LU3 * (xL[1] - xL[0]));
                                   double Ldv_dx = 1.0f / 2.0f / LS * (LV1 * (yL[1] - yL[2]) + LV2 * (yL[2] - yL[0]) + LV3 * (yL[0] - yL[1]));
                                   double Ldv_dy = 1.0f / 2.0f / LS * (LV1 * (xL[2] - xL[1]) + LV2 * (xL[0] - xL[2]) + LV3 * (xL[1] - xL[0]));
                                   // давление в центре треугольника
                                   double LP_mid = (P[Lnum1] + P[Lnum2] + P[Lnum3]) / 3.0f;
                                   double Mu_mid = (nuT[Lnum1] + nuT[Lnum2] + nuT[Lnum3]) / 3.0f * rho_w;
                                   // составляющие тензора напряжений
                                   Tx1[i] = -LP_mid + 2.0f * Mu_mid * Ldu_dx;
                                   Tx2[i] = Mu_mid * (Ldu_dy + Ldv_dx);
                                   Ty1[i] = Mu_mid * (Ldu_dy + Ldv_dx);
                                   Ty2[i] = -LP_mid + 2.0f * Mu_mid * Ldv_dy;
                               }
                           });
                    // Вычисление tau в узлах сетки по сглаженной методике вычисления 
                    //double[] Tau_all = Aproximate(tau_mid, CBottom, BTriangles);

                    //вычисление тензора напряжений по сглаженной методике
                    Tx1_all = Aproximate(Tx1, CTop, TTriangles);
                    Tx2_all = Aproximate(Tx2, CTop, TTriangles);
                    Ty1_all = Aproximate(Ty1, CTop, TTriangles);
                    Ty2_all = Aproximate(Ty2, CTop, TTriangles);
                    //подготовка приграничных значений tau между граничными точками и координат для сплайна
                    count = BTopKnots.Length;
                    TTau = new double[count];
                    TTauC = new double[count];
                    argT = new double[count - 1];
                    cKnot = BTopKnots[0];
                    prevTx1 = 0; prevTx2 = 0; prevTy1 = 0; prevTy2 = 0;
                    //
                    for (int i = 0; i < BTopKnots.Length; i++)
                    {
                        cKnot = BTopKnots[i];
                        for (int j = 0; j < CTop.Length; j++)
                        {
                            if (cKnot == CTop[j])
                            {
                                if (i != 0)
                                {
                                    int prevKnot = BTopKnots[i - 1];
                                    double delx = (X[cKnot] - X[prevKnot]);
                                    double dely = (Y[cKnot] - Y[prevKnot]);
                                    double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
                                    // компоненты касательной между граничными точками
                                    double lx = 1 / ss * delx;
                                    double ly = 1 / ss * dely;
                                    double nx = -ly;
                                    double ny = lx;
                                    //
                                    double LsigX = (prevTx1 + Tx1_all[j]) / 2.0f * nx + (prevTx2 + Tx2_all[j]) / 2.0f * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
                                    double LsigY = (prevTy1 + Ty1_all[j]) / 2.0f * nx + (prevTy2 + Ty2_all[j]) / 2.0f * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
                                    //в полуцелых узлах
                                    TTau[i - 1] = (LsigX * lx + LsigY * ly);
                                    argT[i - 1] = X[prevKnot] + delx / 2.0f;
                                    //
                                    LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
                                    LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
                                    TTauC[i] = (LsigX * lx + LsigY * ly);

                                }
                                else
                                {
                                    int nextKnot = BTopKnots[i + 1];
                                    double delx = (X[nextKnot] - X[cKnot]);
                                    double dely = (Y[nextKnot] - Y[cKnot]);
                                    double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
                                    // компоненты касательной между граничными точками
                                    double lx = 1 / ss * delx;
                                    double ly = 1 / ss * dely;
                                    double nx = -ly;
                                    double ny = lx;
                                    //
                                    double LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
                                    double LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
                                    TTauC[i] = (LsigX * lx + LsigY * ly);
                                }
                                //
                                prevTx1 = Tx1_all[j];
                                prevTx2 = Tx2_all[j];
                                prevTy1 = Ty1_all[j];
                                prevTy2 = Ty2_all[j];
                                break;
                            }
                        }
                    }
                    TTau[count - 1] = TTau[count - 2];

                }
                if (IndexMethod == 0) //!!!-- 1 ый порядок точности, для Tau в целых и полуцелых узлах надо использовать через сплайн!
                {
                    //
                    double[] tau_mid = new double[BTriangles.Length];
                    //
                    OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, BTriangles.Length);
                    Parallel.ForEach(rangePartitioner,
                           (range, loopState) =>
                           {
                               for (int i = range.Item1; i < range.Item2; i++)
                               //for (int i = 0; i < BTriangles.Length; i++)
                               {

                                   double[] xL = new double[3];
                                   double[] yL = new double[3];
                                   //
                                   int LcurV = BTriangles[i];
                                   int[] Knots = Mesh.AreaElems[LcurV];
                                   //
                                   int Lnum1 = Knots[0];
                                   int Lnum2 = Knots[1];
                                   int Lnum3 = Knots[2];
                                   // получаем координаты узлов элемента
                                   xL[0] = X[Lnum1]; xL[1] = X[Lnum2]; xL[2] = X[Lnum3];
                                   yL[0] = Y[Lnum1]; yL[1] = Y[Lnum2]; yL[2] = Y[Lnum3];
                                   // нахождение площади треугольника
                                   double LS = Sk[LcurV];
                                   // скорости в вершинах треугольника
                                   double LU1 = U[Lnum1];
                                   double LU2 = U[Lnum2];
                                   double LU3 = U[Lnum3];
                                   //
                                   double LV1 = V[Lnum1];
                                   double LV2 = V[Lnum2];
                                   double LV3 = V[Lnum3];
                                   // касательный вектор (обход против часовой стрелки)
                                   double Lsx = Sx[i];
                                   double Lsy = Sy[i];
                                   // нормаль (направлена во внутрь КО)
                                   double Lnx = -Lsy;
                                   double Lny = Lsx;
                                   // производные в центре треугольника
                                   double Ldu_dx = 1.0f / 2.0f / LS * (LU1 * (yL[1] - yL[2]) + LU2 * (yL[2] - yL[0]) + LU3 * (yL[0] - yL[1]));
                                   double Ldu_dy = 1.0f / 2.0f / LS * (LU1 * (xL[2] - xL[1]) + LU2 * (xL[0] - xL[2]) + LU3 * (xL[1] - xL[0]));
                                   double Ldv_dx = 1.0f / 2.0f / LS * (LV1 * (yL[1] - yL[2]) + LV2 * (yL[2] - yL[0]) + LV3 * (yL[0] - yL[1]));
                                   double Ldv_dy = 1.0f / 2.0f / LS * (LV1 * (xL[2] - xL[1]) + LV2 * (xL[0] - xL[2]) + LV3 * (xL[1] - xL[0]));
                                   // давление в центре треугольника
                                   double LP_mid = (P[Lnum1] + P[Lnum2] + P[Lnum3]) / 3.0f;
                                   double Mu_mid = (nuT[Lnum1] + nuT[Lnum2] + nuT[Lnum3]) / 3.0f * rho_w;
                                   // составляющие тензора напряжений
                                   double Tx1 = -LP_mid + 2.0f * Mu_mid * Ldu_dx;
                                   double Tx2 = Mu_mid * (Ldu_dy + Ldv_dx);
                                   double Ty1 = Mu_mid * (Ldu_dy + Ldv_dx);
                                   double Ty2 = -LP_mid + 2.0f * Mu_mid * Ldv_dy;
                                   // компоненты вектора придонного напряжения
                                   double LsigX = Tx1 * Lnx + Tx2 * Lny;
                                   double LsigY = Ty1 * Lnx + Ty2 * Lny;
                                   //
                                   tau_mid[i] = (LsigX * Lsx + LsigY * Lsy);
                               }
                           });

                    // Вычисление tau в узлах сетки по сглаженной методике вычисления 
                    double[] Tau_all = Aproximate(tau_mid, CBottom, BTriangles);
                    //
                    //подготовка приграничных значений tau между граничными точками и координат для сплайна
                    int count = BBottomKnots.Length;
                    BTau = new double[count];
                    arg = new double[count];
                    int cKnot;
                    //
                    for (int i = 0; i < BBottomKnots.Length; i++)
                    {
                        cKnot = BBottomKnots[i];
                        for (int j = 0; j < CBottom.Length; j++)
                        {
                            if (cKnot == CBottom[j])
                            {

                                BTau[i] = Tau_all[j];
                                arg[i] = X[cKnot]; // аргумент - только X (чтобы легче проецировать на дно)
                                //arg[i] = Math.Sqrt(X[cKnot] * X[cKnot] + Y[cKnot] * Y[cKnot]);
                                break;
                            }
                        }
                    }
                }
                //
                if (IndexMethod == 1)//!!!-- 1 ый порядок точности, для Tau в целых и полуцелых узлах надо использовать через сплайн!
                {
                    //подготовка приграничных значений tau между граничными точками и координат для сплайна
                    arg = new double[BBottomKnots.Length];
                    //
                    OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(1, BBottomKnots.Length - 1);
                    Parallel.ForEach(rangePartitioner,
                           (range, loopState) =>
                           {
                               for (int i = range.Item1; i < range.Item2; i++)
                               //for (int i = 1; i < BBottomKnots.Length - 1; i++)
                               {
                                   //
                                   //           nnK(2)
                                   //            |
                                   //           nK(1)
                                   //            |
                                   //--wK(3)---cKnot(0)---eK(4)
                                   int cKnot = BBottomKnots[i];
                                   int wK = BBottomKnots[i - 1];
                                   int eK = BBottomKnots[i + 1];
                                   int nK = 0, nnK = 0;
                                   double delx = (X[eK] - X[wK]);
                                   double dely = (Y[eK] - Y[wK]);
                                   double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
                                   // компоненты касательной между граничными точками
                                   double lx = 1 / ss * delx;
                                   double ly = 1 / ss * dely;
                                   //нормаль к поверхности между узлами wK и eK
                                   double nx = -ly;
                                   double ny = lx;
                                   //
                                   double Ldu_dx = 0;
                                   double Ldu_dy = 0;
                                   double Ldv_dx = 0;
                                   double Ldv_dy = 0;
                                   double P_c = 0;
                                   //если дно почти горизонтальное, то считаем, что оно горизонтальное
                                   if (lx > 0.98)
                                   {
                                       nK = cKnot + 1;
                                       nnK = cKnot + 2;
                                       //x - это y(координата), y - это U (функция)
                                       double x0 = Y[cKnot];
                                       double y0 = U[cKnot];
                                       double x1 = Y[nK];
                                       double y1 = U[nK];
                                       double x2 = Y[nnK];
                                       double y2 = U[nnK];
                                       Ldu_dy = 1.0f / (x0 - x1) * y0 + 1.0f / (x0 - x2) * y0 + 1.0f / (x1 - x0) * (x0 - x2) / (x1 - x2) * y1 + 1.0f / (x2 - x0) * (x0 - x1) / (x2 - x1) * y2;
                                       //функция V - это y
                                       y0 = V[cKnot];
                                       y1 = V[nK];
                                       y2 = V[nnK];
                                       Ldv_dy = 1.0f / (x0 - x1) * y0 + 1.0f / (x0 - x2) * y0 + 1.0f / (x1 - x0) * (x0 - x2) / (x1 - x2) * y1 + 1.0f / (x2 - x0) * (x0 - x1) / (x2 - x1) * y2;
                                       Ldv_dx = 0;
                                       Ldu_dx = 0;
                                   }
                                   // если дно не горизонтальное
                                   else
                                   {

                                       double k = dy;
                                       FPoint[] PointsNorm = new FPoint[2];
                                       FPoint[] PointsTang = new FPoint[2];
                                       double[] U12 = new double[2]; double[] V12 = new double[2];
                                       double[] U34 = new double[2]; double[] V34 = new double[2];
                                       //
                                       for (int j = 0; j < 2; j++)
                                       {
                                           //точка на расстоянии k по направлению нормали
                                           PointsNorm[j] = new FPoint(X[cKnot] + nx * k * (j + 1), Y[cKnot] + ny * k * (j + 1));
                                           //
                                           int Triangle = Mesh.GetTriangle(PointsNorm[j].X, PointsNorm[j].Y);
                                           //
                                           double s05 = 1.0f / 2.0f / Sk[Triangle];
                                           int[] Knots = Mesh.AreaElems[Triangle];
                                           double x1 = X[Knots[0]]; double x2 = X[Knots[1]]; double x3 = X[Knots[2]];
                                           double y1 = Y[Knots[0]]; double y2 = Y[Knots[1]]; double y3 = Y[Knots[2]];
                                           double L1 = s05 * ((x2 * y3 - x3 * y2) + PointsNorm[j].X * (y2 - y3) + PointsNorm[j].Y * (x3 - x2));
                                           double L2 = s05 * ((x3 * y1 - x1 * y3) + PointsNorm[j].X * (y3 - y1) + PointsNorm[j].Y * (x1 - x3));
                                           double L3 = s05 * ((x1 * y2 - x2 * y1) + PointsNorm[j].X * (y1 - y2) + PointsNorm[j].Y * (x2 - x1));
                                           //
                                           U12[j] = L1 * U[Knots[0]] + L2 * U[Knots[1]] + L3 * U[Knots[2]];
                                           V12[j] = L1 * V[Knots[0]] + L2 * V[Knots[1]] + L3 * V[Knots[2]];
                                       }
                                       //аппроксимация по 4 точкам
                                       //double dPhids = (2 * PhiNormal[0] - 5 * PhiNormal[1] + 4 * PhiNormal[2] - PhiNormal[3]) / k / k;
                                       //аппрроксимация по трем точкам
                                       Ldu_dy = (-7 * U[cKnot] + 8 * U12[0] - U12[1]) / k / k / 2.0f;
                                       Ldv_dy = (-7 * V[cKnot] + 8 * V12[0] - V12[1]) / k / k / 2.0f;
                                       //
                                       //точка на расстоянии k по обоим направлениям по касательной от точки cKnot
                                       PointsTang[0] = new FPoint(X[cKnot] - lx * k, Y[cKnot] - ly * k);
                                       PointsTang[1] = new FPoint(X[cKnot] + lx * k, Y[cKnot] + ly * k);
                                       //
                                       for (int j = 0; j < 2; j++)
                                       {
                                           int Triangle = Mesh.GetTriangle(PointsTang[j].X, PointsTang[j].Y);
                                           //если область вогнутая, то хотя бы одна точка вдоль касательной бдует лежать вне области
                                           // здесь в таком случае влияние производных U и V  вдоль касательной не учитываем
                                           if (Triangle == -1)
                                           {
                                               U34[0] = 0; U34[1] = 0;
                                               V34[0] = 0; V34[1] = 0;
                                               break;
                                           }
                                           //
                                           double s05 = 1.0f / 2.0f / Sk[Triangle];
                                           int[] Knots = Mesh.AreaElems[Triangle];
                                           double x1 = X[Knots[0]]; double x2 = X[Knots[1]]; double x3 = X[Knots[2]];
                                           double y1 = Y[Knots[0]]; double y2 = Y[Knots[1]]; double y3 = Y[Knots[2]];
                                           double L1 = s05 * ((x2 * y3 - x3 * y2) + PointsNorm[j].X * (y2 - y3) + PointsNorm[j].Y * (x3 - x2));
                                           double L2 = s05 * ((x3 * y1 - x1 * y3) + PointsNorm[j].X * (y3 - y1) + PointsNorm[j].Y * (x1 - x3));
                                           double L3 = s05 * ((x1 * y2 - x2 * y1) + PointsNorm[j].X * (y1 - y2) + PointsNorm[j].Y * (x2 - x1));
                                           //
                                           U34[j] = L1 * U[Knots[0]] + L2 * U[Knots[1]] + L3 * U[Knots[2]];
                                           V34[j] = L1 * V[Knots[0]] + L2 * V[Knots[1]] + L3 * V[Knots[2]];

                                       }
                                       Ldu_dx = (U34[1] - U34[0]) / k / 2.0f;
                                       Ldv_dx = (V34[1] - V34[0]) / k / 2.0f;

                                   }
                                   //
                                   // давление в узле
                                   P_c = P[cKnot];
                                   double mu_c = nuT[cKnot] * rho_w;
                                   // составляющие тензора напряжений
                                   double Tx1 = -P_c + 2.0f * mu_c * Ldu_dx;
                                   double Tx2 = mu_c * (Ldu_dy + Ldv_dx);
                                   double Ty1 = mu_c * (Ldu_dy + Ldv_dx);
                                   double Ty2 = -P_c + 2.0f * mu_c * Ldv_dy;
                                   // компоненты вектора придонного напряжения
                                   double LsigX = Tx1 * nx + Tx2 * ny;
                                   double LsigY = Ty1 * nx + Ty2 * ny;
                                   // проекция вектора придонного напряжения на касательный вектор
                                   BTau[i] = (LsigX * lx + LsigY * ly);
                                   arg[i] = X[cKnot];

                                   //1/(x0-x1)*y0+1/(x0-x2)*y0+1/(x1-x0)*(x0-x2)/(x1-x2)*y1+1/(x2-x0)*(x0-x1)/(x2-x1)*y2

                               }
                           });
                    //
                }
            }
            catch (Exception e)
            {
                err = e.Message + "ShearStressesCalculation";
            }

        }
        void ShearStress(int[] BBottomKnots, int[] CBottom, int[] BTriangles, out double[] BTau, out double[] BTauC, out double[] arg)
        {
            BTauC = new double[BBottomKnots.Length];
            BTau = new double[BBottomKnots.Length];
            arg = new double[BBottomKnots.Length - 1];
            try
            {
                int count = BBottomKnots.Length;
                //
                double[] Tx1 = new double[BTriangles.Length];
                double[] Tx2 = new double[BTriangles.Length];
                double[] Ty1 = new double[BTriangles.Length];
                double[] Ty2 = new double[BTriangles.Length];
                //
                double[] tau_mid = new double[BTriangles.Length];
                //double e1x = 1, e1y = 0, e2x = 0, e2y = 1;//проекции
                //
                OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, BTriangles.Length);
                Parallel.ForEach(rangePartitioner,
                        (range, loopState) =>
                        {
                            for (int i = range.Item1; i < range.Item2; i++)
                            //for (int i = 0; i < BTriangles.Length; i++)
                            {

                                double[] xL = new double[3];
                                double[] yL = new double[3];
                                //
                                int LcurV = BTriangles[i];
                                int[] Knots = Mesh.AreaElems[LcurV];
                                //
                                int Lnum1 = Knots[0];
                                int Lnum2 = Knots[1];
                                int Lnum3 = Knots[2];
                                // получаем координаты узлов элемента
                                xL[0] = X[Lnum1]; xL[1] = X[Lnum2]; xL[2] = X[Lnum3];
                                yL[0] = Y[Lnum1]; yL[1] = Y[Lnum2]; yL[2] = Y[Lnum3];
                                // нахождение площади треугольника
                                double LS = Sk[LcurV];
                                // скорости в вершинах треугольника
                                double LU1 = U[Lnum1];
                                double LU2 = U[Lnum2];
                                double LU3 = U[Lnum3];
                                //
                                double LV1 = V[Lnum1];
                                double LV2 = V[Lnum2];
                                double LV3 = V[Lnum3];
                                // производные в центре треугольника
                                double Ldu_dx = 1.0f / 2.0f / LS * (LU1 * (yL[1] - yL[2]) + LU2 * (yL[2] - yL[0]) + LU3 * (yL[0] - yL[1]));
                                double Ldu_dy = 1.0f / 2.0f / LS * (LU1 * (xL[2] - xL[1]) + LU2 * (xL[0] - xL[2]) + LU3 * (xL[1] - xL[0]));
                                double Ldv_dx = 1.0f / 2.0f / LS * (LV1 * (yL[1] - yL[2]) + LV2 * (yL[2] - yL[0]) + LV3 * (yL[0] - yL[1]));
                                double Ldv_dy = 1.0f / 2.0f / LS * (LV1 * (xL[2] - xL[1]) + LV2 * (xL[0] - xL[2]) + LV3 * (xL[1] - xL[0]));
                                // давление в центре треугольника
                                double LP_mid = (P[Lnum1] + P[Lnum2] + P[Lnum3]) / 3.0f;
                                double Mu_mid = (nuT[Lnum1] + nuT[Lnum2] + nuT[Lnum3]) / 3.0f * rho_w;
                                // составляющие тензора напряжений
                                Tx1[i] = -LP_mid + 2.0f * Mu_mid * Ldu_dx;
                                Tx2[i] = Mu_mid * (Ldu_dy + Ldv_dx);
                                Ty1[i] = Mu_mid * (Ldu_dy + Ldv_dx);
                                Ty2[i] = -LP_mid + 2.0f * Mu_mid * Ldv_dy;
                            }
                        });
                // Вычисление tau в узлах сетки по сглаженной методике вычисления 
                //double[] Tau_all = Aproximate(tau_mid, CBottom, BTriangles);

                //вычисление тензора напряжений по сглаженной методике
                double[] Tx1_all = Aproximate(Tx1, CBottom, BTriangles);
                double[] Tx2_all = Aproximate(Tx2, CBottom, BTriangles);
                double[] Ty1_all = Aproximate(Ty1, CBottom, BTriangles);
                double[] Ty2_all = Aproximate(Ty2, CBottom, BTriangles);
                //подготовка приграничных значений tau между граничными точками и координат для сплайна

                int cKnot = BBottomKnots[0];
                double prevTx1 = 0, prevTx2 = 0, prevTy1 = 0, prevTy2 = 0;
                //
                for (int i = 0; i < BBottomKnots.Length; i++)
                {
                    cKnot = BBottomKnots[i];
                    for (int j = 0; j < CBottom.Length; j++)
                    {
                        if (cKnot == CBottom[j])
                        {
                            if (i != 0)
                            {
                                int prevKnot = BBottomKnots[i - 1];
                                double delx = (X[cKnot] - X[prevKnot]);
                                double dely = (Y[cKnot] - Y[prevKnot]);
                                double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
                                // компоненты касательной между граничными точками
                                double lx = 1 / ss * delx;
                                double ly = 1 / ss * dely;
                                double nx = -ly;
                                double ny = lx;
                                //
                                double LsigX = (prevTx1 + Tx1_all[j]) / 2.0f * nx + (prevTx2 + Tx2_all[j]) / 2.0f * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
                                double LsigY = (prevTy1 + Ty1_all[j]) / 2.0f * nx + (prevTy2 + Ty2_all[j]) / 2.0f * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
                                //в полуцелых узлах
                                BTau[i - 1] = (LsigX * lx + LsigY * ly);
                                arg[i - 1] = X[prevKnot] + delx / 2.0f;
                                //
                                LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
                                LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
                                BTauC[i] = (LsigX * lx + LsigY * ly);

                            }
                            else
                            {
                                int nextKnot = BBottomKnots[i + 1];
                                double delx = (X[nextKnot] - X[cKnot]);
                                double dely = (Y[nextKnot] - Y[cKnot]);
                                double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
                                // компоненты касательной между граничными точками
                                double lx = 1 / ss * delx;
                                double ly = 1 / ss * dely;
                                double nx = -ly;
                                double ny = lx;
                                //
                                double LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
                                double LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
                                BTauC[i] = (LsigX * lx + LsigY * ly);
                            }
                            //
                            prevTx1 = Tx1_all[j];
                            prevTx2 = Tx2_all[j];
                            prevTy1 = Ty1_all[j];
                            prevTy2 = Ty2_all[j];
                            break;
                        }
                    }
                }
                BTau[count - 1] = BTau[count - 2];
            }
            catch (Exception e)
            {
                err = e.Message + "ShearStressesCalculation";
            }
        }
        double[] Aproximate(double[] MiddleFunction, int[] GLKnots, int[] GTriangs)
        {
            int Count = GLKnots.Length;
            //
            double[] ExactFunc = new double[Count];
            //
            double[][] Matrix = new double[3][];
            for (int i = 0; i < 3; i++)
                Matrix[i] = new double[3];
            //
            try
            {
                SBand AlgB = new SBand();
                AlgB.SetSystem(Count, BWidth);
                // Вычисляем локальные матрицы жесткости и производим сборку глобальной матрицы жесткости
                int tr = 0;
                int[] GKnots, LKnots = new int[3];
                double S = 0; ;
                for (int k = 0; k < GTriangs.Length; k++)
                {
                    tr = GTriangs[k];
                    S = Sk[tr];
                    //S = Mesh.GetSquare(tr);
                    //переходим к локальной нумерации для СЛАУ
                    GKnots = Mesh.AreaElems[tr];
                    for (int i = 0; i < 3; i++)
                    {
                        for (int j = 0; j < Count; j++)
                        {
                            if (GKnots[i] == GLKnots[j])
                            {
                                LKnots[i] = j;
                                break;
                            }
                        }
                    }
                    //
                    // Вычисляем локальную матрицу жесткости 
                    // Расчет локальной матрицы жесткости для диффузионного члена
                    Matrix[0][0] = 1.0 / 6.0 * S;
                    Matrix[0][1] = 1.0 / 12.0 * S;
                    Matrix[0][2] = 1.0 / 12.0 * S;

                    Matrix[1][0] = 1.0 / 12.0 * S;
                    Matrix[1][1] = 1.0 / 6.0 * S;
                    Matrix[1][2] = 1.0 / 12.0 * S;

                    Matrix[2][0] = 1.0 / 12.0 * S;
                    Matrix[2][1] = 1.0 / 12.0 * S;
                    Matrix[2][2] = 1.0 / 6.0 * S;
                    // Формирование глобальной матрицы жесткости
                    AlgB.BuildMatrix(Matrix, LKnots);
                    //Mesh.SaveMesh("nn");
                    //
                    double[] tmpU = { MiddleFunction[k] * S / 3.0f, MiddleFunction[k] * S / 3.0f, MiddleFunction[k] * S / 3.0f };
                    //
                    AlgB.BuildRight(tmpU, LKnots);
                }
                // Решение системы алгебраических уравнений
                AlgGauss.Solve(AlgB);
                ExactFunc = AlgB.GetX;
            }
            catch (Exception e)
            {
                err = e.Message + "Aproximate fell down";
            }
            return ExactFunc;
        }
    }
    public class FPoint
    {
        public double X;
        public double Y;
        public FPoint(double x, double y)
        {
            X = x; Y = y;
        }
    }
}
//--------------------------------------------
//using AlgebraLibrary;
//using MeshLibrary;
//using System;
//using System.Collections.Concurrent;
//using System.Collections.Generic;
//using System.Diagnostics;
//using System.Linq;
//using System.Text;
//using System.Threading.Tasks;

//namespace HydrodynamicLibrary
//{
//    [Serializable]
//    public class WaterTaskEliz
//    {
//        #region Искомые величины и объекты для работы
//        public bool SerializeNow = false;
//        public string status = "Running";
//        public string err = "ok";
//        public int Iter = 0;
//        int beginIter = 0;
//        //
//        public double[] U = null;
//        public double[] V = null;
//        public double[] P = null;
//        public double[] ErrP = null;
//        double[] buffP = null;
//        double[] buffU = null;
//        double[] buffV = null;
//        public double[] BTau = null;
//        public double[] BTauС = null;
//        public double[] arg = null;//аргумент к BTau для сплайна
//        public double[] TTau = null;
//        public double[] TTauС = null;
//        public double[] argT = null;
//        //
//        /// <summary>
//        /// максимальная горизонтальная скорость
//        /// </summary>
//        double U_max = 0;
//        /// <summary>
//        /// Рейнольдс x = U*L/nu
//        /// </summary>
//        double Re = 1;
//        //
//        double rho_w = 1000;
//        /// <summary>
//        /// штраф неразрывности в давлении
//        /// </summary>
//        double alpha_n = 0.5f;
//        /// <summary>
//        /// штраф регуляризационной части в давлении
//        /// </summary>
//        double alpha_r = 0.5f;
//        /// <summary>
//        /// штраф фиктивного источника на правой границе
//        /// </summary>
//        double alpha_p = 0.5f;
//        //
//        //для контроля потери массы
//        //перемнные для баланса массы на входе и выходе
//        public double Q_in = 0;
//        public double Q_out = 0;
//        /// <summary>
//        /// ширина ленты
//        /// </summary>
//        public int BWidth = 0;
//        // 
//        /// <summary>
//        /// лист связности центрального узла CV[i][0] и окружающих его элементов (треугольников) CV[i][1..7]
//        /// </summary>
//        int[][] CV = null;
//        /// <summary>
//        /// упрощеная версия хранения граничных треугольников у дна
//        /// </summary>
//        int[] BTriangles = null;
//        /// <summary>
//        /// массив связности окружающих дно точек в глобальной и локальной нумерации
//        /// </summary>
//        int[] CBottom = null;
//        /// <summary>
//        /// упрощеная версия хранения граничных треугольников у своб. пов.
//        /// </summary>
//        int[] TTriangles = null;
//        /// <summary>
//        /// массив связности окружающих своб пов. точек в глобальной и локальной нумерации
//        /// </summary>
//        int[] CTop = null;
//        /// <summary>
//        /// массив - [] граничная точка на правой стенке, [] вершины треугольников, создающих грань с этой точкой, но не лежащие на нранице
//        /// </summary>
//        int[][] RightKnotsList = null;
//        int[][] TopKnotsList = null;
//        /// <summary>
//        /// генератор КЭ сетки для тестовой задачи
//        /// </summary>
//        public Mesh Mesh;
//        /// <summary>
//        /// решатель алгебраической задачи
//        /// </summary>
//        public SBand ABand = null;
//        public SSystem Sys = null;
//        /// <summary>
//        /// секундомер
//        /// </summary>
//        [NonSerialized]
//        Stopwatch stopW = null;
//        [NonSerialized]
//        TimeSpan timeSpan;
//        int remainTimeMin;
//        //
//        #endregion
//        //
//        double[] X = null, Y = null;
//        int iter = 1;
//        double dt = 0.0001f;
//        double tau = 0.01f;
//        double Q = 0;
//        public double dPdx = 0;
//        [NonSerialized]
//        double delta = 0.05;
//        double relaxP = 0.1f;
//        double nu = 0;
//        double mu = 0;
//        public int CountKnots = 0, CountTriangles = 0;
//        public double Ucp = 0;// значение средней скорости по суммированию профиля
//        double errP = 0.001f; // пмаксимальная допустимая погршность по давлению
//        //
//        AlgorythmGauss AlgGauss = new AlgorythmGauss();
//        Algorythm Alg = null;
//        //
//        public int _Nx = 0, _Ny = 0;
//        double dy = 0;
//        //
//        int NBottom = 0;
//        int NLeft = 0;
//        int NRight = 0;
//        int NTop = 0;
//        //
//        int[] BLeftKnots = null;
//        int[] BRightKnots = null;
//        int[] BBottomKnots = null;
//        int[] BTopKnots = null;
//        //
//        double[] RBC = null;
//        double[] BV = null;
//        bool surf_flag = false;
//        bool flag = true;
//        double[] R = null;
//        //
//        double[] Sk = null;
//        double[] b1 = null, b2 = null, b3 = null;
//        double[] c1 = null, c2 = null, c3 = null;
//        double[][] Lx10 = null;
//        double[][] Lx32 = null;
//        double[][] Ly01 = null;
//        double[][] Ly23 = null;
//        double[][] Alpha = null;
//        double[][] SS = null;
//        double[] S0 = null;
//        double[][] _Lk = null;
//        int[][] P1 = null;
//        double[][] Nx = null;
//        double[][] Ny = null;
//        double[] Sx, Sy;
//        public WaterTaskEliz(WElizParameter p, Mesh m, SSystem a, Algorythm Alg)
//        {
//            CountKnots = m.CountKnots;
//            CountTriangles = m.CountElems;
//            this.Alg = Alg;
//            //
//            BWidth = m.BandWidth();
//            //
//            Sys = a;
//            Sys.SetSystem(CountKnots, BWidth);
//            //
//            ABand = new SBand(CountKnots, BWidth);
//            //
//            InitMassives();
//            //
//            Re = p.Re;
//            alpha_n = p.alpha_n;
//            alpha_r = p.alpha_r;
//            //alpha_p = p.alpha_p;
//            Q = p.Q;
//            dt = p.dt_local;
//            tau = p.tau;
//            relaxP = p.relaxP;
//            mu = p.mu;
//            errP = p.errP;
//            surf_flag = p.surf_flag;
//            iter = p.iter;
//            nu = p.nu_m;
//            delta = p.delta;
//            //
//            //ChangeMesh(m);
//        }

//        private void InitMassives()
//        {
//            U = new double[CountKnots];
//            V = new double[CountKnots];
//            P = new double[CountKnots];
//            ErrP = new double[CountKnots];

//        }
//        public void ChangeMesh(Mesh m)
//        {
//            Mesh = m;
//            //обновление геометрии
//            Sk = Mesh.Sk;
//            b1 = Mesh.b1;
//            b2 = Mesh.b2;
//            b3 = Mesh.b3;
//            c1 = Mesh.c1;
//            c2 = Mesh.c2;
//            c3 = Mesh.c3;
//            BLeftKnots = Mesh.LeftKnots;
//            BRightKnots = Mesh.RightKnots;
//            BBottomKnots = Mesh.BottomKnots;
//            BTopKnots = Mesh.TopKnots;
//            NLeft = Mesh.CountLeft;
//            NRight = Mesh.CountRight;
//            NTop = Mesh.CountTop;
//            NBottom = Mesh.CountBottom;
//            X = Mesh.X;
//            Y = Mesh.Y;
//            _Ny = NLeft;
//            _Nx = NBottom;
//            RightKnotsList = Mesh.CPRight;
//            TopKnotsList = Mesh.CPTop;
//            BTriangles = Mesh.BTriangles;
//            CBottom = Mesh.CBottom;
//            TTriangles = Mesh.TTriangles;
//            CTop = Mesh.CTop;
//            CV = Mesh.CVolumes;
//            //
//            Lx10 = Mesh.Lx10;
//            Lx32 = Mesh.Lx32;
//            Ly01 = Mesh.Ly01;
//            Ly23 = Mesh.Ly23;
//            Alpha = Mesh.Alpha;
//            S0 = Mesh.S0;
//            SS = Mesh.S;
//            P1 = Mesh.P1;
//            _Lk = Mesh.Lk;
//            Nx = Mesh.Nx;
//            Ny = Mesh.Ny;
//            Sx = Mesh.Sx;
//            Sy = Mesh.Sy;
//            //

//            InitialConditions();
//        }
//        void InitialConditions()
//        {
//            //Начальное условие для скорости
//            double[] u0 = new double[NLeft];
//            double y;
//            //double Hn = Y[BLeftKnots[0]] - Y[BLeftKnots[NLeft - 1]];
//            //
//            //U_max = (double)(3.0 / 2.0 * Q / Hn);
//            //dPdx = (double)(-8.0 * U_max * mu / Hn / Hn);
//            //
//            if (!surf_flag)
//            {
//                //левая и правая граница


//                // ГУ уступ
//                //double Hn = Y[BLeftKnots[0]] - Y[BLeftKnots[NLeft / 2]];
//                //U_max = 3.0 / 2.0 * Q / Hn;
//                //dPdx = -8.0 * U_max * mu / Hn / Hn;
//                //for (int i = 0; i < NLeft / 2; i++)
//                //{
//                //    int knot = BLeftKnots[i];
//                //    y = (Y[knot] - Y[0]);
//                //    U[knot] = 1.0 / 2.0 / mu * dPdx * (y - Hn) * (y - H);
//                //    Ucp += U[knot];
//                //    //knot = BRightKnots[i];
//                //    //U[knot] = 1.0 / 2.0 / mu * dPdx * (y - Hn) * y;
//                //}
//                // ГУ поток
//                double H = Y[BLeftKnots[0]] - Y[BLeftKnots[NLeft - 1]];
//                U_max = 3.0 / 2.0 * Q / H;
//                dPdx = -8.0 * U_max * mu / H / H;
//                for (int i = 0; i < NLeft; i++)
//                {
//                    int knot = BLeftKnots[i];
//                    y = (Y[knot] - Y[0]);
//                    U[knot] = (double)(1.0 / 2.0 / mu * dPdx * (y - H) * y);
//                    Ucp += U[knot];
//                    //Тест
//                    //P[knot] = -dPdx * (L - X[knot]);
//                    ////
//                    knot = BRightKnots[i];
//                    U[knot] = (double)(1.0 / 2.0 / mu * dPdx * (y - H) * y);
//                }
//                Ucp /= NLeft;

//                if (flag)
//                {

//                    // внутренняя область
//                    //идеальное НУ
//                    for (int i = 0; i < CV.Length; i++)
//                    {
//                        int knot = CV[i][0];
//                        y = (Y[knot] - Y[0]);
//                        if (y >= 0)
//                            U[knot] = (double)(1.0 / 2.0 / mu * dPdx * (y - H) * y);
//                    }
//                    //
//                    buffP = new double[CountKnots];
//                    buffU = new double[CountKnots];
//                    buffV = new double[CountKnots];
//                    flag = false;
//                }
//                else
//                {
//                    // решение с предыдущего расчета
//                    for (int i = 0; i < CountKnots; i++)
//                    {
//                        U[i] = buffU[i];
//                        V[i] = buffV[i];
//                        P[i] = buffP[i];
//                    }
//                }
//            }
//            else
//            {
//                for (int i = 0; i < NLeft; i++)
//                {
//                    int knot = BLeftKnots[i];
//                    y = Y[knot];
//                    U[knot] = (double)(1 / 2.0 / mu * dPdx * (-y) * y);
//                }
//            }
//            //ГУ на левой стенке для КЭ
//            // массивы для ГУ
//            RBC = new double[NRight];
//            BV = new double[NLeft];
//            //главные ГУ
//            for (int i = 0; i < NLeft - 1; i++)
//            {
//                double y1 = Y[BLeftKnots[i]];
//                double y2 = Y[BLeftKnots[i + 1]];
//                //
//                double r3 = (double)(-Math.Abs(y1 - y2) / 2.0 * (dPdx) * (-1));
//                //
//                BV[i] += r3;
//                BV[i + 1] += r3;
//            }
//        }
//        public void Run()
//        {

//            double MaxError = 0; // максимальная порешность по давлению
//            //pr(new Form1.ReportDelegate(Program.mm.Report), "Расчет гидродинамики");
//            //////////
//            int knot = 0;
//            int count = 0;
//            double sumBU = 0;
//            //
//            int knotUp = 0, knotRightU = 0, knotRightD = 0, knotDown = 0;
//            //
//            double[] Result = null;
//            //
//            double[] BV2 = new double[NRight];
//            //
//            stopW = new Stopwatch();
//            double qf = 0;
//            //WriteToData();
//            try
//            {
//                System.Object lockThis = new System.Object();
//                //stopW.Start();
//                for (int iteration = beginIter; iteration < iter; iteration++)
//                {
//                    //System.Threading.Thread.Sleep(5000);

//                    ///------Протестировано ОК
//                    ////////////////// МКЭ давление /////////////////////
//                    #region Расчет давления
//                    Sys.ClearSystem();
//                    if (iteration != 0)
//                        Sys.SetX(Result);
//                    // выделение памяти под результат решения задачи
//                    Result = new double[Mesh.CountKnots];
//                    //выделяем масивы для локальных правых частей
//                    // основной цикл по конечным элементам
//                    // вычисляем локальные матрицы жесткости и производим сборку глобальной матрицы жесткости
//                    //OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, Mesh.CountElems);
//                    //Parallel.ForEach(rangePartitioner,
//                    //      (range, loopState) =>
//                    //      {
//                    //          for (int fe = range.Item1; fe < range.Item2; fe++)
//                    for (int fe = 0; fe < Mesh.CountElems; fe++)
//                    {
//                        // выделяем массивы для локальных матриц жесткости
//                        double[][] M = new double[3][];
//                        for (int k = 0; k < 3; k++)
//                        {
//                            M[k] = new double[3];
//                        }
//                        //и номера его вершин
//                        int[] LKnots = Mesh.AreaElems[fe];
//                        // нахождение площади треугольника
//                        double LSk = Sk[fe];
//                        // расчитываем геометрию элемента 
//                        double Lb1 = b1[fe];
//                        double Lb2 = b2[fe];
//                        double Lb3 = b3[fe];
//                        double Lc1 = c1[fe];
//                        double Lc2 = c2[fe];
//                        double Lc3 = c3[fe];
//                        // расчет локальной матрицы жесткости для диффузионного члена
//                        M[0][0] = -LSk * (Lb1 * Lb1 + Lc1 * Lc1);
//                        M[0][1] = -LSk * (Lb1 * Lb2 + Lc1 * Lc2);
//                        M[0][2] = -LSk * (Lb1 * Lb3 + Lc1 * Lc3);

//                        M[1][0] = -LSk * (Lb2 * Lb1 + Lc2 * Lc1);
//                        M[1][1] = -LSk * (Lb2 * Lb2 + Lc2 * Lc2);
//                        M[1][2] = -LSk * (Lb2 * Lb3 + Lc2 * Lc3);

//                        M[2][0] = -LSk * (Lb3 * Lb1 + Lc3 * Lc1);
//                        M[2][1] = -LSk * (Lb3 * Lb2 + Lc3 * Lc2);
//                        M[2][2] = -LSk * (Lb3 * Lb3 + Lc3 * Lc3);
//                        lock (lockThis)
//                            Sys.BuildMatrix(M, LKnots);
//                    }

//                    // });
//                    R = new double[CountKnots];
//                    //сборка правой части
//                    OrderablePartitioner<Tuple<int, int>> rangePartitioner1 = Partitioner.Create(0, Mesh.CountElems);
//                    Parallel.ForEach(rangePartitioner1,
//                            (range, loopState) =>
//                            {
//                                for (int fe = range.Item1; fe < range.Item2; fe++)
//                                //for(int fe=0;fe<Mesh.CountElem;fe++)
//                                {

//                                    //for (int fe = 0; fe < Mesh.CountElem; fe++)
//                                    //{
//                                    double[] RR = new double[3];
//                                    // получаем текущий конечный элемент
//                                    int[] LKnots = Mesh.AreaElems[fe];
//                                    int Lm1 = LKnots[0];
//                                    int Lm2 = LKnots[1];
//                                    int Lm3 = LKnots[2];
//                                    // нахождение площади треугольника
//                                    double LSk = Sk[fe];
//                                    // расчитываем геометрию элемента 
//                                    double Lb1 = b1[fe];
//                                    double Lb2 = b2[fe];
//                                    double Lb3 = b3[fe];
//                                    double Lc1 = c1[fe];
//                                    double Lc2 = c2[fe];
//                                    double Lc3 = c3[fe];
//                                    //
//                                    double LU1 = U[Lm1]; double LU2 = U[Lm2]; double LU3 = U[Lm3];
//                                    double LV1 = V[Lm1]; double LV2 = V[Lm2]; double LV3 = V[Lm3];
//                                    //правая часть - неразрывность
//                                    double LSR = rho_w * LSk / (3 * tau) * ((Lb1 * LU1 + Lb2 * LU2 + Lb3 * LU3) + (Lc1 * LV1 + Lc2 * LV2 + Lc3 * LV3));
//                                    RR[0] = alpha_n * LSR;
//                                    RR[1] = alpha_n * LSR;
//                                    RR[2] = alpha_n * LSR;
//                                    //правая часть поправка КГД
//                                    double LBUU = (Lb1 * LU1 + Lb2 * LU2 + Lb3 * LU3) * (LU1 + LU2 + LU3);
//                                    double LCUV = (Lc1 * LU1 + Lc2 * LU2 + Lc3 * LU3) * (LV1 + LV2 + LV3);
//                                    double LBVU = (Lb1 * LV1 + Lb2 * LV2 + Lb3 * LV3) * (LU1 + LU2 + LU3);
//                                    double LCVV = (Lc1 * LV1 + Lc2 * LV2 + Lc3 * LV3) * (LV1 + LV2 + LV3);
//                                    //
//                                    RR[0] += alpha_r * rho_w * LSk / 3.0 * (Lb1 * (LBUU + LCUV) + Lc1 * (LBVU + LCVV));
//                                    RR[1] += alpha_r * rho_w * LSk / 3.0 * (Lb2 * (LBUU + LCUV) + Lc2 * (LBVU + LCVV));
//                                    RR[2] += alpha_r * rho_w * LSk / 3.0 * (Lb3 * (LBUU + LCUV) + Lc3 * (LBVU + LCVV));
//                                    //ГУ по Фомину
//                                    //RR[0] += alpha_p * rho_w * LSk / 3.0 * (1 / dt * qf);
//                                    //RR[1] += alpha_p * rho_w * LSk / 3.0 * (1 / dt * qf);
//                                    //RR[2] += alpha_p * rho_w * LSk / 3.0 * (1 / dt * qf);
//                                    //
//                                    //для отображения невязки
//                                    R[Lm1] += RR[0];
//                                    R[Lm2] += RR[1];
//                                    R[Lm3] += RR[2];
//                                    //}
//                                }

//                            });
//                    //
//                    Sys.BuildRight(R, null);
//                    //ГУ слева
//                    Sys.BuildRight(BV, BLeftKnots);
//                    //главные ГУ справа 2
//                    //if (iteration == iter - 1)
//                    //    DongBC_PE();
//                    //else
//                    //    DongBC_P();
//                    // ГУ P=0 справа    //
//                    RBC = new double[NRight];
//                    // для Dong убрать  //
//                    Sys.SetBoundary(RBC, BRightKnots);
//                    //Sys.SetBoundary(BV2, BRightKnots);
//                    //Sys.SetBoundary(new double[] { 0 }, new int[] { BRightKnots[NRight - 1] }); // задаем ноль в правой верхней точке
//                    // решение системы алгебраических уравнений
//                    Sys.Accept(Alg);
//                    Result = Sys.GetX;
//                    //для отладки
//                    for (int i = 0; i < NLeft; i++)
//                        R[BLeftKnots[i]] += BV[i];
//                    for (int i = 0; i < NRight; i++)
//                        R[BRightKnots[i]] = 0;
//                    //
//                    // релаксация решения, буферизация и вычисление погрешности
//                    MaxError = 0;// масимальная ошибка в области
//                    for (int i = 0; i < CountKnots; i++)
//                    {
//                        //релаксация
//                        P[i] = (1 - relaxP) * P[i] + relaxP * Result[i];
//                        //вычисление погрешности
//                        double CurErr = Math.Abs((P[i] - buffP[i]) / P[i]);
//                        if (MaxError < CurErr)
//                            MaxError = CurErr;
//                        ErrP[i] = CurErr;
//                        //буферизация
//                        buffP[i] = P[i];
//                    }
//                    #endregion

//                    ///------Протестировано ОК
//                    ////////////////// МКО скорость /////////////////////
//                    #region Расчет скоростей
//                    //int knotCorner = 0;
//                    //for (int j = 0; j < NBottom - 1; j++)
//                    //{
//                    //    knotCorner = Mesh.BottomKnots[j];
//                    //    int knot2 = Mesh.BottomKnots[j + 1];
//                    //    if (Mesh.Y[knotCorner] - Mesh.Y[knot2] > 0.0000001)
//                    //        break;
//                    //}
//                    //knotCorner += (NLeft + NRight / 2);
//                    //цикл по внутренним КО
//                    OrderablePartitioner<Tuple<int, int>> rangePartitioner3 = Partitioner.Create(0, CV.Length);
//                    Parallel.ForEach(rangePartitioner3,
//                            (range, loopState) =>
//                            {
//                                for (int i = range.Item1; i < range.Item2; i++)
//                                //for (int i = 0; i < CV.Length; i++)
//                                {
//                                    double LsummU = 0;//потоки U скорости
//                                    double LsummV = 0;//потоки V скорости
//                                    //
//                                    int p0 = CV[i][0];
//                                    int jj = CV[i].Length - 1;//количество КО, связанных с данным узлом
//                                    //if (p0 == knotCorner)
//                                    //    continue;
//                                    for (int j = 0; j < jj; j++)
//                                    {
//                                        double _lx10 = Lx10[i][j]; double _lx32 = Lx32[i][j];
//                                        double _ly01 = Ly01[i][j]; double _ly23 = Ly23[i][j];
//                                        //площадь
//                                        double LS = SS[i][j];
//                                        //сосоедние элементы
//                                        int Lv1 = CV[i][(j + 1) % jj + 1];
//                                        int Lv2 = CV[i][j + 1];
//                                        //вторая точка общей грани
//                                        int Lp1 = P1[i][j];
//                                        //находим значения функций в центрах масс 1ого и 2ого треугольника как средние значения по элементу
//                                        int[] Knots1 = Mesh.AreaElems[Lv1];
//                                        int Lt1 = Knots1[0]; int Lt2 = Knots1[1]; int Lt3 = Knots1[2];
//                                        double LUc1 = (U[Lt1] + U[Lt2] + U[Lt3]) / 3.0;
//                                        double LVc1 = (V[Lt1] + V[Lt2] + V[Lt3]) / 3.0;
//                                        double LPc1 = (P[Lt1] + P[Lt2] + P[Lt3]) / 3.0;
//                                        int[] Knots2 = Mesh.AreaElems[Lv2];
//                                        int Lz1 = Knots2[0]; int Lz2 = Knots2[1]; int Lz3 = Knots2[2];
//                                        double LUc2 = (U[Lz1] + U[Lz2] + U[Lz3]) / 3.0;
//                                        double LVc2 = (V[Lz1] + V[Lz2] + V[Lz3]) / 3.0;
//                                        double LPc2 = (P[Lz1] + P[Lz2] + P[Lz3]) / 3.0;
//                                        //значения производных в точке пересечения граней
//                                        double Ls2 = 2 * LS;
//                                        double Ldudx = ((LUc1 - LUc2) * _ly01 + (U[Lp1] - U[p0]) * _ly23) / Ls2;
//                                        double Ldudy = ((LUc1 - LUc2) * _lx10 + (U[Lp1] - U[p0]) * _lx32) / Ls2;
//                                        double Ldvdx = ((LVc1 - LVc2) * _ly01 + (V[Lp1] - V[p0]) * _ly23) / Ls2;
//                                        double Ldvdy = ((LVc1 - LVc2) * _lx10 + (V[Lp1] - V[p0]) * _lx32) / Ls2;
//                                        double Ldpdx = ((LPc1 - LPc2) * _ly01 + (P[Lp1] - P[p0]) * _ly23) / Ls2;
//                                        double Ldpdy = ((LPc1 - LPc2) * _lx10 + (P[Lp1] - P[p0]) * _lx32) / Ls2;
//                                        //внешняя нормаль к грани КО (контуру КО)
//                                        double Lnx = Nx[i][j]; double Lny = Ny[i][j];
//                                        ////значение функций в точке пересечения грани КО и основной грани
//                                        double Lalpha = Alpha[i][j];
//                                        double LUcr = Lalpha * U[p0] + (1 - Lalpha) * U[Lp1];
//                                        double LVcr = Lalpha * V[p0] + (1 - Lalpha) * V[Lp1];
//                                        double LPcr = Lalpha * P[p0] + (1 - Lalpha) * P[Lp1];
//                                        //длина текущего фрагмента внешнего контура КО
//                                        double LLk = _Lk[i][j];
//                                        //расчет потоков
//                                        double Lpress = -1.0 / rho_w * LPcr * Lnx;
//                                        double LconvU = -LUcr * LUcr * Lnx - (LUcr * LVcr) * Lny;
//                                        double LdiffU = nu * (2.0 * Ldudx * Lnx - 2.0 / 3.0 * (Ldudx + Ldvdy) * Lnx + Ldudy * Lny + Ldvdx * Lny);
//                                        double LregU1 = 2.0 * tau * LUcr * (LUcr * Ldudx + LVcr * Ldudy + 1.0 / rho_w * Ldpdx) * Lnx;
//                                        double LregU2 = tau * (LVcr * (LUcr * Ldudx + LVcr * Ldudy + 1.0 / rho_w * Ldpdx) + LUcr * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0 / rho_w * Ldpdy)) * Lny;
//                                        double LregU = LregU1 + LregU2;
//                                        LsummU += (LconvU + LdiffU + LregU + Lpress) * LLk;
//                                        //                  
//                                        double LpressV = -1.0 / rho_w * LPcr * Lny;
//                                        double LconvV = -(LUcr * LVcr) * Lnx - LVcr * LVcr * Lny;
//                                        double LdiffV = nu * (2.0 * Ldvdy * Lny - 2.0 / 3.0 * (Ldudx + Ldvdy) * Lny + Ldvdx * Lnx + Ldudy * Lnx);
//                                        double LregV1 = 2.0 * tau * LVcr * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0 / rho_w * Ldpdy) * Lny;
//                                        double LregV2 = tau * (LVcr * (LUcr * Ldudx + LVcr * Ldudy + 1.0 / rho_w * Ldpdx) + LUcr * (LUcr * Ldvdx + LVcr * Ldvdy + 1.0 / rho_w * Ldpdy)) * Lnx;
//                                        double LregV = LregV1 + LregV2;
//                                        LsummV += (LconvV + LdiffV + LregV + LpressV) * LLk;
//                                    }
//                                    //
//                                    //lock (lockThis)
//                                    //{
//                                    U[p0] = U[p0] + dt / S0[i] * LsummU;
//                                    V[p0] = V[p0] + dt / S0[i] * LsummV;
//                                    //
//                                    if ((U[p0] > 10000) || (double.IsNaN(U[p0])))
//                                    {
//                                        err = " U в бесконечность";
//                                        //iteration = iter;
//                                        return;
//                                    }
//                                    //}

//                                }

//                            });


//                    //U[knotCorner] = U[knotCorner - 1];
//                    //если задача со свободной поверхностью
//                    if (surf_flag)
//                        U[BLeftKnots[0]] = U[BTopKnots[BTopKnots.Length - 2]];
//                    //ГУ на правой стенке - по КО
//                    //for (int i = 0; i < NRight - 2; i++)
//                    //{
//                    //    knot = RightKnotsList[i][0];
//                    //    count = RightKnotsList[i].Length - 1;
//                    //    sumBU = 0;
//                    //    sumBV = 0;
//                    //    for (int m = 0; m < count; m++)
//                    //    {
//                    //        sumBU += (double)1 / count * U[RightKnotsList[i][m + 1]];
//                    //        sumBV += (double)1 / count * V[RightKnotsList[i][m + 1]];
//                    //    }
//                    //    U[knot] = sumBU;
//                    //    V[knot] = sumBV;
//                    //}
//                    //
//                    //ГУ Dong
//                    //if (iteration == iter - 1)
//                    //    DongBC_UE();
//                    //else
//                    //    DongBC_U();
//                    //ГУ справа - снос
//                    for (int i = 0; i < NRight; i++)
//                    {
//                        knot = BRightKnots[i];
//                        //
//                        U[knot] = U[knot - NRight];
//                        V[knot] = V[knot - NRight];
//                    }
//                    //
//                    //
//                    //TEST - на вход то же, что и на выходе
//                    //for (int i = 0; i < NLeft; i++)
//                    //{
//                    //    int r = BRightKnots[i];
//                    //    int l = BLeftKnots[NLeft - i - 1];
//                    //    U[l] = U[r];
//                    //}
//                    //for (int i = 0; i < NLeft; i++)
//                    //{
//                    //    int r = BRightKnots[i];
//                    //    int l = BLeftKnots[NLeft - i - 1];
//                    //    U[r] = U[l];
//                    //}
//                    ////----------------
//                    //если задача со свободной поверхностью
//                    if (surf_flag)
//                    {
//                        //ГУ на верхней стенке 
//                        for (int i = 0; i < NTop - 2; i++)
//                        {
//                            knot = TopKnotsList[i][0];
//                            count = TopKnotsList[i].Length - 1;
//                            sumBU = 0;
//                            for (int m = 0; m < count; m++)
//                                sumBU += (double)1 / count * U[TopKnotsList[i][m + 1]];
//                            //    
//                            U[knot] = sumBU;
//                        }
//                        //
//                        knotUp = Mesh.TopKnots[1];
//                        knotRightU = BRightKnots[NRight - 1];
//                        U[knotRightU] = U[knotUp];
//                        //
//                        knotDown = BBottomKnots[NBottom - 2];
//                        knotRightD = BRightKnots[0];
//                        U[knotRightD] = U[knotDown];
//                    }
//                    //

//                    #endregion
//                    // 
//                    for (int i = 0; i < CountKnots; i++)
//                    {
//                        buffU[i] = U[i];
//                        buffV[i] = V[i];
//                    }
//                    //ГУ Фомин
//                    //вычисление коррекции скорости на выходе
//                    //расходы на границах
//                    //Q_in = 0; Q_out = 0;
//                    //double Qaout = 0;
//                    //double[] _dy = new double[NLeft];
//                    //int _b0 = 0, _b1 = 0;
//                    //for (int i = 1; i < _Ny - 1; i++)
//                    //{
//                    //    _b0 = BLeftKnots[i - 1];
//                    //    _b1 = BLeftKnots[i + 1];
//                    //    //
//                    //    _dy[i] = (Y[_b0] - Y[_b1]) / 2.0;
//                    //}
//                    //_dy[0] = (Y[BLeftKnots[0]] - Y[BLeftKnots[1]]);
//                    //_dy[NLeft - 1] = (Y[BLeftKnots[NLeft - 2]] - Y[BLeftKnots[NLeft - 1]]);
//                    ////
//                    //for (int i = 0; i < _Ny; i++)
//                    //{
//                    //    Q_in += U[BLeftKnots[NLeft - 1 - i]] * _dy[i];
//                    //    Q_out += U[BRightKnots[i]] * _dy[i];
//                    //    Qaout += Math.Abs(U[BRightKnots[i]] * _dy[i]);
//                    //}
//                    //// корректирующий коэффициент
//                    //double alphaM = 0.1;
//                    //double alphaOut = Math.Max(-alphaM, Math.Min(alphaM, (Q_in - Q_out) / Qaout));
//                    //double bufU;
//                    //for (int i = 0; i < _Ny; i++)
//                    //{
//                    //    bufU = buffU[BRightKnots[i]];
//                    //    U[BRightKnots[i]] = (1 + Math.Sign(bufU) * alphaOut) * bufU;
//                    //}
//                    ////вычисление значения фиктивного источника
//                    //Q_out = 0;
//                    //for (int i = 0; i < _Ny; i++)
//                    //    Q_out += U[BRightKnots[i]] * _dy[i];
//                    //double H = Y[BLeftKnots[0]] - Y[BLeftKnots[NLeft - 1]];
//                    //double L = X[BBottomKnots[NBottom - 1]] - X[BBottomKnots[0]];
//                    //qf = (Q_out - Q_in) / (H * L);
//                    //
//                    //
//                    //выход из цикла если ошибка меньше или равно errP
//                    //if (MaxError <= errP)
//                    //{
//                    //    Iter = iteration + 1;
//                    //    break;
//                    //}
//                    //
//                    beginIter = iteration + 1;
//                    if (SerializeNow)
//                    {
//                        status = "Stoped";
//                        return;
//                    }
//                    Iter = iteration + 1;
//                    //Q_in = 0; Q_out = 0;
//                    //for (int k = 0; k < NLeft - 1; k++)
//                    //{
//                    //    int a = BLeftKnots[k];
//                    //    int b = BLeftKnots[k + 1];
//                    //    Q_in += (U[a] + U[b]) * 0.5f * Math.Abs(Y[a] - Y[b]);
//                    //}
//                    ////
//                    //for (int k = 1; k < NRight - 1; k++)
//                    //{
//                    //    int a = BRightKnots[k];
//                    //    int b = BRightKnots[k + 1];
//                    //    Q_out += (U[a] + U[b]) * 0.5f * Math.Abs(Y[a] - Y[b]);
//                    //}
//                }
//                //Iter = iter;
//                //расход на входе и выходе из расчетной области
//                beginIter = 0;
//                Q_in = 0; Q_out = 0;
//                for (int k = 0; k < NLeft - 1; k++)
//                {
//                    int a = BLeftKnots[k];
//                    int b = BLeftKnots[k + 1];
//                    Q_in += (U[a] + U[b]) * 0.5f * Math.Abs(Y[a] - Y[b]);
//                }
//                //
//                for (int k = 1; k < NRight - 1; k++)
//                {
//                    int a = BRightKnots[k];
//                    int b = BRightKnots[k + 1];
//                    Q_out += (U[a] + U[b]) * 0.5f * Math.Abs(Y[a] - Y[b]);
//                }
//            }
//            catch (Exception ex)
//            {
//                err = err + "WaterTask.Run " + ex.Message;
//            }
//            //вычисление сдвиговых напряжений на дне
//            //ShearStresses();
//            //ShearStress(BBottomKnots, CBottom, BTriangles, out BTau, out BTauС, out arg);
//            //ShearStress(BTopKnots, CTop, TTriangles, out TTau, out TTauС, out argT);
//        }
//        //----Тест        ///
//        public double[] p_conv, p_kinet;
//        public double[] u_press, u_kinet, u_cont;
//        private void DongBC_UE(double delta = 0.05)
//        {
//            u_cont = new double[NRight];
//            u_kinet = new double[NRight];
//            u_press = new double[NRight];
//            //
//            int knot = BRightKnots[0];
//            double du = 0, dv = 0;
//            double dx = (X[knot] - X[knot - NRight]);
//            double dy = (Y[knot + 2] - Y[knot + 1]);
//            for (int i = 1; i < NRight - 1; i++)
//            {
//                knot = BRightKnots[i];
//                du = (U[knot] - U[knot - NRight]) / dx;
//                if (V[knot] < 0)
//                    dv = (V[knot] - V[knot - 1]) / dy;
//                else
//                    dv = (V[knot + 1] - V[knot]) / dy;
//                u_press[i] = 1.0 / mu * P[knot];
//                u_kinet[i] = rho_w / 4.0 / mu * (U[knot] * U[knot] + V[knot] * V[knot]) * (1 - Math.Tanh(+U[knot] / Ucp / delta));
//                u_cont[i] = du + dv;
//                U[knot] = U[knot - NRight] + dx * (u_press[i] + u_kinet[i] - u_cont[i]);
//                V[knot] = V[knot - NRight];
//            }
//        }

//        private void DongBC_PE(double delta = 0.05)
//        {
//            p_conv = new double[NRight];
//            p_kinet = new double[NRight];
//            //
//            int knot = 0;
//            for (int i = 0; i < NRight; i++)
//            {
//                RBC[i] = 0;
//                knot = BRightKnots[i];
//                p_kinet[i] = 0.25 * rho_w * (U[knot] * U[knot] + V[knot] * V[knot]) * (1 - Math.Tanh(U[knot] / Ucp / delta));
//                p_conv[i] = mu * (U[knot] - U[knot - NRight]) / (X[knot] - X[knot - NRight]);
//                //
//                RBC[i] = p_conv[i] - p_kinet[i];
//            }
//            RBC[0] = RBC[1];
//            RBC[NRight - 1] = RBC[NRight - 2];
//            //
//            p_kinet[0] = p_kinet[1];
//            p_conv[0] = p_conv[1];
//            p_kinet[NRight - 1] = p_kinet[NRight - 2];
//            p_conv[NRight - 1] = p_conv[NRight - 2];
//        }
//        //----  ///
//        private void DongBC_U(double delta = 0.05)
//        {
//            int knot = BRightKnots[0];
//            double du = 0, dv = 0;
//            double dx = (X[knot] - X[knot - NRight]);
//            double dy = (Y[knot + 2] - Y[knot + 1]);
//            for (int i = 1; i < NRight - 1; i++)
//            {
//                knot = BRightKnots[i];
//                du = (U[knot] - U[knot - NRight]) / dx;
//                if (V[knot] < 0)
//                    dv = (V[knot] - V[knot - 1]) / dy;
//                else
//                    dv = (V[knot + 1] - V[knot]) / dy;
//                U[knot] = U[knot - NRight] + dx / mu * (P[knot] + rho_w / 4.0 * (U[knot] * U[knot] + V[knot] * V[knot]) * (1 - Math.Tanh(+U[knot] / Ucp / delta))) - dx * (du + dv);
//                V[knot] = V[knot - NRight];
//            }
//        }

//        private void DongBC_P(double delta = 0.05)
//        {
//            int knot = 0;
//            for (int i = 0; i < NRight; i++)
//            {
//                RBC[i] = 0;
//                knot = BRightKnots[i];
//                RBC[i] = mu * (U[knot] - U[knot - NRight]) / (X[knot] - X[knot - NRight]) - 0.25 * rho_w * (U[knot] * U[knot] + V[knot] * V[knot]) * (1 - Math.Tanh(U[knot] / Ucp / delta));
//            }
//            RBC[0] = RBC[1];
//            RBC[NRight - 1] = RBC[NRight - 2];
//        }
//        //
//        //
//        /// <summary>
//        /// нахождение размерного касательного напряжения на дне
//        /// </summary>
//        void ShearStresses()
//        {
//            System.Object lockThis = new System.Object();
//            //
//            int IndexMethod = 0;// через ленту tau_l
//            IndexMethod = 2;// через ленту тензор TT
//            //IndexMethod = 1;// через конечные разности -  для сильновырожденной области не годится
//            try
//            {
//                if (IndexMethod == 2)
//                {
//                    //компоненты тензора напряжений
//                    double[] Tx1 = new double[BTriangles.Length];
//                    double[] Tx2 = new double[BTriangles.Length];
//                    double[] Ty1 = new double[BTriangles.Length];
//                    double[] Ty2 = new double[BTriangles.Length];
//                    //
//                    double[] tau_mid = new double[BTriangles.Length];
//                    //double e1x = 1, e1y = 0, e2x = 0, e2y = 1;//проекции
//                    //
//                    OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, BTriangles.Length);
//                    Parallel.ForEach(rangePartitioner,
//                           (range, loopState) =>
//                           {
//                               for (int i = range.Item1; i < range.Item2; i++)
//                               //for (int i = 0; i < BTriangles.Length; i++)
//                               {

//                                   double[] xL = new double[3];
//                                   double[] yL = new double[3];
//                                   //
//                                   int LcurV = BTriangles[i];
//                                   int[] Knots = Mesh.AreaElems[LcurV];
//                                   //
//                                   int Lnum1 = Knots[0];
//                                   int Lnum2 = Knots[1];
//                                   int Lnum3 = Knots[2];
//                                   // получаем координаты узлов элемента
//                                   xL[0] = X[Lnum1]; xL[1] = X[Lnum2]; xL[2] = X[Lnum3];
//                                   yL[0] = Y[Lnum1]; yL[1] = Y[Lnum2]; yL[2] = Y[Lnum3];
//                                   // нахождение площади треугольника
//                                   double LS = Sk[LcurV];
//                                   // скорости в вершинах треугольника
//                                   double LU1 = U[Lnum1];
//                                   double LU2 = U[Lnum2];
//                                   double LU3 = U[Lnum3];
//                                   //
//                                   double LV1 = V[Lnum1];
//                                   double LV2 = V[Lnum2];
//                                   double LV3 = V[Lnum3];
//                                   // производные в центре треугольника
//                                   double Ldu_dx = 1.0f / 2.0f / LS * (LU1 * (yL[1] - yL[2]) + LU2 * (yL[2] - yL[0]) + LU3 * (yL[0] - yL[1]));
//                                   double Ldu_dy = 1.0f / 2.0f / LS * (LU1 * (xL[2] - xL[1]) + LU2 * (xL[0] - xL[2]) + LU3 * (xL[1] - xL[0]));
//                                   double Ldv_dx = 1.0f / 2.0f / LS * (LV1 * (yL[1] - yL[2]) + LV2 * (yL[2] - yL[0]) + LV3 * (yL[0] - yL[1]));
//                                   double Ldv_dy = 1.0f / 2.0f / LS * (LV1 * (xL[2] - xL[1]) + LV2 * (xL[0] - xL[2]) + LV3 * (xL[1] - xL[0]));
//                                   // давление в центре треугольника
//                                   double LP_mid = (P[Lnum1] + P[Lnum2] + P[Lnum3]) / 3.0f;
//                                   // составляющие тензора напряжений
//                                   Tx1[i] = -LP_mid + 2.0f * mu * Ldu_dx;
//                                   Tx2[i] = mu * (Ldu_dy + Ldv_dx);
//                                   Ty1[i] = mu * (Ldu_dy + Ldv_dx);
//                                   Ty2[i] = -LP_mid + 2.0f * mu * Ldv_dy;
//                               }
//                           });
//                    // Вычисление tau в узлах сетки по сглаженной методике вычисления 
//                    //double[] Tau_all = Aproximate(tau_mid, CBottom, BTriangles);

//                    //вычисление тензора напряжений по сглаженной методике
//                    double[] Tx1_all = Aproximate(Tx1, CBottom, BTriangles);
//                    double[] Tx2_all = Aproximate(Tx2, CBottom, BTriangles);
//                    double[] Ty1_all = Aproximate(Ty1, CBottom, BTriangles);
//                    double[] Ty2_all = Aproximate(Ty2, CBottom, BTriangles);
//                    //подготовка приграничных значений tau между граничными точками и координат для сплайна
//                    int count = BBottomKnots.Length;
//                    BTau = new double[count];
//                    BTauС = new double[count];
//                    arg = new double[count - 1];
//                    int cKnot = BBottomKnots[0];
//                    double prevTx1 = 0, prevTx2 = 0, prevTy1 = 0, prevTy2 = 0;
//                    //
//                    for (int i = 0; i < BBottomKnots.Length; i++)
//                    {
//                        cKnot = BBottomKnots[i];
//                        for (int j = 0; j < CBottom.Length; j++)
//                        {
//                            if (cKnot == CBottom[j])
//                            {
//                                if (i != 0)
//                                {
//                                    int prevKnot = BBottomKnots[i - 1];
//                                    double delx = (X[cKnot] - X[prevKnot]);
//                                    double dely = (Y[cKnot] - Y[prevKnot]);
//                                    double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
//                                    // компоненты касательной между граничными точками
//                                    double lx = 1 / ss * delx;
//                                    double ly = 1 / ss * dely;
//                                    double nx = -ly;
//                                    double ny = lx;
//                                    //
//                                    double LsigX = (prevTx1 + Tx1_all[j]) / 2.0f * nx + (prevTx2 + Tx2_all[j]) / 2.0f * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
//                                    double LsigY = (prevTy1 + Ty1_all[j]) / 2.0f * nx + (prevTy2 + Ty2_all[j]) / 2.0f * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
//                                    //double LsigX = 2 * prevTx1 * Tx1_all[j] / (prevTx1 + Tx1_all[j]) * nx + 2 * prevTx2 * Tx2_all[j] / (prevTx2 + Tx2_all[j]) * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
//                                    //double LsigY = 2 * prevTy1 * Ty1_all[j] / (prevTy1 + Ty1_all[j]) * nx + 2 * prevTy2 * Ty2_all[j] / (prevTy2 + Ty2_all[j]) * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
//                                    //в полуцелых узлах
//                                    BTau[i - 1] = (LsigX * lx + LsigY * ly);
//                                    arg[i - 1] = X[prevKnot] + delx / 2.0f;
//                                    //
//                                    LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
//                                    LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
//                                    BTauС[i] = (LsigX * lx + LsigY * ly);

//                                }
//                                else
//                                {
//                                    int nextKnot = BBottomKnots[i + 1];
//                                    double delx = (X[nextKnot] - X[cKnot]);
//                                    double dely = (Y[nextKnot] - Y[cKnot]);
//                                    double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
//                                    // компоненты касательной между граничными точками
//                                    double lx = 1 / ss * delx;
//                                    double ly = 1 / ss * dely;
//                                    double nx = -ly;
//                                    double ny = lx;
//                                    //
//                                    double LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
//                                    double LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
//                                    BTauС[i] = (LsigX * lx + LsigY * ly);
//                                }
//                                //
//                                prevTx1 = Tx1_all[j];
//                                prevTx2 = Tx2_all[j];
//                                prevTy1 = Ty1_all[j];
//                                prevTy2 = Ty2_all[j];
//                                break;
//                            }
//                        }
//                    }
//                    BTau[count - 1] = BTau[count - 2];
//                    /////
//                    Tx1 = new double[TTriangles.Length];
//                    Tx2 = new double[TTriangles.Length];
//                    Ty1 = new double[TTriangles.Length];
//                    Ty2 = new double[TTriangles.Length];
//                    //
//                    tau_mid = new double[TTriangles.Length];
//                    //double e1x = 1, e1y = 0, e2x = 0, e2y = 1;//проекции
//                    //
//                    rangePartitioner = Partitioner.Create(0, TTriangles.Length);
//                    Parallel.ForEach(rangePartitioner,
//                           (range, loopState) =>
//                           {
//                               for (int i = range.Item1; i < range.Item2; i++)
//                               //for (int i = 0; i < BTriangles.Length; i++)
//                               {

//                                   double[] xL = new double[3];
//                                   double[] yL = new double[3];
//                                   //
//                                   int LcurV = TTriangles[i];
//                                   int[] Knots = Mesh.AreaElems[LcurV];
//                                   //
//                                   int Lnum1 = Knots[0];
//                                   int Lnum2 = Knots[1];
//                                   int Lnum3 = Knots[2];
//                                   // получаем координаты узлов элемента
//                                   xL[0] = X[Lnum1]; xL[1] = X[Lnum2]; xL[2] = X[Lnum3];
//                                   yL[0] = Y[Lnum1]; yL[1] = Y[Lnum2]; yL[2] = Y[Lnum3];
//                                   // нахождение площади треугольника
//                                   double LS = Sk[LcurV];
//                                   // скорости в вершинах треугольника
//                                   double LU1 = U[Lnum1];
//                                   double LU2 = U[Lnum2];
//                                   double LU3 = U[Lnum3];
//                                   //
//                                   double LV1 = V[Lnum1];
//                                   double LV2 = V[Lnum2];
//                                   double LV3 = V[Lnum3];
//                                   // производные в центре треугольника
//                                   double Ldu_dx = 1.0f / 2.0f / LS * (LU1 * (yL[1] - yL[2]) + LU2 * (yL[2] - yL[0]) + LU3 * (yL[0] - yL[1]));
//                                   double Ldu_dy = 1.0f / 2.0f / LS * (LU1 * (xL[2] - xL[1]) + LU2 * (xL[0] - xL[2]) + LU3 * (xL[1] - xL[0]));
//                                   double Ldv_dx = 1.0f / 2.0f / LS * (LV1 * (yL[1] - yL[2]) + LV2 * (yL[2] - yL[0]) + LV3 * (yL[0] - yL[1]));
//                                   double Ldv_dy = 1.0f / 2.0f / LS * (LV1 * (xL[2] - xL[1]) + LV2 * (xL[0] - xL[2]) + LV3 * (xL[1] - xL[0]));
//                                   // давление в центре треугольника
//                                   double LP_mid = (P[Lnum1] + P[Lnum2] + P[Lnum3]) / 3.0f;
//                                   // составляющие тензора напряжений
//                                   Tx1[i] = -LP_mid + 2.0f * mu * Ldu_dx;
//                                   Tx2[i] = mu * (Ldu_dy + Ldv_dx);
//                                   Ty1[i] = mu * (Ldu_dy + Ldv_dx);
//                                   Ty2[i] = -LP_mid + 2.0f * mu * Ldv_dy;
//                               }
//                           });
//                    // Вычисление tau в узлах сетки по сглаженной методике вычисления 
//                    //double[] Tau_all = Aproximate(tau_mid, CBottom, BTriangles);

//                    //вычисление тензора напряжений по сглаженной методике
//                    Tx1_all = Aproximate(Tx1, CTop, TTriangles);
//                    Tx2_all = Aproximate(Tx2, CTop, TTriangles);
//                    Ty1_all = Aproximate(Ty1, CTop, TTriangles);
//                    Ty2_all = Aproximate(Ty2, CTop, TTriangles);
//                    //подготовка приграничных значений tau между граничными точками и координат для сплайна
//                    count = BTopKnots.Length;
//                    TTau = new double[count];
//                    TTauС = new double[count];
//                    argT = new double[count - 1];
//                    cKnot = BTopKnots[0];
//                    prevTx1 = 0; prevTx2 = 0; prevTy1 = 0; prevTy2 = 0;
//                    //
//                    for (int i = 0; i < BTopKnots.Length; i++)
//                    {
//                        cKnot = BTopKnots[i];
//                        for (int j = 0; j < CTop.Length; j++)
//                        {
//                            if (cKnot == CTop[j])
//                            {
//                                if (i != 0)
//                                {
//                                    int prevKnot = BTopKnots[i - 1];
//                                    double delx = (X[cKnot] - X[prevKnot]);
//                                    double dely = (Y[cKnot] - Y[prevKnot]);
//                                    double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
//                                    // компоненты касательной между граничными точками
//                                    double lx = 1 / ss * delx;
//                                    double ly = 1 / ss * dely;
//                                    double nx = -ly;
//                                    double ny = lx;
//                                    //
//                                    double LsigX = (prevTx1 + Tx1_all[j]) / 2.0f * nx + (prevTx2 + Tx2_all[j]) / 2.0f * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
//                                    double LsigY = (prevTy1 + Ty1_all[j]) / 2.0f * nx + (prevTy2 + Ty2_all[j]) / 2.0f * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
//                                    //в полуцелых узлах
//                                    TTau[i - 1] = (LsigX * lx + LsigY * ly);
//                                    argT[i - 1] = X[prevKnot] + delx / 2.0f;
//                                    //
//                                    LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
//                                    LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
//                                    TTauС[i] = (LsigX * lx + LsigY * ly);

//                                }
//                                else
//                                {
//                                    int nextKnot = BTopKnots[i + 1];
//                                    double delx = (X[nextKnot] - X[cKnot]);
//                                    double dely = (Y[nextKnot] - Y[cKnot]);
//                                    double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
//                                    // компоненты касательной между граничными точками
//                                    double lx = 1 / ss * delx;
//                                    double ly = 1 / ss * dely;
//                                    double nx = -ly;
//                                    double ny = lx;
//                                    //
//                                    double LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
//                                    double LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
//                                    TTauС[i] = (LsigX * lx + LsigY * ly);
//                                }
//                                //
//                                prevTx1 = Tx1_all[j];
//                                prevTx2 = Tx2_all[j];
//                                prevTy1 = Ty1_all[j];
//                                prevTy2 = Ty2_all[j];
//                                break;
//                            }
//                        }
//                    }
//                    TTau[count - 1] = TTau[count - 2];

//                }
//                if (IndexMethod == 0) //!!!-- 1 ый порядок точности, для Tau в целых и полуцелых узлах надо использовать через сплайн!
//                {
//                    //
//                    double[] tau_mid = new double[BTriangles.Length];
//                    //
//                    OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, BTriangles.Length);
//                    Parallel.ForEach(rangePartitioner,
//                           (range, loopState) =>
//                           {
//                               for (int i = range.Item1; i < range.Item2; i++)
//                               //for (int i = 0; i < BTriangles.Length; i++)
//                               {

//                                   double[] xL = new double[3];
//                                   double[] yL = new double[3];
//                                   //
//                                   int LcurV = BTriangles[i];
//                                   int[] Knots = Mesh.AreaElems[LcurV];
//                                   //
//                                   int Lnum1 = Knots[0];
//                                   int Lnum2 = Knots[1];
//                                   int Lnum3 = Knots[2];
//                                   // получаем координаты узлов элемента
//                                   xL[0] = X[Lnum1]; xL[1] = X[Lnum2]; xL[2] = X[Lnum3];
//                                   yL[0] = Y[Lnum1]; yL[1] = Y[Lnum2]; yL[2] = Y[Lnum3];
//                                   // нахождение площади треугольника
//                                   double LS = Sk[LcurV];
//                                   // скорости в вершинах треугольника
//                                   double LU1 = U[Lnum1];
//                                   double LU2 = U[Lnum2];
//                                   double LU3 = U[Lnum3];
//                                   //
//                                   double LV1 = V[Lnum1];
//                                   double LV2 = V[Lnum2];
//                                   double LV3 = V[Lnum3];
//                                   // касательный вектор (обход против часовой стрелки)
//                                   double Lsx = Sx[i];
//                                   double Lsy = Sy[i];
//                                   // нормаль (направлена во внутрь КО)
//                                   double Lnx = -Lsy;
//                                   double Lny = Lsx;
//                                   // производные в центре треугольника
//                                   double Ldu_dx = 1.0f / 2.0f / LS * (LU1 * (yL[1] - yL[2]) + LU2 * (yL[2] - yL[0]) + LU3 * (yL[0] - yL[1]));
//                                   double Ldu_dy = 1.0f / 2.0f / LS * (LU1 * (xL[2] - xL[1]) + LU2 * (xL[0] - xL[2]) + LU3 * (xL[1] - xL[0]));
//                                   double Ldv_dx = 1.0f / 2.0f / LS * (LV1 * (yL[1] - yL[2]) + LV2 * (yL[2] - yL[0]) + LV3 * (yL[0] - yL[1]));
//                                   double Ldv_dy = 1.0f / 2.0f / LS * (LV1 * (xL[2] - xL[1]) + LV2 * (xL[0] - xL[2]) + LV3 * (xL[1] - xL[0]));
//                                   // давление в центре треугольника
//                                   double LP_mid = (P[Lnum1] + P[Lnum2] + P[Lnum3]) / 3.0f;
//                                   // составляющие тензора напряжений
//                                   double Tx1 = -LP_mid + 2.0f * mu * Ldu_dx;
//                                   double Tx2 = mu * (Ldu_dy + Ldv_dx);
//                                   double Ty1 = mu * (Ldu_dy + Ldv_dx);
//                                   double Ty2 = -LP_mid + 2.0f * mu * Ldv_dy;
//                                   // компоненты вектора придонного напряжения
//                                   double LsigX = Tx1 * Lnx + Tx2 * Lny;
//                                   double LsigY = Ty1 * Lnx + Ty2 * Lny;
//                                   //
//                                   tau_mid[i] = (LsigX * Lsx + LsigY * Lsy);
//                               }
//                           });

//                    // Вычисление tau в узлах сетки по сглаженной методике вычисления 
//                    double[] Tau_all = Aproximate(tau_mid, CBottom, BTriangles);
//                    //
//                    //подготовка приграничных значений tau между граничными точками и координат для сплайна
//                    int count = BBottomKnots.Length;
//                    BTau = new double[count];
//                    arg = new double[count];
//                    int cKnot;
//                    //
//                    for (int i = 0; i < BBottomKnots.Length; i++)
//                    {
//                        cKnot = BBottomKnots[i];
//                        for (int j = 0; j < CBottom.Length; j++)
//                        {
//                            if (cKnot == CBottom[j])
//                            {

//                                BTau[i] = Tau_all[j];
//                                arg[i] = X[cKnot]; // аргумент - только X (чтобы легче проецировать на дно)
//                                //arg[i] = Math.Sqrt(X[cKnot] * X[cKnot] + Y[cKnot] * Y[cKnot]);
//                                break;
//                            }
//                        }
//                    }
//                }
//                //
//                if (IndexMethod == 1)//!!!-- 1 ый порядок точности, для Tau в целых и полуцелых узлах надо использовать через сплайн!
//                {
//                    //подготовка приграничных значений tau между граничными точками и координат для сплайна
//                    arg = new double[BBottomKnots.Length];
//                    //
//                    OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(1, BBottomKnots.Length - 1);
//                    Parallel.ForEach(rangePartitioner,
//                           (range, loopState) =>
//                           {
//                               for (int i = range.Item1; i < range.Item2; i++)
//                               //for (int i = 1; i < BBottomKnots.Length - 1; i++)
//                               {
//                                   //
//                                   //           nnK(2)
//                                   //            |
//                                   //           nK(1)
//                                   //            |
//                                   //--wK(3)---cKnot(0)---eK(4)
//                                   int cKnot = BBottomKnots[i];
//                                   int wK = BBottomKnots[i - 1];
//                                   int eK = BBottomKnots[i + 1];
//                                   int nK = 0, nnK = 0;
//                                   double delx = (X[eK] - X[wK]);
//                                   double dely = (Y[eK] - Y[wK]);
//                                   double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
//                                   // компоненты касательной между граничными точками
//                                   double lx = 1 / ss * delx;
//                                   double ly = 1 / ss * dely;
//                                   //нормаль к поверхности между узлами wK и eK
//                                   double nx = -ly;
//                                   double ny = lx;
//                                   //
//                                   double Ldu_dx = 0;
//                                   double Ldu_dy = 0;
//                                   double Ldv_dx = 0;
//                                   double Ldv_dy = 0;
//                                   double P_c = 0;
//                                   //если дно почти горизонтальное, то считаем, что оно горизонтальное
//                                   if (lx > 0.98)
//                                   {
//                                       nK = cKnot + 1;
//                                       nnK = cKnot + 2;
//                                       //x - это y(координата), y - это U (функция)
//                                       double x0 = Y[cKnot];
//                                       double y0 = U[cKnot];
//                                       double x1 = Y[nK];
//                                       double y1 = U[nK];
//                                       double x2 = Y[nnK];
//                                       double y2 = U[nnK];
//                                       Ldu_dy = 1.0f / (x0 - x1) * y0 + 1.0f / (x0 - x2) * y0 + 1.0f / (x1 - x0) * (x0 - x2) / (x1 - x2) * y1 + 1.0f / (x2 - x0) * (x0 - x1) / (x2 - x1) * y2;
//                                       //функция V - это y
//                                       y0 = V[cKnot];
//                                       y1 = V[nK];
//                                       y2 = V[nnK];
//                                       Ldv_dy = 1.0f / (x0 - x1) * y0 + 1.0f / (x0 - x2) * y0 + 1.0f / (x1 - x0) * (x0 - x2) / (x1 - x2) * y1 + 1.0f / (x2 - x0) * (x0 - x1) / (x2 - x1) * y2;
//                                       Ldv_dx = 0;
//                                       Ldu_dx = 0;
//                                   }
//                                   // если дно не горизонтальное
//                                   else
//                                   {

//                                       double k = dy;
//                                       FPoint[] PointsNorm = new FPoint[2];
//                                       FPoint[] PointsTang = new FPoint[2];
//                                       double[] U12 = new double[2]; double[] V12 = new double[2];
//                                       double[] U34 = new double[2]; double[] V34 = new double[2];
//                                       //
//                                       for (int j = 0; j < 2; j++)
//                                       {
//                                           //точка на расстоянии k по направлению нормали
//                                           PointsNorm[j] = new FPoint(X[cKnot] + nx * k * (j + 1), Y[cKnot] + ny * k * (j + 1));
//                                           //
//                                           int Triangle = Mesh.GetTriangle(PointsNorm[j].X, PointsNorm[j].Y);
//                                           //
//                                           double s05 = 1.0f / 2.0f / Sk[Triangle];
//                                           int[] Knots = Mesh.AreaElems[Triangle];
//                                           double x1 = X[Knots[0]]; double x2 = X[Knots[1]]; double x3 = X[Knots[2]];
//                                           double y1 = Y[Knots[0]]; double y2 = Y[Knots[1]]; double y3 = Y[Knots[2]];
//                                           double L1 = s05 * ((x2 * y3 - x3 * y2) + PointsNorm[j].X * (y2 - y3) + PointsNorm[j].Y * (x3 - x2));
//                                           double L2 = s05 * ((x3 * y1 - x1 * y3) + PointsNorm[j].X * (y3 - y1) + PointsNorm[j].Y * (x1 - x3));
//                                           double L3 = s05 * ((x1 * y2 - x2 * y1) + PointsNorm[j].X * (y1 - y2) + PointsNorm[j].Y * (x2 - x1));
//                                           //
//                                           U12[j] = L1 * U[Knots[0]] + L2 * U[Knots[1]] + L3 * U[Knots[2]];
//                                           V12[j] = L1 * V[Knots[0]] + L2 * V[Knots[1]] + L3 * V[Knots[2]];
//                                       }
//                                       //аппроксимация по 4 точкам
//                                       //double dPhids = (2 * PhiNormal[0] - 5 * PhiNormal[1] + 4 * PhiNormal[2] - PhiNormal[3]) / k / k;
//                                       //аппрроксимация по трем точкам
//                                       Ldu_dy = (-7 * U[cKnot] + 8 * U12[0] - U12[1]) / k / k / 2.0f;
//                                       Ldv_dy = (-7 * V[cKnot] + 8 * V12[0] - V12[1]) / k / k / 2.0f;
//                                       //
//                                       //точка на расстоянии k по обоим направлениям по касательной от точки cKnot
//                                       PointsTang[0] = new FPoint(X[cKnot] - lx * k, Y[cKnot] - ly * k);
//                                       PointsTang[1] = new FPoint(X[cKnot] + lx * k, Y[cKnot] + ly * k);
//                                       //
//                                       for (int j = 0; j < 2; j++)
//                                       {
//                                           int Triangle = Mesh.GetTriangle(PointsTang[j].X, PointsTang[j].Y);
//                                           //если область вогнутая, то хотя бы одна точка вдоль касательной бдует лежать вне области
//                                           // здесь в таком случае влияние производных U и V  вдоль касательной не учитываем
//                                           if (Triangle == -1)
//                                           {
//                                               U34[0] = 0; U34[1] = 0;
//                                               V34[0] = 0; V34[1] = 0;
//                                               break;
//                                           }
//                                           //
//                                           double s05 = 1.0f / 2.0f / Sk[Triangle];
//                                           int[] Knots = Mesh.AreaElems[Triangle];
//                                           double x1 = X[Knots[0]]; double x2 = X[Knots[1]]; double x3 = X[Knots[2]];
//                                           double y1 = Y[Knots[0]]; double y2 = Y[Knots[1]]; double y3 = Y[Knots[2]];
//                                           double L1 = s05 * ((x2 * y3 - x3 * y2) + PointsNorm[j].X * (y2 - y3) + PointsNorm[j].Y * (x3 - x2));
//                                           double L2 = s05 * ((x3 * y1 - x1 * y3) + PointsNorm[j].X * (y3 - y1) + PointsNorm[j].Y * (x1 - x3));
//                                           double L3 = s05 * ((x1 * y2 - x2 * y1) + PointsNorm[j].X * (y1 - y2) + PointsNorm[j].Y * (x2 - x1));
//                                           //
//                                           U34[j] = L1 * U[Knots[0]] + L2 * U[Knots[1]] + L3 * U[Knots[2]];
//                                           V34[j] = L1 * V[Knots[0]] + L2 * V[Knots[1]] + L3 * V[Knots[2]];

//                                       }
//                                       Ldu_dx = (U34[1] - U34[0]) / k / 2.0f;
//                                       Ldv_dx = (V34[1] - V34[0]) / k / 2.0f;

//                                   }
//                                   //
//                                   // давление в узле
//                                   P_c = P[cKnot];
//                                   // составляющие тензора напряжений
//                                   double Tx1 = -P_c + 2.0f * mu * Ldu_dx;
//                                   double Tx2 = mu * (Ldu_dy + Ldv_dx);
//                                   double Ty1 = mu * (Ldu_dy + Ldv_dx);
//                                   double Ty2 = -P_c + 2.0f * mu * Ldv_dy;
//                                   // компоненты вектора придонного напряжения
//                                   double LsigX = Tx1 * nx + Tx2 * ny;
//                                   double LsigY = Ty1 * nx + Ty2 * ny;
//                                   // проекция вектора придонного напряжения на касательный вектор
//                                   BTau[i] = (LsigX * lx + LsigY * ly);
//                                   arg[i] = X[cKnot];

//                                   //1/(x0-x1)*y0+1/(x0-x2)*y0+1/(x1-x0)*(x0-x2)/(x1-x2)*y1+1/(x2-x0)*(x0-x1)/(x2-x1)*y2

//                               }
//                           });
//                    //
//                }
//            }
//            catch (Exception e)
//            {
//                err = e.Message + "ShearStressesCalculation";
//            }

//        }
//        void ShearStress(int[] BBottomKnots, int[] CBottom, int[] BTriangles, out double[] BTau, out double[] BTauC, out double[] arg)
//        {
//            //
//            BTauC = new double[BBottomKnots.Length];
//            BTau = new double[BBottomKnots.Length];
//            arg = new double[BBottomKnots.Length - 1];
//            int count = BBottomKnots.Length;
//            //
//            double[] Tx1 = new double[BTriangles.Length];
//            double[] Tx2 = new double[BTriangles.Length];
//            double[] Ty1 = new double[BTriangles.Length];
//            double[] Ty2 = new double[BTriangles.Length];
//            //
//            double[] tau_mid = new double[BTriangles.Length];
//            //double e1x = 1, e1y = 0, e2x = 0, e2y = 1;//проекции
//            //
//            OrderablePartitioner<Tuple<int, int>> rangePartitioner = Partitioner.Create(0, BTriangles.Length);
//            Parallel.ForEach(rangePartitioner,
//                    (range, loopState) =>
//                    {
//                        for (int i = range.Item1; i < range.Item2; i++)
//                        //for (int i = 0; i < BTriangles.Length; i++)
//                        {

//                            double[] xL = new double[3];
//                            double[] yL = new double[3];
//                            //
//                            int LcurV = BTriangles[i];
//                            int[] Knots = Mesh.AreaElems[LcurV];
//                            //
//                            int Lnum1 = Knots[0];
//                            int Lnum2 = Knots[1];
//                            int Lnum3 = Knots[2];
//                            // получаем координаты узлов элемента
//                            xL[0] = X[Lnum1]; xL[1] = X[Lnum2]; xL[2] = X[Lnum3];
//                            yL[0] = Y[Lnum1]; yL[1] = Y[Lnum2]; yL[2] = Y[Lnum3];
//                            // нахождение площади треугольника
//                            double LS = Sk[LcurV];
//                            // скорости в вершинах треугольника
//                            double LU1 = U[Lnum1];
//                            double LU2 = U[Lnum2];
//                            double LU3 = U[Lnum3];
//                            //
//                            double LV1 = V[Lnum1];
//                            double LV2 = V[Lnum2];
//                            double LV3 = V[Lnum3];
//                            // производные в центре треугольника
//                            double Ldu_dx = 1.0f / 2.0f / LS * (LU1 * (yL[1] - yL[2]) + LU2 * (yL[2] - yL[0]) + LU3 * (yL[0] - yL[1]));
//                            double Ldu_dy = 1.0f / 2.0f / LS * (LU1 * (xL[2] - xL[1]) + LU2 * (xL[0] - xL[2]) + LU3 * (xL[1] - xL[0]));
//                            double Ldv_dx = 1.0f / 2.0f / LS * (LV1 * (yL[1] - yL[2]) + LV2 * (yL[2] - yL[0]) + LV3 * (yL[0] - yL[1]));
//                            double Ldv_dy = 1.0f / 2.0f / LS * (LV1 * (xL[2] - xL[1]) + LV2 * (xL[0] - xL[2]) + LV3 * (xL[1] - xL[0]));
//                            // давление в центре треугольника
//                            double LP_mid = (P[Lnum1] + P[Lnum2] + P[Lnum3]) / 3.0f;
//                            // составляющие тензора напряжений
//                            Tx1[i] = -LP_mid + 2.0f * mu * Ldu_dx;
//                            Tx2[i] = mu * (Ldu_dy + Ldv_dx);
//                            Ty1[i] = mu * (Ldu_dy + Ldv_dx);
//                            Ty2[i] = -LP_mid + 2.0f * mu * Ldv_dy;
//                        }
//                    });
//            // Вычисление tau в узлах сетки по сглаженной методике вычисления 
//            //double[] Tau_all = Aproximate(tau_mid, CBottom, BTriangles);

//            //вычисление тензора напряжений по сглаженной методике
//            double[] Tx1_all = Aproximate(Tx1, CBottom, BTriangles);
//            double[] Tx2_all = Aproximate(Tx2, CBottom, BTriangles);
//            double[] Ty1_all = Aproximate(Ty1, CBottom, BTriangles);
//            double[] Ty2_all = Aproximate(Ty2, CBottom, BTriangles);
//            //подготовка приграничных значений tau между граничными точками и координат для сплайна

//            int cKnot = BBottomKnots[0];
//            double prevTx1 = 0, prevTx2 = 0, prevTy1 = 0, prevTy2 = 0;
//            //
//            for (int i = 0; i < BBottomKnots.Length; i++)
//            {
//                cKnot = BBottomKnots[i];
//                for (int j = 0; j < CBottom.Length; j++)
//                {
//                    if (cKnot == CBottom[j])
//                    {
//                        if (i != 0)
//                        {
//                            int prevKnot = BBottomKnots[i - 1];
//                            double delx = (X[cKnot] - X[prevKnot]);
//                            double dely = (Y[cKnot] - Y[prevKnot]);
//                            double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
//                            // компоненты касательной между граничными точками
//                            double lx = 1 / ss * delx;
//                            double ly = 1 / ss * dely;
//                            double nx = -ly;
//                            double ny = lx;
//                            //
//                            double LsigX = (prevTx1 + Tx1_all[j]) / 2.0f * nx + (prevTx2 + Tx2_all[j]) / 2.0f * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
//                            double LsigY = (prevTy1 + Ty1_all[j]) / 2.0f * nx + (prevTy2 + Ty2_all[j]) / 2.0f * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
//                            //в полуцелых узлах
//                            BTau[i - 1] = (LsigX * lx + LsigY * ly);
//                            arg[i - 1] = X[prevKnot] + delx / 2.0f;
//                            //
//                            LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
//                            LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
//                            BTauС[i] = (LsigX * lx + LsigY * ly);

//                        }
//                        else
//                        {
//                            int nextKnot = BBottomKnots[i + 1];
//                            double delx = (X[nextKnot] - X[cKnot]);
//                            double dely = (Y[nextKnot] - Y[cKnot]);
//                            double ss = (double)(Math.Sqrt(delx * delx + dely * dely));
//                            // компоненты касательной между граничными точками
//                            double lx = 1 / ss * delx;
//                            double ly = 1 / ss * dely;
//                            double nx = -ly;
//                            double ny = lx;
//                            //
//                            double LsigX = Tx1_all[j] * nx + Tx2_all[j] * ny;//умножили (Tx1;Tx2) на (0;-1) - нормаль к поверхности
//                            double LsigY = Ty1_all[j] * nx + Ty2_all[j] * ny;//умножили (Ty1;Ty2) на (0;-1) - нормаль к поверхности
//                            BTauС[i] = (LsigX * lx + LsigY * ly);
//                        }
//                        //
//                        prevTx1 = Tx1_all[j];
//                        prevTx2 = Tx2_all[j];
//                        prevTy1 = Ty1_all[j];
//                        prevTy2 = Ty2_all[j];
//                        break;
//                    }
//                }
//            }
//            BTau[count - 1] = BTau[count - 2];
//        }
//        double[] Aproximate(double[] MiddleFunction, int[] GLKnots, int[] GTriangs)
//        {
//            int Count = GLKnots.Length;
//            //
//            double[] ExactFunc = new double[Count];
//            //
//            double[][] Matrix = new double[3][];
//            for (int i = 0; i < 3; i++)
//                Matrix[i] = new double[3];
//            //
//            try
//            {
//                SBand AlgB = new SBand();
//                AlgB.SetSystem(Count, BWidth);
//                // Вычисляем локальные матрицы жесткости и производим сборку глобальной матрицы жесткости
//                int tr = 0;
//                int[] GKnots, LKnots = new int[3];
//                double S = 0; ;
//                for (int k = 0; k < GTriangs.Length; k++)
//                {
//                    tr = GTriangs[k];
//                    S = Sk[tr];
//                    //S = Mesh.GetSquare(tr);
//                    //переходим к локальной нумерации для СЛАУ
//                    GKnots = Mesh.AreaElems[tr];
//                    for (int i = 0; i < 3; i++)
//                    {
//                        for (int j = 0; j < Count; j++)
//                        {
//                            if (GKnots[i] == GLKnots[j])
//                            {
//                                LKnots[i] = j;
//                                break;
//                            }
//                        }
//                    }
//                    //
//                    // Вычисляем локальную матрицу жесткости 
//                    // Расчет локальной матрицы жесткости для диффузионного члена
//                    Matrix[0][0] = 1.0 / 6.0 * S;
//                    Matrix[0][1] = 1.0 / 12.0 * S;
//                    Matrix[0][2] = 1.0 / 12.0 * S;

//                    Matrix[1][0] = 1.0 / 12.0 * S;
//                    Matrix[1][1] = 1.0 / 6.0 * S;
//                    Matrix[1][2] = 1.0 / 12.0 * S;

//                    Matrix[2][0] = 1.0 / 12.0 * S;
//                    Matrix[2][1] = 1.0 / 12.0 * S;
//                    Matrix[2][2] = 1.0 / 6.0 * S;
//                    // Формирование глобальной матрицы жесткости
//                    AlgB.BuildMatrix(Matrix, LKnots);
//                    //Mesh.SaveMesh("nn");
//                    //
//                    double[] tmpU = { MiddleFunction[k] * S / 3.0f, MiddleFunction[k] * S / 3.0f, MiddleFunction[k] * S / 3.0f };
//                    //
//                    AlgB.BuildRight(tmpU, LKnots);
//                }
//                // Решение системы алгебраических уравнений
//                AlgGauss.Solve(AlgB);
//                ExactFunc = AlgB.GetX;
//            }
//            catch (Exception e)
//            {
//                err = e.Message + "Aproximate fell down";
//            }
//            return ExactFunc;
//        }
//        /// <summary>
//        /// метод расчета L2 погрешности (используя метод трапеций)
//        /// </summary>
//        /// <param name="Exact">Точное решение</param>
//        /// <param name="Calc">Расчетное решение</param>
//        /// <param name="dx"></param>
//        /// <returns></returns>
//        public double[] L2_discrepancy(double[] Exact, double[] Calc, double dx)
//        {
//            int N = Exact.Length;
//            double[] L2 = new double[N];
//            //
//            double intE = 0, intC = 0;
//            for (int i = 0; i < N - 1; i++)
//            {
//                intE = (Exact[i] + Exact[i + 1]) / 2.0 * dx;
//                intC = (Calc[i] + Calc[i + 1]) / 2.0 * dx;
//                L2[i] = Math.Sqrt((intE - intC) * (intE - intC)) * 100;
//            }
//            // фронтальная нумерация между верхей и нижней границей интеграл не высчитывается
//            for (int i = 0; i < NTop; i++)
//                L2[Mesh.TopKnots[i]] = 0;
//            //
//            return L2;
//        }
//    }
//    public class FPoint
//    {
//        public double X;
//        public double Y;
//        public FPoint(double x, double y)
//        {
//            X = x; Y = y;
//        }
//    }
//}
